{"/config/app":{"title":"应用配置详情","data":{"":"","entry#entry":"object | string | string[]可用于修改、拓展 Webpack 的 enrty 选项，配置项参考 官方文档。\nmodule.exports = {\n// ...\nentry: {\nhome: './home.js',\nabout: ['./about.js'],\ncontact: ['./contact.js']\n}\n}"}},"/config/lib":{"title":"库配置详情","data":{"":"","entry#entry":"string | string[]可用于修改、拓展 Rollup 的 input 选项。\nexport default {\n// ...\nentry: 'src/index.ts'\n}"}},"/document/basic-function/config-configure":{"title":"Config 配置","data":{"":"config 主要用来管理插件的启停，插件的配置管理，项目常用变量的聚合等能力。它的核心特性就是区分环境。\n区分环境配置核心依赖 RUNTIME_ENV 环境变量。","区分环境#区分环境":"在src/config 文件目录下新增如下文件：\nconfig.default.ts : 默认配置项 （优先级最低）\nconfig.local.ts   : 本地环境生效\nconfig.test.ts    : 测试环境生效\nconfig.release.ts : 预发布环境生效\nconfig.prod.ts    : 生产环境生效\n\n\n一般建议最少有一个 config.default.ts 文件。","配置特性#配置特性":"优先级： 应用 config > 插件 config > 框架 config\n环境隔离： 通过不同的环境加载不同的配置项，做到环境的隔离（备注：default 配置项在任何环境都会生效）\n区分环境：环境配置项里面的配置会覆盖掉 default 里面的配置项\n所有的配置文件均为非必须项（建议：最少有一个 default 配置文件）","cluster-配置#Cluster 配置":"/**\n* cluster config\n*/\nconfig.cluster = {\nenable: false,\n};\n\n字段\t类型\t必填\t默认值\t说明\tenable\tboolean\t否\tfalse\t是否以 cluster 模型启动应用","进程数量说明#进程数量说明":"开发模式下启动一个 alone 进程一个 worker 进程\n生产环境容器模式下会自动获取容器核数, 启动一个 alone 进程容器核数个 worker 进程\n非容器环境启动 cpu 核数个进程","routingcontrollersoptions-配置#RoutingControllersOptions 配置":"/*\n* routing-controllers configs\n* 1. controllers、middlewares、authorizationChecker 需要使用`path.join`进行文件位置的绝对定位\n*/\nconfig.routingControllersOptions = {\ncurrentUserChecker,\ndefaultErrorHandler: false,\ncontrollers: [path.join(__dirname, '../controller/*')],\nmiddlewares: [path.join(__dirname, '../middleware/*')],\n// middlewares: [\n//   require(path.join(__dirname,'../middleware/xxxMiddleware')).default,\n// ]\ndefaults: {\nnullResultCode: 200,  // 204 | 404\nundefinedResultCode: 200 // 204 | 404\n}\n};\n\nRoutingControllersOptions 参数说明\n\n\n字段\t类型\t必填\t说明\tcurrentUserChecker\tfunction\t否\t向 ctx.state.payload 中注入数据\tcontrollers\tstring[]\t否\tcontrollers 文件列表\tmiddlewares\tstring[]\t否\tmiddlewares 文件列表\tdefaults\tObject\t否\t异常处理配置信息","error-配置#Error 配置":"/**\n* error handle\n*/\nconfig.error = {\nenable: true,\n\n// use yunfly default error log.\nuseYunflyLog: true,\n\n/**\n* 错误码\n* Type: number | true | Record<Key, Key>\n*/\nerrCode: true,\n\n// 是否开启 HTTP 状态码\nenableHttpCode: false,\n\n// 是否返回 rpc 错误信息\nuseRpcErrorMessage: true,\n\n// 是否返回错误详情\nshowMessageDetail: true,\n\n/* Customize your error fn. （Optional） */\n// customError: async (err: any, ctx: Context) => {}\n\nunhandledRejection: (err: any) => {\nconsole.error('UnhandledRejection error, at time', Date.now(), 'reason:', err);\n},\nuncaughtException: (err: any) => {\nconsole.error('uncaughtException error, at time', Date.now(), 'reason:', err);\n},\n};\n\n字段\t类型\t默认值\t必填\t说明\tenable\tboolean\ttrue\t是\t是否开启错误处理\terrCode\tnumber/true/Record<Key, Key>\t2\t否\t错误码\tuseYunflyLog\tboolean\ttrue\t否\t是否开启日志记录\tenableHttpCode\tboolean\tfalse\t否\t是否开启 HTTP 状态码\tuseRpcErrorMessage\tboolean\ttrue\t否\t是否返回 rpc 错误信息\tshowMessageDetail\tboolean\tfalse\t否\t是否返回错误详情\tcustomError\t(err: any, ctx: Koa.Context) => any\t\t否\t自定义错误，若定义，则不会执行yunfly-plugin-error中间件后续逻辑\tcustomErrorHandle\t(err: any, ctx: Koa.Context) => any\t\t否\t可用于重新组装错误，并不影响yunfly-plugin-error中间件后续逻辑的执行\tunhandledRejection\t(err: any, ctx: Koa.Context) => any\t\t否\t自定义 Promise 错误\tuncaughtException\t(err: any, ctx: Koa.Context) => any\t\t否\t自定义未能捕获的异常","bodyparser-配置#BodyParser 配置":"// body参数配置\nconfig.bodyParser = {\njsonLimit: '1mb',\nformLimit: '1mb',\nqueryString: {\nparameterLimit: 1 * 1024 * 1024,\n},\n};\n\n字段\t类型\t必填\t说明\tjsonLimit\tstring\t否\tjson 格式数据上传大小限制\tjsonLimit\tstring\t否\t表单提交数据大小限制\tqueryString\tObject\t否\turl 上传数据大小限制","currentcontext-配置#CurrentContext 配置":"/**\n* 在controller,service,util等代码位置直接获取context对象\n*/\nconfig.currentContext = {\nenable: true,\n}\n\n字段\t类型\t必填\t说明\tenable\tboolean\t是\t是否启用插件","socket-配置#Socket 配置":"// socket\nconfig.socket = {\nenable: false,\ntype: 'worker', // 可选值 worker: 随机选择一个worker执行， all: 所有worker都执行, 默认为worker\npath: '/',\n};"}},"/document/basic-function/controller":{"title":"控制器(Controller)","data":{"":"yunfly 路由底层框架库为 routing-controllers，使用 Typescript 注解能力来进行路由的开发。\nController 主要用于参加校验, 简单逻辑处理, 调用 Service 方法。","初始化项目#初始化项目":"安装 yunfly 框架\n\n\n\n\nyarn add @yunflyjs/yunfly\n\n\n配置 src/config.default.ts 中 routingControllersOptions 配置项\n\n\n\n\nconfig.routingControllersOptions = {\ncurrentUserChecker,\ndefaultErrorHandler: false,\ncontrollers: [path.join(__dirname, '../controller/*')],\nmiddlewares: [path.join(__dirname, '../middleware/*')],\ndefaults: {\nnullResultCode: 200,  // 204 | 404\nundefinedResultCode: 200 // 204 | 404\n}\n};\n\n\ntsconfig.json 中需要设置以下配置项\n\n\n\n\n{\n\"emitDecoratorMetadata\": true,\n\"experimentalDecorators\": true\n}","快速使用#快速使用":"src/controller 下新建 ExampleController.ts 文件\n\n\n\n\nimport { Controller, Param, Body, Get, Post, Put, Delete } from '@yunflyjs/yunfly';\n\n@Controller()\nexport class ExampleController {\n@Get('/users')\ngetAll() {\nreturn 'This action returns all users';\n}\n\n@Get('/users/:id')\ngetOne(@Param('id') id: number) {\nreturn 'This action returns user #' + id;\n}\n\n@Post('/users')\npost(@Body() user: any) {\nreturn 'Saving user...';\n}\n\n@Put('/users/:id')\nput(@Param('id') id: number, @Body() user: any) {\nreturn 'Updating a user...';\n}\n\n@Delete('/users/:id')\nremove(@Param('id') id: number) {\nreturn 'Removing user...';\n}\n}\n\n\n启动项目\n\n\n\n\n// 启动\nyarn dev\n\n// 监听模式启动\nyarn watch:dev\n\n\n访问\n\n\n\n\n# 浏览器将显示 This action returns all users。\nhttp://localhost:3000/users。\n\n# 将显示 This action returns user #1\nhttp://localhost:3000/users/1","使用-json#使用 JSON":"对于一个总是返回 JSON 的 REST API，建议用 @JsonController 代替 @Controller。 @JsonController 装饰的控制器路由的响应数据将自动转换为 JSON 类型且 Content-Type 被设置为 application/json。\n同时请求的 application/json 头信息也可以被解释，请求 Body 将解析为 JSON。\nimport { JsonController, Param, Body, Get, Post, Put, Delete } from '@yunflyjs/yunfly';\n\n@JsonController()\nexport class ExampleController {\n@Get('/users')\ngetAll() {\nreturn userRepository.findAll();\n}\n\n@Get('/users/:id')\ngetOne(@Param('id') id: number) {\nreturn userRepository.findById(id);\n}\n\n@Post('users')\npost(@Body() user: User) {\nreturn userRepository.insert(user);\n}\n}","返回-promise#返回 Promise":"返回一个 Promise，响应将等待该 Promise 回执后返回其结果。\nimport { JsonController, Param, Body, Get, Post, Put, Delete } from '@yunflyjs/yunfly';\n\n@JsonController()\nexport class ExampleController {\n@Get('/users')\nasync getAll() {\nreturn await userRepository.findAll();\n}\n\n@Get('/users/:id')\nasync getOne(@Param('id') id: number) {\nreturn await userRepository.findById(id);\n}\n\n@Post('/users')\nasync post(@Body() user: User) {\nreturn await userRepository.insert(user);\n}\n\n@Put('/users/:id')\nasync put(@Param('id') id: number, @Body() user: User) {\nreturn await userRepository.updateById(id, user);\n}\n\n@Delete('/users/:id')\nasync remove(@Param('id') id: number) {\nreturn await userRepository.removeById(id);\n}\n}","从目录加载控制器#从目录加载控制器":"在 config.routingControllersOptions.controllers 中指定文件夹，即可加载该目录下所有控制器：\nconfig.routingControllersOptions = {\ncontrollers: [path.join(__dirname, '../controller/*')],\n};","从目录加载中间件#从目录加载中间件":"在 config.routingControllersOptions.middlewares 中指定文件夹，即可加载该目录下所有全局中间件：\nconfig.routingControllersOptions = {\nmiddlewares: [path.join(__dirname, '../middleware/*')],\n};","路由前缀#路由前缀":"全局路由前缀\n\n要为所有路由添加前缀，比如 /api，可以使用 routePrefix 配置项：\nconfig.routingControllersOptions = {\nroutePrefix: '/api',\n}\n\n指定控制器路由前缀\n\n向控制器装饰器传递根路由参数，控制器下的路由将添加该跟路由前缀：\nimport { Controller } from \"@yunflyjs/yunfly\";\n\n@Controller('/users')\nexport class UserController {\n// ...\n}","method-装饰器#Method 装饰器":"如下图，我们需要对控制器下的不同 HTTP 方法做不同处理。如 @Get('/users/:id') 会为 GET /users/:id 请求生成路由映射，这意味着如果 GET /users/:id 请求则会走 handleGet 逻辑。同理，@Post('/users') 会为 POST /users 请求生成路由映射，POST /users 请求则会走 handlePost 逻辑。以此类推，我们针对其他 HTTP 方法 PUT DELETE PATCH HEAD 分别注入路由处理逻辑。\nimport { Controller, Param, Body, Get, Patch, Post, Head, Put, Delete } from '@yunflyjs/yunfly';\n\n@Controller()\nexport class ExampleController {\n\n@Get('/users/:id')\nhandleGet(@Param('id') id: number) {\nreturn userRepository.findById(id);\n}\n\n@Post('/users')\nhandlePost(@Body() user: User) {\nreturn userRepository.insert(user);\n}\n\n@Put('/users/:id')\nhandlePut(@Param('id') id: number, @Body() user: User) {\nreturn userRepository.updateById(id, user);\n}\n\n@Delete('/users/:id')\nhandleDelete(@Param('id') id: number) {\nreturn userRepository.removeById(id);\n}\n\n@Patch('/users/:id')\nhandlePatch() {\nreturn userRepository.updateById(id, user);\n}\n\n@Head('/users/:id')\nhandleHead() {\nreturn userRepository.removeById(id);\n}\n}\n更多方法装饰器说明：\n标识\t示例\t描述\t@Get(route: string|RegExp)\t@Get(\"/users\") all()\t匹配 HTTP GET 方法\t@Post(route: string|RegExp)\t@Post(\"/users\") save()\t匹配 HTTP Post 方法\t@Put(route: string|RegExp)\t@Put(\"/users/:id\") update()\t匹配 HTTP Put 方法\t@Patch(route: string|RegExp)\t@Patch(\"/users/:id\") patch()\t匹配 HTTP Patch 方法\t@Delete(route: string|RegExp)\t@Delete(\"/users/:id\") delete()\t匹配 HTTP Delete 方法\t@Head(route: string|RegExp)\t@Head(\"/users/:id\") head()\t匹配 HTTP Head 方法\t@All(route: string|RegExp)\t@All(\"/users/me\") rewrite()\t匹配所有 HTTP 方法","动态路由#动态路由":"controller 动态路由\n\n如果要匹配动态路由的话，可通过:[参数]的方式注入。如：\nimport { Controller } from \"@yunflyjs/yunfly\";\n\n@Controller('/users/:id')\nexport class ExampleController {\n// ...\n}\n\nmethod 动态路由\n\n\nimport { Controller, Get, Param } from \"@yunflyjs/yunfly\";\n\n@Controller('/users')\nexport class ExampleController {\n\n@Get(\"/:id\")\ngetOne(@Param(\"id\") id: number) {\n// ...\n}\n}","使用-req-和-res-对象#使用 Req 和 Res 对象":"直接使用框架的 Request 对象和 Response 对象。 如果想自己处理响应，可以在方法中返回该 Response 对象。\nimport { Controller, Req, Res, Get } from '@yunflyjs/yunfly';\n\n@Controller()\nexport class ExampleController {\n@Get('/users')\ngetAll(\n@Req() request: any,\n@Res() response: any\n) {\nreturn response.send('Hello response!');\n}\n}\n\n@Req() 装饰器注入了一个 Request 对象，@Res() 装饰器注入了一个 Response 对象。 如果安装了对应的类型声明，也可以对它们进行声明：","获取-param-参数#获取 Param 参数":"用于获取动态路由参数","param#@Param":"@Get(\"/users/:id\")\ngetOne(\n@Param(\"id\") id: number\n) {\n// 这里可以访问 id\n}","params#@Params":"@Get(\"/users/:id/:name\")\ngetOne(\n@Params() params: {id: number; name: string }\n) {\n// 这里可以访问 params.id, params.name\n}","获取-query-参数#获取 Query 参数":"获取通过 get 传递的参数","queryparam#@QueryParam":"@Get(\"/users\")\ngetUsers(\n@QueryParam(\"name\") name: string\n) {\n// 这里可以访问 name\n}","queryparams#@QueryParams":"@Get(\"/users\")\ngetUsers(\n@QueryParams() query: {name: string; age: number}\n) {\n// 这里可以访问query.name, query.age\n}","get请求单参多值#get请求单参多值":"可以使用 config.sameQueryParam 对 get 参数进行处理\n获取参数值始终为字符串\n\n\nconfig.sameQueryParam = {\nebable: true,\nisArray: false,\n}\n\n@Get(\"/users/by-multiple-ids\")\ngetUsers(@QueryParam(\"ids\", { isArray: true}) ids: string[]) {\n}\n\n// GET /users/by-multiple-ids?ids=a → ids = 'a'\n// GET /users/by-multiple-ids?ids=a&ids=b → ids = 'a,b'\n\n获取参数值始终为数组\n\n\nconfig.sameQueryParam = {\nebable: true,\nisArray: true,\n}\n\n@Get(\"/users/by-multiple-ids\")\ngetUsers(@QueryParam(\"ids\", { isArray: true}) ids: string[]) {\n}\n\n// GET /users/by-multiple-ids?ids=a → ids = ['a']\n// GET /users/by-multiple-ids?ids=a&ids=b → ids = ['a', 'b']","获取-post-参数#获取 Post 参数":"获取通过 post 传递的参数","body#@Body":"@Post(\"/users\")\nsaveUser(\n@Body() user:{name: string; age: number}\n) {\n// 这里可以访问 user.name, user.age\n}","bodyparam#@BodyParam":"@Post(\"/users\")\nsaveUser(\n@BodyParam(\"name\") name: string,\n@BodyParam(\"age\") age: number,\n) {\n// 这里可以访问 name, age\n}","获取-header-参数#获取 Header 参数":"获得 htttp header 头部信息","headerparam#@HeaderParam":"@Post(\"/users\")\nsaveUser(\n@HeaderParam(\"authorization\") token: string\n) {\n// 这里可以获得 token\n}","headerparams#@HeaderParams":"@Post(\"/users\")\nsaveUser(\n@HeaderParams() header: {token: string}\n) {\n// 这里可以获得 header.token\n}","获得-cookie-信息#获得 Cookie 信息":"用于获取 http cookie 头信息","cookieparam#@CookieParam":"@Get(\"/users\")\ngetUsers(\n@CookieParam(\"username\") username: string\n) {\n// 这里可以获得 username\n}","cookieparams#@CookieParams":"@Get(\"/users\")\ngetUsers(\n@CookieParams() cookies: { username: string }\n) {\n// 这里可以获得 cookies.username\n}","获得-session--信息#获得 Session  信息":"用于获取 session 值","sessionparam#@SessionParam":"@Get(\"/login\")\nsavePost(\n@SessionParam(\"user\") user: User,\n@Body() post: Post\n) {}","session#@Session":"@Get(\"/login\")\nsavePost(\n@Session() session: any,\n@Body() post: Post\n) {}\n\n@Session 装饰器装饰的参数默认为必填。如果你的方法中该参数是可选的，需要手动标记为非必填\n\naction(\n@Session(\"user\", { required: false }) user: User\n){}","限制必填参数#限制必填参数":"在装饰器配置 required: true 限制参数为必填：\n@Post(\"/users\")\nsave(\n@Body({\nrequired: true\n}) user: any\n) {\n// 如果请求内没有user参数，该方法不会执行\n}\n\n可以在其它任何参数装饰器中限制必填参数，如 @QueryParam, @BodyParam 等。 如果请求中没有必填参数，yunfly 框架将抛出一个错误。","设置-contenttype#设置 ContentType":"为路由设置 ContentType：\n@Get(\"/users\")\n@ContentType(\"text/cvs\")\ngetUsers() {\n// ...\n}","设置-location#设置 Location":"为路由设置 Location：\n@Get(\"/users\")\n@Location(\"http://github.com\")\ngetUsers() {\n// ...\n}","设置重定向#设置重定向":"为路由设置重定向：\n@Get(\"/users\")\n@Redirect(\"http://github.com\")\ngetUsers() {\n// ...\n}\n通过返回字符串覆写重定向地址：\n@Get(\"/users\")\n@Redirect(\"http://github.com\")\ngetUsers() {\nreturn \"https://www.google.com\";\n}\n使用模板生成重定向：\n@Get(\"/users\")\n@Redirect(\"http://github.com/:owner/:repo\")\ngetUsers() {\nreturn {\nowner: \"pleerock\",\nrepo: \"@yunflyjs/yunfly\"\n};\n}","设置-http-响应代码#设置 HTTP 响应代码":"可以显式设置 HTTP 响应代码：\n@HttpCode(201)\n@Post(\"/users\")\nsaveUser(@Body() user: User) {\n// ...\n}","管理空响应#管理空响应":"对于返回 void 或 Promise<void> 或 undefined 的控制器方法，将自动向客户端抛出 404 错误。 @OnUndefined 装饰器可用于设置这种情况下的状态码。\n@Delete(\"/users/:id\")\n@OnUndefined(204)\nasync remove(@Param(\"id\") id: number): Promise<void> {\nreturn userRepository.removeById(id);\n}\n对于返回值可能为 undefined 的情况，@OnUndefined 也可以发挥作用。下面例子中，当用户 id 不存在时 findOneById 返回 undefined，该路由将返回 404 代码，如果存在则返回 200 代码：\n@Get(\"/users/:id\")\n@OnUndefined(404)\ngetOne(@Param(\"id\") id: number) {\nreturn userRepository.findOneById(id);\n}\n当结果为 undefined 时也可以返回一个错误类：\nimport { HttpError } from '@yunflyjs/yunfly';\n\nexport class UserNotFoundError extends HttpError {\nconstructor() {\nsuper(404, 'User not found!');\n}\n}\n@Get(\"/users/:id\")\n@OnUndefined(UserNotFoundError)\nsaveUser(@Param(\"id\") id: number) {\nreturn userRespository.findOneById(id);\n}\n如果控制器方法返回 null 可以用 @OnNull 装饰器替代。","自定义-header#自定义 Header":"定义任意 Header 信息：\n@Get(\"/users/:id\")\n@Header(\"Catch-Control\", \"none\")\ngetOne(@Param(\"id\") id: number){\n// ...\n}","抛出-http-错误#抛出 HTTP 错误":"抛出 HTTP 错误请参考 错误类使用章节：错误类使用","使用中间件#使用中间件":"@Middleware 装饰器用于自定义中间件， @UseBefore 和 @UseAfter 装饰器使用任何已有的或自定义的 Koa 中间件。","usebefore#@UseBefore":"中间件执行之前做什么事情\nimport { Controller, Get, UseBefore } from \"@yunflyjs/yunfly\";\n// ...\n\n@Get(\"/users/:id\")\n@UseBefore(CheckParams)\ngetOne(@Param(\"id\") id: number) {\n// ...\n}","useafter#@UseAfter":"中间件执行之后做什么事情\nimport { Controller, Get, UseBefore } from \"@yunflyjs/yunfly\";\n// ...\n\n@Get(\"/users/:id\")\n@UseAfter(RecordLog)\ngetOne(@Param(\"id\") id: number) {\n// ...\n}","在方法中使用中间件#在方法中使用中间件":"import { Controller, Get, UseBefore } from \"@yunflyjs/yunfly\";\nlet compression = require(\"compression\");\n\n// ...\n\n@Get(\"/users/:id\")\n@UseBefore(compression())\ngetOne(@Param(\"id\") id: number) {\n// ...\n}","在控制器中使用中间件#在控制器中使用中间件":"import { Controller, UseBefore } from '@yunflyjs/yunfly';\nlet compression = require('compression');\n\n@Controller()\n@UseBefore(compression())\nexport class UserController {}","自定义中间件#自定义中间件":"","定义一个普通中间件#定义一个普通中间件":"import { KoaMiddlewareInterface } from \"@yunflyjs/yunfly\";\nexport class MyMiddleware implements KoaMiddlewareInterface {\nasync use(context: any, next: (err?: any) => Promise<any>): Promise<any> {\nconsole.log(\"do something before execution...\");\nreturn await next()\nconsole.log(\"do something after execution...\");\n}\n}","普通中间件应用#普通中间件应用":"Controller 中应用\n\n\nimport {Controller, UseBefore, UseAfter} from \"@yunflyjs/yunfly\";\nimport {MyMiddleware} from \"./MyMiddleware\";\nimport {loggingMiddleware} from \"./loggingMiddleware\";\n//...\n@Controller()\n@UseBefore(MyMiddleware)\n@UseAfter(loggingMiddleware)\nexport class UserController {\n// ...\n}\n\n方法中使用\n\n\nimport { Get, UseBefore, UseAfter} from \"@yunflyjs/yunfly\";\nimport {MyMiddleware} from \"./MyMiddleware\";\nimport {loggingMiddleware} from \"./loggingMiddleware\";\n@Get(\"/users/:id\")\n@UseBefore(MyMiddleware)\n@UseAfter(loggingMiddleware)\ngetOne(@Param(\"id\") id: number) {\n// ...\n}","定义一个全局中间件#定义一个全局中间件":"import { KoaMiddlewareInterface,Middleware } from \"@yunflyjs/yunfly\";\n\n@Middleware({ type: 'before' })\nexport class MyMiddleware implements KoaMiddlewareInterface {\nasync use(context: any, next: (err?: any) => Promise<any>): Promise<any> {\nconsole.log(\"do something before execution...\");\nawait next()\nconsole.log(\"do something after execution...\");\n}\n}","全局中间件应用#全局中间件应用":"config.routingControllersOptions = {\nmiddlewares: [path.join(__dirname, '../middleware/*')],\n};","更多中间件装饰器说明#更多中间件装饰器说明":"标识\t示例\t描述\t@Middleware({type: \"before\"|\"after\"})\t@Middleware({ type: \"before\"}) class SomeMiddleware\t注册全局中间件\t@UseBefore()\t@UseBefore(CompressionMiddleware)\t请求开始前调用\t@UseAfter()\t@UseAfter(CompressionMiddleware)\t请求结束后调用\t@Interceptor()\t@Interceptor() class SomeInterceptor\t注册全局拦截器\t@UseInterceptor()\t@UseInterceptor(BadWordsInterceptor)\t拦截 Controller / Action，替换某些值","其他装饰器#其他装饰器":"有时候我们需要对接口进行鉴权，这时就需要用到 @Authorized 装饰器了。\n如下图，我们示范如何在 yunfly 使用 @Authorized。\n\nconfig.default.ts 增加对 routingControllersOptions 配置：\n\n\n\n\n{\nconfig.routingControllersOptions = {\n// 代码Demo\nauthorizationChecker: async (action: Action, roles: string[]) => {\n// 这里可以使用action中的request/response对象\n// 如果装饰器定义了可以访问action角色\n// 也可以使用它们来提供详细的鉴权\n// checker必须返回boolean类型(true or false)或者Promise(回执也必须是boolean)\nconst token = action.request.headers['authorization'];\n\nconst user = await getEntityManager().findOneByToken(User, token);\nif (user && !roles.length) return true;\nif (user && roles.find(role => user.roles.indexOf(role) !== -1)) return true;\n\nreturn false;\n})\n}\n}\n\n\n在路由中使用 @Authorized\n\n\n\n\nimport { Controller, Post, Authorized, Body } from '@yunflyjs/yunfly';\n\n@Controller()\nexport class UserController {\n@Authorized()\n@Post('/questions')\nsave(@Body() question: Question) {}\n\n@Authorized('POST_MODERATOR') // 指定角色或角色数组\n@Post('/posts')\nsave(@Body() post: Post) {}\n}\n更多装饰器说明\n标识\t示例\t描述\t@Authorized(roles?: string|string[])\t@Authorized(\"SUPER_ADMIN\") get()\t授权检查\t@CurrentUser(options?: { required?: boolean })\tget(@CurrentUser({ required: true }) user: User)\t注入当前授权的用户\t@Header(headerName: string, headerValue: string)\t@Header(\"Cache-Control\", \"private\") get()\t自定义相应头部信息\t@ContentType(contentType: string)\t@ContentType(\"text/csv\") get()\t自定义响应头部 HTTP Content-Type 信息\t@Location(url: string)\t@Location(\"http://github.com\") get()\t自定义响应头部 HTTP Location 信息\t@Redirect(url: string)\t@Redirect(\"http://github.com\") get()\t自定义响应头部 HTTP Redirect 信息\t@HttpCode(code: number)\t@HttpCode(201) post()\t自定义响应 HTTP code\t@OnNull(codeOrError: number|Error)\t@OnNull(201) post()\t当真实响应的 HTTP code  为 null 时，设置 HTTP code\t@OnUndefined(codeOrError: number|Error)\t@OnUndefined(201) post()\t当真实响应的 HTTP code  为 undefined 时，设置 HTTP code\t@Render(template: string)\t@Render(\"user-list.html\") get()\t渲染给定的 HTML 模板，控制器返回的数据用作模板变量","自定义装饰器#自定义装饰器":"您也可以通过包装现有装饰器或者采用 @yunflyjs/yunfly 提供的方法创建新的装饰器，如下：\n\n使用 @yunflyjs/yunfly 提供的 createParamDecorator 创建参数装饰器\n\n\n\n\nimport { createParamDecorator } from '@yunflyjs/yunfly';\n\nexport function UserFromSession(options?: { required?: boolean }) {\nreturn createParamDecorator({\nrequired: options && options.required ? true : false,\nvalue: action => {\nconst token = action.request.headers['authorization'];\nreturn database.findUserByToken(token);\n},\n});\n}\n\n\n\n通过包装现有装饰器\n\n\n\n\nimport { UseAfter } from '@yunflyjs/yunfly';\nimport { IResponseType } from '../types';\nimport { handleResponseType } from './handle';\n\nexport const ResponseType = function (type: IResponseType) {\n// 进行包装\nreturn UseAfter(handleResponseType(type, true));\n};\n更多详细用法请参考：https://www.npmjs.com/package/routing-controllers#using-middlewares"}},"/document/basic-function/directory-struct":{"title":"目录结构","data":{"":"├── package.json\n├── README.md\n├── tsconfig.json\n├── .gitignore\n├── src\n│    ├── config\n│    │  └── config.default.ts\n│    │  └── config.local.ts (可选)\n│    │  └── config.test.ts  (可选)\n│    │  └── config.release.ts (可选)\n│    │  └── config.prod.ts (可选)\n│    │  └── config.middleware.ts (可选)\n│    ├── controller\n│    │  └── ExampleController.ts\n│    ├── middleware\n│    │  └── ExampleMIddleware.ts\n│    ├── service\n│    │  └── ExampleService.ts\n│    ├── alone\n│    │  └── alone1.ts\n│    │  └── alone2.ts\n│    ├── schedule\n│    │  └── task1.ts\n│    │  └── task2.ts\n│    ├── plugin\n│    │   └── yunfly-plugin-email\n│    │       ├── src\n│    │       │   ├── config\n│    │       │   │   └── config.default.ts\n│    │       │   └── app.ts\n│    │       ├── tsconfig.json\n│    │       ├── README.md\n│    │       └── package.json\n│    └── app.ts\n\n\ntsconfig.json Ts规则配置项  详细配置参考\ncontroller BFF controller 层\nmiddleware 中间件\nservice BFF service 层\nalone alone 进程执行文件\nschedule 定时任务文件 （一个文件表示一个定时任务）\nconfig BFF 配置器\napp.ts 可配置服务启动文件","备注#备注":"为保持代码规范一致性 controller、service 文件尽量以大写字母开头，分别以 Controller、Service 后缀结尾。\n根据自身业务的复杂度来决定 controller 和 service 下是否再拆分文件夹。"}},"/document/basic-function/logger":{"title":"日志","data":{"":"logger 日志库，同时把日志输出到控制台与日志系统中，可以自定义控制台输出能力。","使用#使用":"","使用-logger-api#使用 logger api":"import { logger } from '@yunflyjs/yunfly';\n\nlogger.log('1111');\nlogger.info('hello %d', 'world!');\nlogger.error('some error!');\nlogger.access('access log');\n\n因为框架代理了 console 方法，因此以下使用方式同效。\n\nconsole.log('1111');\nconsole.info('hello %d', 'world!');\nconsole.error('some error!');\nconsole.access('access log');","链式调用#链式调用":"import { logger } from '@yunflyjs/yunfly';\n\n// 颜色输出\nlogger.color('#2e8555').log('1111');\n\n// 日志前缀\nlogger.prefix('yunfly').info('hello %d', 'world!');\n\n// 控制台同步输出\nlogger.window().error('some error!');","日志储存类型#日志储存类型":"框架日志主要分为3种类型的日志：\n\n记录常规业务需求日志的 business.log 日志\n\n\n\n记录错误信息的 error.log 日志\n\n\n\n记录框架请求链路的 access.log 日志","console-与日志储存关系#console 与日志储存关系":"","businesslog#business.log":"console.log\nconsole.info\nconsole.warn\nconsole.trace\nconsole.debug\n\n// 等价于\nlogger.log\nlogger.info\nlogger.warn\nlogger.trace\nlogger.debug\n以上打印日志都会存储到 business.log\n推荐使用 logger.info 进行日志的打印","errorlog#error.log":"console.error\n\n// 等价于\nlogger.error","accesslog#access.log":"console.access\n\n// 等价于\nlogger.access","方法说明#方法说明":"","color#color":"控制台输出日志时附带颜色（开发模式下有效）\nimport { logger } from '@yunflyjs/yunfly';\n\n// 自定义输出颜色\nlogger.color('#2e8555').log('自定义输出颜色');\n\n// 随机输出颜色\nlogger.color().log('随机输出颜色');","window#window":"生产环境下日志默认输出到日志文件中，控制台不输出日志，可以通过 window 方法来定义控制台是否输出日志。\nimport { logger } from '@yunflyjs/yunfly';\n\nlogger.window().log('控制台中也输出日志');","prefix#prefix":"输出日志附加前缀并给当前日志打标识\nimport { logger } from '@yunflyjs/yunfly';\n\nlogger.prefix('yunfly').log('这是输出的日志内容!');\n// output: 【yunfly】: 这是输出的日志内容!\n\n备注：\n\nprefix: 当前log名称, 可通过 process.env.YUNFLY_DEBUG 和 process.env.YUNFLY_DEBUG_TYPE 进行控制输出, 跟 debug 库类似。\n案例二：通过 YUNFLY_DEBUG 环境变量控制日志输出\n\n\nimport { logger } from '@yunflyjs/yunfly';\n\nprocess.env.YUNFLY_DEBUG = 'yunfly';\n\nlogger.prefix('yunfly').info('控制台输出当前日志!');\n// output: 【yunfly】: 控制台输出当前日志!\n\nlogger.prefix('yundoc').info('控制台不会输出当前日志!');\n// output:","onlysign#onlySign":"当使用 prefix 给日志添加标识时，日志输出会附加标识前缀, 如果只想做日志标识而不想输出前缀，这时可通过 onlySign 进行控制。\nimport { logger } from '@yunflyjs/yunfly';\n\nlogger.prefix('yunfly').info('控制台输出有前缀的日志!');\n// output: 【yunfly】: 控制台输出有前缀的日志!\n\nlogger.prefix('yunfly').onlySign().info('控制台不会输出有前缀的日志!');\n// output: 控制台不会输出有前缀的日志!","logfilter#logFilter":"日志信息过滤函数。\n通过链式调用配置日志过滤器\n\n\nimport { logger } from '@yunflyjs/yunfly';\n\nconst logFilter = (logType?: any, ...optionalParams: any[]) =>\noptionalParams.map((item: any) => {\nif (typeof item === 'string') {\n// 过滤密码等敏感字符\nreturn item.replace(/(\"password\\\\?\":\\\\?\")([^\\\\?\"]+)(\\\\?\")/g, (target, $1, $2, $3) => `${$1}${new Array($2.length).join('*')}${$3}`);\n}\nreturn item;\n});\n\nlogger.logFilter(logFilter).info('password: 123456');\n\n通过 api 设置日志过滤器\n\n\nimport { logger } from '@yunflyjs/yunfly';\n\nconst logFilter = (logType?: any, ...optionalParams: any[]) =>\noptionalParams.map((item: any) => {\nif (typeof item === 'string') {\n// 过滤密码等敏感字符\nreturn item.replace(/(\"password\\\\?\":\\\\?\")([^\\\\?\"]+)(\\\\?\")/g, (target, $1, $2, $3) => `${$1}${new Array($2.length).join('*')}${$3}`);\n}\nreturn item;\n});\n\nsetLogFilter(logFilter);\n\nlogger.info('password: 123456');","argumentshandle#argumentsHandle":"日志打印之前对日志参数进行处理函数。\n通过链式调用配置处理器\n\n\nimport { logger } from '@yunflyjs/yunfly';\n\nconst handle = (...args: any[]): any[] => {\nreturn args.map((item)=>{\nreturn item + '加了一点东西!'\n})\n}\n\nlogger.argumentsHandle(handle).info('自定义日志处理逻辑！');\n\n通过 setArgsHandle 配置处理器\n\n\nimport logger, { setArgsHandle } from '@yunke/loggers';\n\nconst handle = (...args: any[]): any[] => {\nreturn args.map((item)=>{\nreturn item + '加了一点东西!'\n})\n}\n\nsetArgsHandle(handle)\n\nlogger.info('自定义日志处理逻辑！');","其他知识#其他知识":"","processenvyunfly_debug#process.env.YUNFLY_DEBUG":"当使用 debug 进行日志打印时， 可以通过环境变量来控制打印的输出\n开发环境有效\n使用场景： 开发模式下，控制台输出的日志太多，可以手动控制输出日志信息。\nprocess.env.YUNFLY_DEBUG = 'logger1';\n\n// output: 【logger1】: logger1\n\nprocess.env.YUNFLY_DEBUG = 'logger1,logger3';\n/*\n* output:\n* 【logger1】: logger1\n* 【logger3】: logger3\n*/","processenvyunfly_debug_type#process.env.YUNFLY_DEBUG_TYPE":"当使用根据环境变量来控制日志输出时，我们可以决定是包含的还是输出，排查设置的才输出。当前环境变量取值为：include 或 exclude\nprocess.env.YUNFLY_DEBUG = 'logger1';\nprocess.env.YUNFLY_DEBUG_TYPE = 'include';\n// output: 【logger1】: logger1\n\nprocess.env.YUNFLY_DEBUG = 'logger1';\nprocess.env.YUNFLY_DEBUG_TYPE = 'exclude';\n/*\n* output:\n* 【logger2】: logger2\n* 【logger3】: logger3\n*/","通过配置控制日志输出内容#通过配置控制日志输出内容":"config.setEnv = {\n'YUNFLY_DEBUG': 'client-request',\n'YUNFLY_DEBUG_TYPE': 'exclude', // exclude | include\n};\n\n备注： 需要安装 @yunflyjs/yunfly-plugin-set-env 插件。","通过环境变量控制日志输出#通过环境变量控制日志输出":"// 在 beforeStart 生命周期中设置环境变量\nprocess.env.YUNFLY_DEBUG_TYPE = 'exclude';\nprocess.env.YUNFLY_DEBUG = 'client-request';\n\nYUNFLY_DEBUG 可选日志参数说明\n\n\n名称\t说明\tclient-request\tclient 端(例如：浏览器)向 BFF发起的 HTTP 请求链路日志\thttp-request\tBFF 发起的 HTTP 请求链路日志\tgrpc-request\tBFF 发起的RPC 请求链路日志\tgrpc-restart\tRPC 请求过程中的 init 和 restart 日志\tservice-crypto\tRPC 请求过程中的 init 和 restart 日志\n\nYUNFLY_DEBUG_TYPE 参数说明\n\nYUNFLY_DEBUG_TYPE 的值为 exclude 或者 include。 当值为 include 时，表示只输出 YUNFLY_DEBUG 定义的日志。"}},"/document/basic-function/middleware-config":{"title":"中间件配置","data":{"":"提示：推荐使用插件模型。\n中间件配置核心是为了直接运行 koa 中间件而存在的产物。src/config 下新增 config.middleware.ts 文件。","中间件案例#中间件案例":"定义一个全局中间件，设置 ctx.name = 'zane'，这样每个请求都会带上 name 参数\nimport { KoaApp, Config } from '@yunflyjs/yunfly'\nexport default function KoaMiddleware(app: KoaApp, config: Config) {\n// 挂载中间件\napp.use(async (ctx: any, next: any) => {\nctx.name = 'zane'\nawait next()\n})\n}"}},"/document/basic-function/middleware":{"title":"中间件(Middleware)","data":{"":"BFF中间件就是 koa 中间件，koa 中间件是洋葱圈模型。每次我们编写一个中间件，就相当于在洋葱外面包了一层。","从目录加载中间件#从目录加载中间件":"在 config.routingControllersOptions.middlewares 中指定文件夹，即可加载该目录下所有全局中间件：\nconfig.routingControllersOptions = {\nmiddlewares: [path.join(__dirname, '../middleware/*')],\n};","开发中间件#开发中间件":"开发一个普通中间件\n\n\nimport { KoaMiddlewareInterface, Context } from \"@yunflyjs/yunfly\";\n\nexport class MyMiddleware implements KoaMiddlewareInterface {\nasync use(context: Context, next: (err?: any) => Promise<any>): Promise<any> {\nconsole.log(\"do something before execution...\");\nawait next()\nconsole.log(\"do something after execution...\");\n}\n}","使用中间件#使用中间件":"","controler-级别中间件#Controler 级别中间件":"你可以对一个 Controler 使用自定义的中间件\n\n\n使用 @UseBefore 和 @UseAfter 来决定中间件的执行时机\n\nimport { Controller, UseBefore, UseAfter } from \"@yunflyjs/yunfly\";\nimport { MyMiddleware } from \"./MyMiddleware\";\n//...\n@Controller()\n@UseBefore(MyMiddleware)\nexport class UserController {\n// ...\n}","method-级别中间件#Method 级别中间件":"可以只针对于某个 Method 使用中间件\n\n\n使用 @UseBefore 和 @UseAfter 来决定中间件的执行时机","method-中间件#method 中间件":"如果您只需中间件作用于具体的方法，则是在方法前进行注入。如下面注入的 @UseBefore 和 @UseAfter，只作用于 getOne 方法。\nimport { Get, UseBefore, UseAfter } from \"@yunflyjs/yunfly\";\nimport { MyMiddleware } from \"./MyMiddleware\";\n\n@Get(\"/users/:id\")\n@UseBefore(MyMiddleware)\ngetOne(@Param(\"id\") id: number) {\n// ...\n}","全局中间件#全局中间件":"Controller 和 Method 级别中间件都是手动配置，自定义使用位置。\n\n全局中间件的含义跟 koa 中间件一致，即不需要手动申明，配置一次全局生效。\n\n升级为全局中间件只需要在普通中间件基础之上添加 @Middleware 中间件即可实现。\nimport { KoaMiddlewareInterface, Context, Middleware } from \"@yunflyjs/yunfly\";\n\n@Middleware({ type: 'before' })\nexport class MyMiddleware implements KoaMiddlewareInterface {\nasync use(context: Context, next: (err?: any) => Promise<any>): Promise<any> {\nconsole.log(\"do something before execution...\");\nawait next()\nconsole.log(\"do something after execution...\");\n}\n}\n\nMiddleware 参数说明\n\n\n字段\t类型\t说明\ttype\t\"after\" | \"before\"\t执行时机 等效于 @UseBefore, @UseAfter\tpriority\tboolean\t优先级，值越小，优先级越高","使用#使用":"config.default.ts 文件增加 routingControllersOptions 配置进行全局中间件的加载。这样每个请求都会经过这些全局中间件。\n{\nconfig.routingControllersOptions = {\nmiddlewares: [path.join(__dirname, '../middleware/*')],\n}\n}\n详细中间件使用方式请 参考文档","插件中间件#插件中间件":"你还可以从插件中加载中间件，例如 @yunflyjs/yunfly-plugin-logger 中间件。\n安装依赖\n\n\nyarn add @yunflyjs/yunfly-plugin-logger\n\n使用插件中间件\n\n\n/**\n* yunfly 插件\n* 数组顺序就是插件的加载顺序\n*/\nimport { PluginConfig } from '@yunflyjs/yunfly';\n\nconst plugins: PluginConfig[] = [\n{\nname: 'log',\npackage: '@yunflyjs/yunfly-plugin-logger',\n},\n];\n\nexport default plugins;\n\n配置插件参数\n\n\nconfig.log = {\nenable: true,\n......\n}\n\n插件中间件代码案例","中间件执行顺序#中间件执行顺序":"","执行顺序#执行顺序":"插件中间件 > 项目业务中间件","中间件权重#中间件权重":"priority 参数可以调整中间件执行顺序，数字越大，执行顺序越靠前。\nimport { KoaMiddlewareInterface, Context, Middleware } from '@yunflyjs/yunfly';\n\n@Middleware({ type: 'before', priority: 10 })\nexport class MyMiddleware implements KoaMiddlewareInterface {\nasync use(context: Context, next: (err?: any) => Promise<any>): Promise<any> {\nconsole.log('当前中间件权重为10');\nreturn await next();\n}\n}"}},"/document/basic-function/plugin-config":{"title":"插件配置","data":{"":"config 用于配置插件启动时所需要的配置项, plugin 用来做插件的定义, 它决定项目可以使用那些插件。\nsrc/config 文件目录下新增 config.plugin.ts 文件用来管理项目的插件。","完整的插件案例#完整的插件案例":"/**\n* yunfly 插件\n* 数组顺序就是插件的加载顺序\n*/\nimport * as path from 'path'\n//\nconst plugins: {[key:string]: string}[] = [\n/**\n* hello 插件\n* 使用path模式\n*/\n{\nname: 'hello',\npath: path.join(__dirname, '../plugin/yunfly-plugin-hello'),\n},\n/**\n* redis 插件\n* 使用npm包模式\n*/\n{\nname: 'redis',\npackage: '@yunflyjs/yunfly-plugin-redis'\n}\n];\n//\nexport default plugins;","插件类型#插件类型":"export interface PluginConfig {\nname: string;\npath?: string;\npackage?: string;\nasync?: boolean;\nlifeHook?: 'beforeStart' | 'appDidReady' | 'afterStart';\npriority?: number;\n}","参数说明#参数说明":"字段\t类型\t必选\t说明\tname\tstring\t是\t当前插件配置的唯一标识 name, 跟 config.default.ts 中字段保持一致, name 字段很有用，它用来标识是否有重复插件和插件覆盖的能力\tpackage\tstring\t否\tnpm包插件名，例如: @yunflyjs/yunfly-plugin-redis。 (备注：package 与 path 必须有一个字段为真)\tpath\tstring\t否\t本地开发 插件目录地址 (备注：package 与path 必须有一个字段为真)\tasync\tboolean\t否\t若为 false，表示同步加载插件，加载完才会加载下一个插件；否则为异步加载，不阻塞其他插件加载（默认值为： true）。\tlifeHook\tstring\t否\t可选值：beforeStart、configDidReady、appDidReady、afterStart，表示在哪个生命周期进行加载。默认在 appDidReady 周期下加载插件。想进一步了解生命周期可看\tpriority\tnumber\t否\t插件自定义执行顺序, 数字越小约先执行，默认值：50"}},"/document/basic-function/service":{"title":"服务(service)","data":{"":"Service 主要用于逻辑处理, RPC, HTTP接口聚合等能力。\n\n常规案例介绍","简单逻辑处理#简单逻辑处理":"逻辑\n\n\nimport { Service } from '@yunflyjs/yunfly';\n\n@Service()\nexport default class ExampleService {\n\n/**\n* 简单逻辑计算\n*\n* @memberof ExampleService\n*/\nsum (request: {a: number, b: number}): number {\nreturn a + b;\n}\n\n}\n\n使用\n\n\nimport { JsonController, Inject, Get, QueryParam } from \"@yunflyjs/yunfly\";\nimport { ExampleService } from \"../service/ExampleService\";\n\n@JsonController('/example')\nexport class ExampleController {\n@Inject() private exampleService: ExampleService;\n\n@Get('/sum')\nsum (\n@QueryParam('a') a: number,\n@QueryParam('b') b: number,\n) {\nreturn this.exampleService.sum({ a, b });\n}\n}","请求-http-接口#请求 HTTP 接口":"逻辑\n\n\nimport { Service } from '@yunflyjs/yunfly';\n\n@Service()\nexport default class ExampleService {\n\n/**\n* 发起 HTTP 请求\n*\n* @memberof ExampleService\n*/\nasync getDataFromAxios(): Promise<string> {\ntry {\nconst url = 'https://xxx.com/api/get-some-thing'\nconst res = await axios.get(url);\nreturn res.data;\n} catch (err) {\nthrow err;\n}\n}\n}\n\n使用\n\n\nimport { JsonController, Inject, Get, QueryParam } from \"@yunflyjs/yunfly\";\nimport { ExampleService } from \"../service/ExampleService\";\n\n@JsonController('/example')\nexport class ExampleController {\n@Inject() private exampleService: ExampleService;\n\n@Get('/get-data-from-axios')\nasync getDataFromAxios () {\nreturn await this.exampleService.getDataFromAxios();\n}\n}","请求-rpc-接口#请求 RPC 接口":"逻辑\n\n\nimport { Service } from '@yunflyjs/yunfly';\nimport { MetaData } from '../../types/common.type';\nimport { exampleServiceV2 } from '../../grpc-code-gen/yued/grpc-server-example/example/ExampleService';\n\n@Service()\nexport default class ExampleService {\n\nasync doSomething(request: {name: string;age:number}): Promise<any> {\nconst { error, response }: any = await exampleServiceV2.DoSomething({\nrequest\n});\n\nif (error) {\nthrow error;\n}\n\nreturn response;\n}\n}\n\n使用\n\n\nimport { JsonController, Inject, Get, QueryParams } from \"@yunflyjs/yunfly\";\nimport { ExampleService } from \"../service/ExampleService\";\n\n@JsonController('/example')\nexport class ExampleController {\n@Inject() private exampleService: ExampleService;\n\n@Get('/get-data-from-axios')\nasync DoSomething (\n@QueryParams() params: {name: string;age:number}\n) {\nreturn await this.exampleService.DoSomething({ request: params });\n}\n}"}},"/document/introduction/characteristic":{"title":"特性","data":{"":"基于 Koa 开发, 底层框架性能优异。\n基于 Typescript 进行项目开发，更安全，更高效。\n基于 routing-controllers 进行路由的定义，完善的注解API，开发效率更高\n提供基于 Yunfly 强大的插件能力\n高度扩展的框架开发机制\n内置多进程能力\n渐进式开发"}},"/document/introduction/framework-differences":{"title":"与社区框架差异","data":{"":"能力\tyunfly\teggjs\tnestjs\tTypescript\t✅\t❌[支持但不友好]\t✅\tcluster\t✅\t✅\t❌\topenapi\t✅\t❌\t✅\t框架约束\t部分约束\t约束\t自由\t扩展模型\t插件\t插件\t模块"}},"/document/introduction/introduce":{"title":"介绍","data":{"":"Yunfly 一款高性能 Node.js WEB 框架, 使用 Typescript 构建我们的应用。\n使用 Koa2 做为 HTTP 底层框架, 使用 routing-controllers 、 typedi 来高效构建我们的 Node 应用。Yunfly 在 Koa 框架之上提升了一个抽象级别, 但仍然支持 Koa 中间件。在此基础之上, 提供了一套强大的插件系统, 给开发者提供更强大更灵活的能力。","框架技术栈#框架技术栈":"Koa2 node.js http 框架, async await异步编程 参考文档\nfind-my-way 一款高性能的 http 路由器 参考文档\ntypescript 微软开发的自由和开源的编程语言, 它是JavaScript的一个超集, 添加了可选的静态类型和基于类的面向对象编程 参考文档\nrouting-controllers  使用装饰器的方式来进行路由的开发 参考文档\ntypedi: 依赖注入插件工具  参考文档\ngrpc: 一个高性能、开源和通用的 RPC 框架  参考文档\nlog4js: javascript 的 log 日志插件 参考文档"}},"/document/introduction/performance":{"title":"性能","data":{"":"以下性能测试为同一台机器同样的容器场景下压测3分钟得出的结果。","容器环境#容器环境":"1G1核 Docker 容器","hello-world-场景#hello world 场景":"web框架\tqps\t备注\tyunfly\t6400\t使用 koa 为底层库\teggjs\t3950\t使用 koa 为底层库\tnestjs\t2900\t使用 express 为底层库\tnestjs\t7200\t使用 fastify 为底层库","1000-个路由场景#1000 个路由场景":"web框架\tqps\t备注\tyunfly\t6100\t使用 koa 为底层库\teggjs\t1680\t使用 koa 为底层库\tnestjs\t2050\t使用 express为底层库\tnestjs\t6550\t使用 fastify为底层库"}},"/document/simple-use/env":{"title":"环境准备","data":{"":"","nodejs-版本#Node.js 版本":"Node.js >= 12.17.0, 推荐使用 node@14+","环境变量#环境变量":"NODE_ENV\tRUNTIME_ENV\t说明\tdev\tlocal\t本地开发环境\tproduction\ttest\t测试环境\tproduction\trelease\t预发布环境\tproduction\tprod\t生产环境\n备注：\n\nNODE_ENV 只区分开发生产环境，主要用来区分本地环境与部署环境\nRUNTIME_ENV 运行时环境, 主要用于不同环境的逻辑区分\n\n\n\n可以在 scripts run 命令中设置 RUNTIME_ENV 环境变量来满足自己的业务需求。\n\n例如：\n\n\nrun 命令\n\n\n{\n\"scripts\":{\n\"run\": \"cross-env PORT=3000 NODE_ENV=production RUNTIME_ENV=test yunfly\",\n}\n}"}},"/document/simple-use/gradually-build":{"title":"逐步搭建","data":{"":"一步一步逐步搭建","设置淘宝镜像源#设置淘宝镜像源":"// npm\nnpm config set registry https://registry.npmmirror.com\n\n// yarn\nyarn config set registry https://registry.npmmirror.com","初始化项目#初始化项目":"","初始化下目录结构#初始化下目录结构":"// 创建目录\nmkdir yunfly-example\ncd yunfly-example\n\n// 初始化 package.json\nyarn init\n\n// 安装依赖\nyarn add @yunflyjs/yunfly\nyarn add cross-env typescript tsconfig-paths gts --dev","配置脚本命令#配置脚本命令":"package.json 中添加 npm scripts 脚本\n\n\n{\n\"scripts\": {\n\"dev\": \"cross-env NODE_ENV=dev PORT=3000 yunfly\",\n\"watch:dev\": \"cross-env NODE_ENV=dev PORT=3000 yunfly --watch\",\n\"run\": \"cross-env PORT=3000 NODE_ENV=production RUNTIME_ENV=prod yunfly\",\n\"build\": \"yarn clean && yarn compile\",\n\"clean\": \"gts clean\",\n\"compile\": \"tsc -p .\"\n}\n}","配置-tsconfigjson#配置 tsconfig.json":"{\n\"extends\": \"./node_modules/gts/tsconfig-google.json\",\n\"compilerOptions\": {\n\"rootDir\": \"src\",\n\"outDir\": \"./build/\",\n\"experimentalDecorators\": true,\n\"emitDecoratorMetadata\": true,\n\"noEmitOnError\": false,\n\"noUnusedLocals\": true,\n\"noUnusedParameters\": false,\n\"moduleResolution\": \"node\",\n\"strictPropertyInitialization\": false,\n\"module\": \"commonjs\",\n\"target\": \"esnext\",\n\"sourceMap\": false\n},\n\"include\": [\n\"src/**/*.ts\"\n],\n\"exclude\": [\n\"node_modules\"\n]\n}","编写-controller#编写 Controller":"import { Get, JsonController, BodyParam, Post, QueryParam } from 'yunfly';\n/**\n* 测试案例controller\n*\n* @export\n* @class TestController\n*/\n@JsonController('/example')\nexport default class ExampleController {\n/**\n* 简单案例 - get\n*\n* @param {string} name 姓名\n* @return {*}  {string}\n* @memberof ExampleController\n*/\n@Get('/simple/get')\nsimple(\n@QueryParam('name') name: string,\n): string {\nreturn name || 'success';\n}\n/**\n* 简单案例 -post\n*\n* @param {string} name 姓名\n* @return {*}  {string}\n* @memberof ExampleController\n*/\n@Post('/simple/post')\nsimple1(\n@BodyParam('name') name: string,\n): string {\nreturn name || 'success';\n}\n}","配置-config#配置 Config":"/**\n* This is an env aggregation default config.\n* (note) this is a minimum config.\n*/\nimport * as path from 'path';\nimport { Config } from 'yunfly';\n\nconst config = () => {\nconst config: Config = {};\n\n/*\n* routing-controllers configs\n* 1. controllers、middlewares、authorizationChecker 需要使用`path.join`进行文件位置的绝对定位\n* 2. 如果 middlewares 、authorizationChecker中有rpc请求，则需要使用函数包裹。\n*/\nconfig.routingControllersOptions = {\ndefaultErrorHandler: false,\ncontrollers: [path.join(__dirname, '../controller/*')],\nmiddlewares: [path.join(__dirname, '../middleware/*')],\n// middlewares: [\n//   require(path.join(__dirname,'../middleware/xxxMiddleware')).default,\n// ]\ndefaults: {\nnullResultCode: 200,  // 204 | 404\nundefinedResultCode: 200 // 204 | 404\n}\n};\n\nreturn config;\n};\n\nexport default config;\n\n此时目录结构如下：\n\n\nyunfly-example\n├── src\n│   ├── config\n│   │   └── config.default.ts\n│   └── controller\n│       └── ExampleController.ts\n├── package.json\n├── tsconfig.json\n└── yarn.locak","运行项目#运行项目":"yarn dev\nyarn watch:dev\n\n访问应用\n\n\nhttp://127.0.0.1:3000/example/simple/get?name=xxx","生产编译#生产编译":"// 编译\nyarn build\n\n// 运行\nyarn run run"}},"/document/simple-use/quickly-start":{"title":"快速开始","data":{"":"通过框架脚手架快速初始化项目","设置淘宝镜像源#设置淘宝镜像源":"// npm\nnpm config set registry https://registry.npmmirror.com\n\n// yarn\nyarn config set registry https://registry.npmmirror.com","通过脚手架快速初始化#通过脚手架快速初始化":"安装依赖\n\n\nyarn global add @yunflyjs/yunfly-gen\n\n初始化模板\n\n\nnpx yunfly-gen\n\n安装依赖/启动项目\n\n\nyarn install\n\n// 启动项目\nyarn dev\nyarn watch:dev\n\n访问应用\n\n\nhttp://127.0.0.1:3000/example/simple/get?name=xxx\n\n生产编译\n\n\n// 编译\nyarn build\n\n// 运行\nyarn run run"}},"/faq":{"title":"构建报错","data":{"":"","core-jsxxxjs-模块找不到#core-js/xxx/.js 模块找不到":"原因是: 1、core-js没有安装；2、core-js版本低了解决方法: 如果是core-js未安装，则安装即可；如果是core-js版本低了，则升级到最新版本"}},"/":{"title":"Yunfly","data":{"":"https://yunke-yunfly.github.io/doc.github.io"}}}