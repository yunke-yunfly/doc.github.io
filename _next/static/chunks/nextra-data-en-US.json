{"/config/app":{"title":"应用配置详情","data":{"":"","entry#entry":"object | string | string[]可用于修改、拓展 Webpack 的 enrty 选项，配置项参考 官方文档。\nmodule.exports = {\n// ...\nentry: {\nhome: './home.js',\nabout: ['./about.js'],\ncontact: ['./contact.js']\n}\n}"}},"/config/lib":{"title":"库配置详情","data":{"":"","entry#entry":"string | string[]可用于修改、拓展 Rollup 的 input 选项。\nexport default {\n// ...\nentry: 'src/index.ts'\n}"}},"/document/api/apis":{"title":"Api","data":{"":"","辅助方法#辅助方法":"","isproduction#isProduction":"判断是否是生产环境, 通过 NODE_ENV 来判断, NODE_ENV 只有 dev 和 production 两个值\nimport { isProduction } from '@yunflyjs/yunfly'\n\nconst isprod = isProduction();","deepmerge#deepMerge":"深度合并两个对象，可以合并 object 与 array\nimport { deepMerge } from '@yunflyjs/yunfly'\n\nconst x = {\nfoo: { bar: 3 },\narray: [{\ndoes: 'work',\ntoo: [ 1, 2, 3 ]\n}]\n}\n\nconst y = {\nfoo: { baz: 4 },\nquux: 5,\narray: [{\ndoes: 'work',\ntoo: [ 4, 5, 6 ]\n}, {\nreally: 'yes'\n}]\n}\n\nconst output = {\nfoo: {\nbar: 3,\nbaz: 4\n},\narray: [{\ndoes: 'work',\ntoo: [ 1, 2, 3 ]\n}, {\ndoes: 'work',\ntoo: [ 4, 5, 6 ]\n}, {\nreally: 'yes'\n}],\nquux: 5\n}\n\ndeepMerge(x, y) // => output","getpackagejson#getPackageJson":"获得项目 package.json 信息\nimport { getPackageJson } from '@yunflyjs/yunfly'\n\nconst projectName = getPackageJson().name;","getcpuslength#getCpusLength":"获得容器下的 cpu 个数，测试环境下默认 4 个\nimport { getCpusLength } from '@yunflyjs/yunfly'\n\ncosnt cpuLength = getCpusLength();","randomstring#randomString":"获得一个随机数\nimport { randomString } from '@yunflyjs/yunfly'\n\n// 获得一个12位数的随机字符串\nconst randomStr = randomString(12);","firstwordtouppercase#firstWordToUpperCase":"第一个单词大写\nimport { firstWordToUpperCase } from '@yunflyjs/yunfly'\n\nfirstWordToUpperCase('abCd') // => Abcd","getdirpaths#getDirPaths":"获得某个目录下的文件列表，排除 .d. 文件\nimport { getDirPaths } from '@yunflyjs/yunfly'\nimport * as path from 'path'\n\ngetDirPaths(path.join(__dirname, './controllers'))","routing-controllers-apis#routing-controllers apis":"yunfly 默认导出了所有 routing-controllers 的 api, 因此所有 routing-controllers 的 api 都可以从 yunfly 中导入\nimport { Get, JsonController, QueryParam } from '@yunflyjs/yunfly';\n\n@JsonController('/example')\nexport default class ExampleController {\n@Get('/test')\nasync test(\n@QueryParam(\"name\") name: string,\n@QueryParam(\"orgcode\") orgcode: string\n): Promise<types.example.Response | undefined> {\nreturn {\nname,\norgcode\n};\n}\n}\n\n更多 routing-controllers api 请参考：https://www.npmjs.com/package/routing-controllers","typedi-apis#typedi apis":"yunfly 默认导出了所有 typedi 的 api, 因此所有 typedi 的 api 都可以从 yunfly 中导入\nimport { Get, JsonController, QueryParam, Inject } from '@yunflyjs/yunfly';\nimport Example from \"../service/Example\";\n\n@JsonController('/example')\nexport default class ExampleController {\n@Inject() private example: Example;\n\n@Get('/test')\nasync test(\n@QueryParam(\"name\") name: string,\n@QueryParam(\"orgcode\") orgcode: string\n): Promise<types.example.Response | undefined> {\nreturn await this.example.doSomething(name, orgcode);\n}\n}\n\n更多 typedi api 请参考： https://docs.typestack.community/typedi/","errors-api#errors api":"","badrequesterror#BadRequestError":"参数错误, HTTP 状态码:400\nimport { BadRequestError } from '@yunflyjs/yunfly';\n\nthrow BadRequestError()","unauthorizederror#UnauthorizedError":"用户未登录, HTTP 状态码: 401","forbiddenerror#ForbiddenError":"用户无权限, HTTP 状态码: 403","notfounderror#NotFoundError":"用户无权限, HTTP 状态码: 404","methodnotallowederror#MethodNotAllowedError":"方法不允许, HTTP 状态码: 405","toomanyrequestserror#TooManyRequestsError":"过多请求, HTTP 状态码: 429","internalservererror#InternalServerError":"代码不严谨导致的服务器错误, HTTP 状态码: 500","badgatewayerror#BadGatewayError":"网关错误, HTTP 状态码: 502","serviceunavailableerror#ServiceUnavailableError":"服务不可用, HTTP 状态码: 503","gatewaytimeouterror#GatewayTimeoutError":"网关超时, HTTP 状态码: 504","rpcerror#RpcError":"RPC 错误, HTTP 状态码: 500 , code 码：code 由 go 返回的决定，默认值是 -1","yunflyerror#YunflyError":"yunfly 框架自身异常, HTTP 状态码: 500 , code 码：10000 ~ 1099","apolloerror#ApolloError":"Apollo 错误 , HTTP 状态码: 500 , code 码：10100 ~ 10199","rediserror#RedisError":"Redis 错误 , HTTP 状态码: 500 , code 码：10200 ~ 10299","ectderror#EctdError":"ECTD 错误 , HTTP 状态码: 500 , code 码：10300 ~ 10399","mysqlerror#MysqlError":"Mysql 错误 , HTTP 状态码: 500 , code 码：10400 ~ 10499","mongodberror#MongoDBError":"MongoDB 错误 , HTTP 状态码: 500 , code 码：10500 ~ 10599"}},"/document/api/types":{"title":"Types","data":{"":"","pluginconfig#PluginConfig":"插件参数类型\nexport interface PluginConfig {\nname: string;\npath?: string;\npackage?: string;\nasync?: boolean;\nlifeHook?: 'beforeStart' | 'appDidReady' | 'afterStart';\npriority?: number;\n}\n\n字段\t必选\t说明\tname\t是\t当前插件配置的唯一标识name, 跟config.default.ts中字段保持一致, name 字段很有用，它用来标识是否有重复插件和插件覆盖的能力\tpackage\t否\tnpm包插件名，例如: @yunflyjs/yunfly-plugin-redis。 (备注：package与path必须有一个字段为真)\tpath\t否\t本地开发插件目录地址 (备注：package与path必须有一个字段为真)\tasync\t否\t是否时同步插件\tlifeHook\t否\t插件执行的生命周期\tpriority\t否\t插件的权重\n\nimport { PluginConfig } from '@yunflyjs/yunfly';\n\nconst plugins: PluginConfig[] = [\n{\nname: 'routingControllersExample',\npackage: '@yunflyjs/yunfly-plugin-controller-example'\n}\n];\nexport default plugins;","koaapp#KoaApp":"koa 实例化对象类型\nimport { KoaApp, Config } from '@yunflyjs/yunfly';\n\nexport default function KoaMiddleware(app: KoaApp, config: Config) {\n//\n}","config#Config":"yunfly config 配置类型\nimport { Config } from '@yunflyjs/yunfly';\n\nconst config = () => {\nconst config: Config = {};\n// jwt配置\nconfig.jwt = {\ntoken: {\ndomain: '127.0.0.1',\n},\n};\nreturn config;\n};\nexport default config;","context#Context":"yunfly 在 koa context 类型上进行扩展的类型\nimport { KoaApp, Config } from '@yunflyjs/yunfly';\n\napp.use(async function (ctx: Context, next: any) {\n// 所有的config配置注入到ctx中\nawait next();\n});\n// Context.config\n// Context.traceId"}},"/document/basic-function/body-parser":{"title":"获取 Post 请求参数","data":{"":"","简介#简介":"获取 post 请求参数","使用#使用":"安装依赖\n\n\nyarn add @yunflyjs/yunfly-plugin-body-parser\n\nconfig.plugin.ts 中声明插件\n\n\nconst plugins: { [key: string]: string }[] = [\n{\nname: 'bodyParser',\npackage: '@yunflyjs/yunfly-plugin-body-parser',\npriority: 5\n},\n];\nexport default plugins;\n\nconfig.default.ts 配置项 （可选）\n\n\n// body参数配置\nconfig.bodyParser = {\njsonLimit: '1mb',\nformLimit: '1mb',\nqueryString: {\nparameterLimit: 1 * 1024 * 1024,\n},\n};","使用案例#使用案例":"获取 post 请求参数\n\n\nimport { JsonController, BodyParam, Post, Ctx, Context } from '@yunflyjs/yunfly';\n\n@JsonController('/example')\nexport default class ExampleController {\n@Post('/simple/post')\nsimple1(\n@Ctx() ctx: Context,\n@BodyParam('name') name: string,\n): string {\nconst request = ctx.request?.body;\nreturn request;\n}\n}\n\n获取 get 请求参数\n\n\nimport { JsonController, QueryParam, Get, Ctx, Context } from '@yunflyjs/yunfly';\n\n@JsonController('/example')\nexport default class ExampleController {\n@Get('/simple/get')\nsimple1(\n@Ctx() ctx: Context,\n@QueryParam('name') name: string,\n): string {\nconst request = ctx.request?.request;\nreturn request;\n}\n}","参数说明#参数说明":"字段\t类型\t必填\t默认值\t说明\tqueryString\t\t否\t\tquery 参数限制大小\tjsonLimit\tstring\t否\t1mb\t传输json数据限制大小\ttextLimit\tstring\t否\t1mb\t传输text格式限制大小\txmlLimit\tstring\t否\t1mb\t传输xml格式限制大小\tformLimit\tstring\t否\t1mb\t表单数据限制大小\tenableTypes\tjson/form/text/xml[]\t否\t['json', 'form']\t表单数据限制大小\tencoding\tstring\t否\tutf-8\t数据格式编码","参考文档#参考文档":"https://www.npmjs.com/package/koa-bodyparser#options"}},"/document/basic-function/catch-error":{"title":"异常处理","data":{"":"框架默认不提供异常处理器，你可以定制自己的异常处理器。","自定义错误处理器#自定义错误处理器":"创建 ErrorMiddleware.ts 文件，定制自己的错误处理逻辑。\nimport { KoaMiddlewareInterface, Middleware, Context, logger } from '@yunflyjs/yunfly';\n\n@Middleware({ type: 'before', priority: 20 })\nexport default class YunflyPluginErrorMIddleware implements KoaMiddlewareInterface {\nasync use(ctx: Context, next: (err?: any) => Promise<any>): Promise<any> {\ntry {\nawait next();\n} catch (err: any) {\n// 定制自己的错误处理器\nlogger.error({ msg: 'Request error', url: ctx.req.url, error: err });\n// 返回错误信息\nconst body: Record<string, any> = {\ncode: err.code || 400,\nmsg: err.message || '服务器异常',\n};\nctx.body = body;\n}\n}\n}","使用框架提供的统一错误处理器#使用框架提供的统一错误处理器":"框架异常处理统一由 @yunflyjs/yunfly-plugin-error 插件进行处理。内置通用处理逻辑。","使用#使用":"安装依赖\n\n\nyarn add @yunflyjs/yunfly-plugin-error\n\nconfig/config.plugin.ts 中声明插件\n\n\n/**\n* yunfly 插件\n* 数组顺序就是插件的加载顺序\n*/\nconst plugins: {[key:string]: string}[] = [\n{\nname: 'error',\npackage: '@yunflyjs/yunfly-plugin-error'\n}\n];\n//\nexport default plugins;\n\nconfig/config.default.ts 中启用插件 config.error\n\n\nimport {Context,customErrorHandle} from '@yunflyjs/yunfly';\n\n/**\n* error handle\n*/\nconfig.error = {\nenable: true,\n\n// use yunfly default error log.\nuseYunflyLog: true,\n\n/**\n* 错误码\n* Type: number | true | Record<Key, Key>\n*/\nerrCode: true,\n\n// 是否开启 HTTP 状态码\nenableHttpCode: false,\n\n// 是否返回 rpc 错误信息\nuseRpcErrorMessage: true,\n\n// 是否返回错误详情\nshowMessageDetail: true,\n\n/* Customize your error fn. （Optional） */\n// customError: async (err: any, ctx: Context) => {}\n\nunhandledRejection: (err: any) => {\nconsole.error('UnhandledRejection error, at time', Date.now(), 'reason:', err);\n},\nuncaughtException: (err: any) => {\nconsole.error('uncaughtException error, at time', Date.now(), 'reason:', err);\n},\n\n// 用于重新组装error信息，处理class-validator错误，并且不影响其他错误\ncustomErrorHandle,\n};\n\n字段\t类型\t默认值\t必填\t说明\tenable\tboolean\ttrue\t是\t是否开启错误处理\terrCode\tnumber/true/Record<Key, Key>\t2\t否\t错误码\tuseYunflyLog\tboolean\ttrue\t否\t是否开启日志记录\tenableHttpCode\tboolean\tfalse\t否\t是否开启 HTTP 状态码\tuseRpcErrorMessage\tboolean\ttrue\t否\t是否返回 rpc 错误信息\tshowMessageDetail\tboolean\tfalse\t否\t是否返回错误详情\tcustomError\t(err: any, ctx: Koa.Context) => any\t\t否\t自定义错误，若定义，则不会执行yunfly-plugin-error中间件后续逻辑\tcustomErrorHandle\t(err: any, ctx: Koa.Context) => any\t\t否\t可用于重新组装错误，并不影响yunfly-plugin-error中间件后续逻辑的执行\tunhandledRejection\t(err: any, ctx: Koa.Context) => any\t\t否\t自定义 Promise 错误\tuncaughtException\t(err: any, ctx: Koa.Context) => any\t\t否\t自定义未能捕获的异常","参数说明#参数说明":"","errorcode#errorCode":"不同的错误类，有不同的错误码，但为了满足不同用户场景以及向后兼容，为此我们做了如下的处理：1、当 errorCode 为数字时：那么错误码一直就是这个数字\n// 配置\nconfig.error = {\nenable: true,\nuseYunflyLog: true,\nerrorCode: 2, // 则返回 code 一直为 2\n}\n\n// 无论什么错误，code 都为 2\nctx.body = {\ncode: 2,\nmsg: string,\n}\n2、当 errorCode 为带 * 对象时（改造中）： { \"*\": 2, 401: 401 } 代表 401 错误码，返回 401，其他返回 2\n// 配置\nconfig.error = {\nenable: true,\nuseYunflyLog: true,\nerrorCode: {\n401: 401, // 遇到 401 错误，code 码值为 401\n'*': 2, // 其他情况为 2\n},\n}\n\n// 抛错\nimport { UnauthorizedError } from '@yunflyjs/yunfly'\n\nthrow new UnauthorizedError('jwt token验证失败!')\n\n// 返回结果\nctx.body = {\ncode: 401,\nmsg: 'jwt token验证失败!',\n}\n3、当 errorCode 为不带 * 的对象时（改造完成后的特殊处理，常用于 rpc 错误码映射）：{ 2000210: 401} 代表如果遇到错误码为 2000210，则返回 401，其他情况下返回原错误码。\n// 配置\nconfig.error = {\nenable: true,\nuseYunflyLog: true,\nerrorCode: {\n2000210: 401, // 遇到 2000210 错误码时，返回 401\n},\n}\n\n// 抛错\nimport { RpcError } from '@yunflyjs/yunfly'\n\nconst { error, response } = await this.userService.getUserInfo({request})\n\nif (error) {\n// 假定这个 error 的状态码是 2000210，表示用户未登录，我们映射到前端就是 401\nthrow new RpcError(error)\n}\n4、当 errorCode 为 true 时，则代表所有的错误码为原错误码，不做任何映射，如果是 throw 的普通 Error，默认值依然是 2。\n// 配置\nconfig.error = {\nenable: true,\nuseYunflyLog: true,\nerrorCode: true, // 一直采用 Error 类的 code，如果是 Error 类中没有 code，则返回 2\n}\n\nimport { BadRequestError } from '@yunflyjs/yunfly'\n\nthrow new BadRequestError('用户名不为空')\n\n{\ncode: 400,\nmsg: \"用户名不为空\"\n}","customerror#customError":"我们可以通过实现 customError 方法，从而实现错误的自定义处理\nconfig.error = {\nenable: true,\nuseYunflyLog: true,\ncustomError: async (err: any, ctx: Context) => {\nconst message =\ntypeof err === 'string' ? err : err.details || err.message || ''\nctx.body = {\ncode: 2,\nmsg: message || '服务异常,请稍后重试！',\n}\n},\n}\n\ncustomError 暴露 err 和 ctx两个参数，可根据自己的需求进行自定义处理，最后通过 ctx.body = xxx 进行返回结果处理。","useyunflylog#useYunflyLog":"框架默认错误输出字段描述\n\n当 useYunflyLog 为 true 时会自动将错误信息记录到阿里云日志系统中，记录的内容如下：\n方法名\t说明\turl\t请求 URL\tmethod\t请求类型\trequest\t所有请求参数（兼容 get、post）\theaders\thttp 请求头信息\ttrace-id\t链路id\terror\terror 错误详细信息\n\n当参数 useYunflyLog为true时, 无论是否自定义错误函数， 框架都会打印错误日志。","customerrorhandle#customErrorHandle":"从新定义 error 错误信息，核心处理 class-validator 错误信息\nimport { customErrorHandle } from '@yunflyjs/yunfly'\n\nconfig.error = {\n// 用于重新组装error信息，处理class-validator错误，并且不影响其他错误\ncustomErrorHandle,\n}","enablehttpcode#enableHttpCode":"是否开启 HTTP Code\nfalse：不开启，默认值， HTTP code 一直是 200\ntrue：开启，如果 Error 类 httpCode 属性有值，则用 Error 类的 httpCode，没有值，则默认值是 500。","userpcerrormessage#useRpcErrorMessage":"是否使用 rpc 错误信息作为 msg 的值\ntrue：表示使用 rpc 错误信息作为响应结果的 msg 结果\n\n\n{\ncode: 200010, // go 返回的错误\nmsg: \"Error: 2 UNKNOWN: 支付订单不存在\"\n}\n\nfalse：表示使用统一的 “服务器错误，请重试” 作为 msg 结果\n\n\n{\ncode: 200010, // go 返回的错误\nmsg: \"服务器错误，请重试\"\n}","showmessagedetail#showMessageDetail":"是否返回详情信息\n\n针对服务器运行时错误、rpc 错误或者传递了 messageDetail 属性的错误，是否返回 mesageDetail 信息。\ntrue\n\n\n{\ncode: 500,\nmsg: \"服务器错误，请重试\",\nmsg_detail: \"Cannot read property 'doSomething' of undefined\" // 返回\n}\n\nfalse\n\n\n{\ncode: 500,\nmsg: \"服务器错误，请重试\"\n}","unhandledrejection#unhandledRejection":"自定义 Promise 错误\n\n\nconfig.error = {\nenable: true,\nuseYunflyLog: true,\nunhandledRejection: (err: any) => {\nconsole.error(\n'UnhandledRejection error, at time',\nDate.now(),\n'reason:',\nerr\n)\n}\n}","uncaughtexception#uncaughtException":"自定义未能捕获的错误\n\n\nconfig.error = {\nenable: true,\nuseYunflyLog: true,\nuncaughtException: (err: any) => {\nconsole.error(\n'uncaughtException error, at time',\nDate.now(),\n'reason:',\nerr\n)\n},\n}","抛错类型#抛错类型":"当程序出现错误时, 抛错有多种方式。","断言#断言":"import { strict as assert } from 'assert';\n\n@Get('/jest')\ntest(\n@BodyParam('name') name: string,\n): string {\nassert.equal(typeof(name) === 'string', true , \"name 参数必须为字符串类型!\");\nreturn name || 'success';\n}\n\n// 返回结果\nctx.body = {\ncode: 2,\nmsg: 'name 参数必须为字符串类型!',\n}","throw-抛错#throw 抛错":"import { strict as assert } from 'assert';\n\n@Get('/jest')\ntest(\n@BodyParam('name') name: string,\n): string {\nif (typeof(name) !== 'string') {\nthrow \"name 参数必须为字符串类型!\"\n}\nreturn name || 'success';\n}\n\n// 返回结果\nctx.body = {\ncode: 2,\nmsg: 'name 参数必须为字符串类型!',\n}","throw-error-错误类#throw Error 错误类":"import { strict as assert } from 'assert';\n\n@Get('/jest')\ntest(\n@BodyParam('name') name: string,\n): string {\nif (typeof(name) !== 'string') {\nthrow new Error (\"name 参数必须为字符串类型!\");\n}\nreturn name || 'success';\n}\n\n// 返回结果\nctx.body = {\ncode: 2,\nmsg: 'name 参数必须为字符串类型!',\n}","throw-yunkeerror-错误类-推荐#throw YunkeError 错误类 (推荐)":"import { strict as assert } from 'assert';\nimport { BadRequestError } from '@yunflyjs/yunfly'\n\n@Get('/jest')\ntest(\n@BodyParam('name') name: string,\n): string {\nif (typeof(name) !== 'string') {\nthrow new BadRequestError (\"name 参数必须为字符串类型!\");\n}\nreturn name || 'success';\n}\n\n// 返回结果\nctx.body = {\ncode: 400,\nmsg: 'name 参数必须为字符串类型!',\n}\n\n更多错误类请参考：错误类使用","service-错误处理#Service 错误处理":"","global-middleware#global middleware":"框架所有方法错误信息默认由全局 ErrorMiddleware 中间件进行错误处理，一旦有任何报错，都会返回error信息\nimport { Service } from \"typedi\";\n//\n@Service()\nexport default class UserService {\n// 用户鉴权\nasync auth(userId: number, ctx: any): Promise<any> {\nconst response = {}\n// 以下代码会报错，会使用全局的ErrorMiddleware进行错误处理\nresponse.data.name = 'xiaowang'\nreturn response\n}\n}","try-catch#try catch":"import { Service } from \"typedi\";\n//\n@Service()\nexport default class UserService {\n// 用户鉴权\nasync auth(userId: number, ctx: any): Promise<any> {\n// 使用 try catch 手动处理error信息\n// 使用场景： 聚合多个接口时，此接口的报错不影响整个请求的成功状态\ntry {\nconst response = {}\nresponse.data.name = 'xiaowang'\nreturn response\n} catch(err) {\nreturn err\n}\n}\n}","decorator-catch#Decorator Catch":"自定义 Catch 装饰器处理错误信息\n\n\nexport function Catch(option?: ExtSdkOption): Function {\nreturn function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\nconst _fn = descriptor.value;\ndescriptor.value = async function (...args: any[]): Promise<any> {\ntry {\nreturn await _fn.apply(this, args);\n} catch(err: any) {\n// 自定义错误处理逻辑\nconst error = new Error();\nerror.message = '自定义错误信息';\nerror.code = 2;\nthrow error;\n}\n}\nreturn descriptor;\n};\n}\n\nimport { Service } from \"typedi\";\nimport { Catch } from \"../utils/decorator\"\n//\n@Service()\nexport default class UserService {\n// 用户鉴权\n@Catch()\nasync auth(userId: number, ctx: any): Promise<any> {\n// 使用 Catch 装饰器处理error信息\n// 使用场景： 聚合多个接口时，此接口的报错不影响整个请求的成功状态\nconst response = {}\nreturn response\n}\n}","servicev2#ServiceV2":"使用自定义 ServiceV2 接收错误信息并手动处理\n\n\nimport { Service } from \"typedi\";\nimport { Catch } from \"../utils/decorator\"\n// services\nimport { usrUserServiceV2 } from \"../grpc-code-gen/2c/marvel-user/user/UsrUserService\";\n//\nexport interface RpcServiceResponse<T = any> {\n'error'?: any;\n'error_derails'?: string;\n'response': T;\n'metadata': any;\n}\n//\n@Service()\nexport default class UserService {\n// 用户鉴权\nasync auth(request: AnyOptions, ctx: any): Promise<any> {\n// 使用 ServiceV2 处理error信息\n// 使用场景： 聚合多个接口时，此方式可以自定义错误抛出方式\nconst { error, response }: RpcServiceResponse = await usrUserServiceV2.GetUserInfot({ request });\n\nif (error) {\nthrow error;\n}\n\nreturn response\n}\n}","如何输出错误日志#如何输出错误日志":"yunfly 框架代理了 console 方法，我们只需要打印错误信息，即可记录到日志系统中。\n\n\nconsole.error('记录错误日志!');\n\nconsole.error('开发环境请在 log/error.log 中查看错误信息!');"}},"/document/basic-function/config-configure":{"title":"Config 配置","data":{"":"config 主要用来管理插件的启停，插件的配置管理，项目常用变量的聚合等能力。它的核心特性就是区分环境。\n区分环境配置核心依赖 RUNTIME_ENV 环境变量。","区分环境#区分环境":"在src/config 文件目录下新增如下文件：\nconfig.default.ts : 默认配置项 （优先级最低）\nconfig.local.ts   : 本地环境生效\nconfig.test.ts    : 测试环境生效\nconfig.release.ts : 预发布环境生效\nconfig.prod.ts    : 生产环境生效\n\n\n一般建议最少有一个 config.default.ts 文件。","配置特性#配置特性":"优先级： 应用 config > 插件 config > 框架 config\n环境隔离： 通过不同的环境加载不同的配置项，做到环境的隔离（备注：default 配置项在任何环境都会生效）\n区分环境：环境配置项里面的配置会覆盖掉 default 里面的配置项\n所有的配置文件均为非必须项（建议：最少有一个 default 配置文件）","cluster-配置#Cluster 配置":"/**\n* cluster config\n*/\nconfig.cluster = {\nenable: false,\n};\n\n字段\t类型\t必填\t默认值\t说明\tenable\tboolean\t否\tfalse\t是否以 cluster 模型启动应用","进程数量说明#进程数量说明":"开发模式下启动一个 alone 进程一个 worker 进程\n生产环境容器模式下会自动获取容器核数, 启动一个 alone 进程容器核数个 worker 进程\n非容器环境启动 cpu 核数个进程","routingcontrollersoptions-配置#RoutingControllersOptions 配置":"/*\n* routing-controllers configs\n* 1. controllers、middlewares、authorizationChecker 需要使用`path.join`进行文件位置的绝对定位\n*/\nconfig.routingControllersOptions = {\ncurrentUserChecker,\ndefaultErrorHandler: false,\ncontrollers: [path.join(__dirname, '../controller/*')],\nmiddlewares: [path.join(__dirname, '../middleware/*')],\n// middlewares: [\n//   require(path.join(__dirname,'../middleware/xxxMiddleware')).default,\n// ]\ndefaults: {\nnullResultCode: 200,  // 204 | 404\nundefinedResultCode: 200 // 204 | 404\n}\n};\n\nRoutingControllersOptions 参数说明\n\n\n字段\t类型\t必填\t说明\tcurrentUserChecker\tfunction\t否\t向 ctx.state.payload 中注入数据\tcontrollers\tstring[]\t否\tcontrollers 文件列表\tmiddlewares\tstring[]\t否\tmiddlewares 文件列表\tdefaults\tObject\t否\t异常处理配置信息","error-配置#Error 配置":"Error 配置需要安装 @yunflyjs/yunfly-plugin-error 插件。插件使用文档\n\n/**\n* error handle\n*/\nconfig.error = {\nenable: true,\n\n// use yunfly default error log.\nuseYunflyLog: true,\n\n/**\n* 错误码\n* Type: number | true | Record<Key, Key>\n*/\nerrCode: true,\n\n// 是否开启 HTTP 状态码\nenableHttpCode: false,\n\n// 是否返回 rpc 错误信息\nuseRpcErrorMessage: true,\n\n// 是否返回错误详情\nshowMessageDetail: true,\n\n/* Customize your error fn. （Optional） */\n// customError: async (err: any, ctx: Context) => {}\n\nunhandledRejection: (err: any) => {\nconsole.error('UnhandledRejection error, at time', Date.now(), 'reason:', err);\n},\nuncaughtException: (err: any) => {\nconsole.error('uncaughtException error, at time', Date.now(), 'reason:', err);\n},\n};\n\n字段\t类型\t默认值\t必填\t说明\tenable\tboolean\ttrue\t是\t是否开启错误处理\terrCode\tnumber/true/Record<Key, Key>\t2\t否\t错误码\tuseYunflyLog\tboolean\ttrue\t否\t是否开启日志记录\tenableHttpCode\tboolean\tfalse\t否\t是否开启 HTTP 状态码\tuseRpcErrorMessage\tboolean\ttrue\t否\t是否返回 rpc 错误信息\tshowMessageDetail\tboolean\tfalse\t否\t是否返回错误详情\tcustomError\t(err: any, ctx: Koa.Context) => any\t\t否\t自定义错误，若定义，则不会执行yunfly-plugin-error中间件后续逻辑\tcustomErrorHandle\t(err: any, ctx: Koa.Context) => any\t\t否\t可用于重新组装错误，并不影响yunfly-plugin-error中间件后续逻辑的执行\tunhandledRejection\t(err: any, ctx: Koa.Context) => any\t\t否\t自定义 Promise 错误\tuncaughtException\t(err: any, ctx: Koa.Context) => any\t\t否\t自定义未能捕获的异常","bodyparser-配置#BodyParser 配置":"BodyParser 配置需要安装 @yunflyjs/yunfly-plugin-body-parser 插件。插件使用文档\n\n// body参数配置\nconfig.bodyParser = {\njsonLimit: '1mb',\nformLimit: '1mb',\nqueryString: {\nparameterLimit: 1 * 1024 * 1024,\n},\n};\n\n字段\t类型\t必填\t说明\tjsonLimit\tstring\t否\tjson 格式数据上传大小限制\tjsonLimit\tstring\t否\t表单提交数据大小限制\tqueryString\tObject\t否\turl 上传数据大小限制","currentcontext-配置#CurrentContext 配置":"CurrentContext 配置需要安装 @yunflyjs/yunfly-plugin-current-context 插件。插件使用文档\n\n/**\n* 在controller,service,util等代码位置直接获取context对象\n*/\nconfig.currentContext = {\nenable: true,\n}\n\n字段\t类型\t必填\t说明\tenable\tboolean\t是\t是否启用插件","socket-配置#Socket 配置":"// socket\nconfig.socket = {\nenable: false,\ntype: 'worker', // 可选值 worker: 随机选择一个worker执行， all: 所有worker都执行, 默认为worker\npath: '/',\n};"}},"/document/basic-function/controller":{"title":"控制器(Controller)","data":{"":"yunfly 路由底层框架库为 routing-controllers，使用 Typescript 注解能力来进行路由的开发。\nController 主要用于参加校验, 简单逻辑处理, 调用 Service 方法。","初始化项目#初始化项目":"安装 yunfly 框架\n\n\n\n\nyarn add @yunflyjs/yunfly\n\n\n配置 src/config.default.ts 中 routingControllersOptions 配置项\n\n\n\n\nconfig.routingControllersOptions = {\ncurrentUserChecker,\ndefaultErrorHandler: false,\ncontrollers: [path.join(__dirname, '../controller/*')],\nmiddlewares: [path.join(__dirname, '../middleware/*')],\ndefaults: {\nnullResultCode: 200,  // 204 | 404\nundefinedResultCode: 200 // 204 | 404\n}\n};\n\n\ntsconfig.json 中需要设置以下配置项\n\n\n\n\n{\n\"emitDecoratorMetadata\": true,\n\"experimentalDecorators\": true\n}","快速使用#快速使用":"src/controller 下新建 ExampleController.ts 文件\n\n\n\n\nimport { Controller, Param, Body, Get, Post, Put, Delete } from '@yunflyjs/yunfly';\n\n@Controller()\nexport class ExampleController {\n@Get('/users')\ngetAll() {\nreturn 'This action returns all users';\n}\n\n@Get('/users/:id')\ngetOne(@Param('id') id: number) {\nreturn 'This action returns user #' + id;\n}\n\n@Post('/users')\npost(@Body() user: any) {\nreturn 'Saving user...';\n}\n\n@Put('/users/:id')\nput(@Param('id') id: number, @Body() user: any) {\nreturn 'Updating a user...';\n}\n\n@Delete('/users/:id')\nremove(@Param('id') id: number) {\nreturn 'Removing user...';\n}\n}\n\n\n启动项目\n\n\n\n\n// 启动\nyarn dev\n\n// 监听模式启动\nyarn watch:dev\n\n\n访问\n\n\n\n\n# 浏览器将显示 This action returns all users。\nhttp://localhost:3000/users。\n\n# 将显示 This action returns user #1\nhttp://localhost:3000/users/1","使用-json#使用 JSON":"对于一个总是返回 JSON 的 REST API，建议用 @JsonController 代替 @Controller。 @JsonController 装饰的控制器路由的响应数据将自动转换为 JSON 类型且 Content-Type 被设置为 application/json。\n同时请求的 application/json 头信息也可以被解释，请求 Body 将解析为 JSON。\nimport { JsonController, Param, Body, Get, Post, Put, Delete } from '@yunflyjs/yunfly';\n\n@JsonController()\nexport class ExampleController {\n@Get('/users')\ngetAll() {\nreturn userRepository.findAll();\n}\n\n@Get('/users/:id')\ngetOne(@Param('id') id: number) {\nreturn userRepository.findById(id);\n}\n\n@Post('users')\npost(@Body() user: User) {\nreturn userRepository.insert(user);\n}\n}","返回-promise#返回 Promise":"返回一个 Promise，响应将等待该 Promise 回执后返回其结果。\nimport { JsonController, Param, Body, Get, Post, Put, Delete } from '@yunflyjs/yunfly';\n\n@JsonController()\nexport class ExampleController {\n@Get('/users')\nasync getAll() {\nreturn await userRepository.findAll();\n}\n\n@Get('/users/:id')\nasync getOne(@Param('id') id: number) {\nreturn await userRepository.findById(id);\n}\n\n@Post('/users')\nasync post(@Body() user: User) {\nreturn await userRepository.insert(user);\n}\n\n@Put('/users/:id')\nasync put(@Param('id') id: number, @Body() user: User) {\nreturn await userRepository.updateById(id, user);\n}\n\n@Delete('/users/:id')\nasync remove(@Param('id') id: number) {\nreturn await userRepository.removeById(id);\n}\n}","从目录加载控制器#从目录加载控制器":"在 config.routingControllersOptions.controllers 中指定文件夹，即可加载该目录下所有控制器：\nconfig.routingControllersOptions = {\ncontrollers: [path.join(__dirname, '../controller/*')],\n};","从目录加载中间件#从目录加载中间件":"在 config.routingControllersOptions.middlewares 中指定文件夹，即可加载该目录下所有全局中间件：\nconfig.routingControllersOptions = {\nmiddlewares: [path.join(__dirname, '../middleware/*')],\n};","路由前缀#路由前缀":"全局路由前缀\n\n要为所有路由添加前缀，比如 /api，可以使用 routePrefix 配置项：\nconfig.routingControllersOptions = {\nroutePrefix: '/api',\n}\n\n指定控制器路由前缀\n\n向控制器装饰器传递根路由参数，控制器下的路由将添加该跟路由前缀：\nimport { Controller } from \"@yunflyjs/yunfly\";\n\n@Controller('/users')\nexport class UserController {\n// ...\n}","method-装饰器#Method 装饰器":"如下图，我们需要对控制器下的不同 HTTP 方法做不同处理。如 @Get('/users/:id') 会为 GET /users/:id 请求生成路由映射，这意味着如果 GET /users/:id 请求则会走 handleGet 逻辑。同理，@Post('/users') 会为 POST /users 请求生成路由映射，POST /users 请求则会走 handlePost 逻辑。以此类推，我们针对其他 HTTP 方法 PUT DELETE PATCH HEAD 分别注入路由处理逻辑。\nimport { Controller, Param, Body, Get, Patch, Post, Head, Put, Delete } from '@yunflyjs/yunfly';\n\n@Controller()\nexport class ExampleController {\n\n@Get('/users/:id')\nhandleGet(@Param('id') id: number) {\nreturn userRepository.findById(id);\n}\n\n@Post('/users')\nhandlePost(@Body() user: User) {\nreturn userRepository.insert(user);\n}\n\n@Put('/users/:id')\nhandlePut(@Param('id') id: number, @Body() user: User) {\nreturn userRepository.updateById(id, user);\n}\n\n@Delete('/users/:id')\nhandleDelete(@Param('id') id: number) {\nreturn userRepository.removeById(id);\n}\n\n@Patch('/users/:id')\nhandlePatch() {\nreturn userRepository.updateById(id, user);\n}\n\n@Head('/users/:id')\nhandleHead() {\nreturn userRepository.removeById(id);\n}\n}\n更多方法装饰器说明：\n标识\t示例\t描述\t@Get(route: string|RegExp)\t@Get(\"/users\") all()\t匹配 HTTP GET 方法\t@Post(route: string|RegExp)\t@Post(\"/users\") save()\t匹配 HTTP Post 方法\t@Put(route: string|RegExp)\t@Put(\"/users/:id\") update()\t匹配 HTTP Put 方法\t@Patch(route: string|RegExp)\t@Patch(\"/users/:id\") patch()\t匹配 HTTP Patch 方法\t@Delete(route: string|RegExp)\t@Delete(\"/users/:id\") delete()\t匹配 HTTP Delete 方法\t@Head(route: string|RegExp)\t@Head(\"/users/:id\") head()\t匹配 HTTP Head 方法\t@All(route: string|RegExp)\t@All(\"/users/me\") rewrite()\t匹配所有 HTTP 方法","动态路由#动态路由":"controller 动态路由\n\n如果要匹配动态路由的话，可通过:[参数]的方式注入。如：\nimport { Controller } from \"@yunflyjs/yunfly\";\n\n@Controller('/users/:id')\nexport class ExampleController {\n// ...\n}\n\nmethod 动态路由\n\n\nimport { Controller, Get, Param } from \"@yunflyjs/yunfly\";\n\n@Controller('/users')\nexport class ExampleController {\n\n@Get(\"/:id\")\ngetOne(@Param(\"id\") id: number) {\n// ...\n}\n}","使用-req-和-res-对象#使用 Req 和 Res 对象":"直接使用框架的 Request 对象和 Response 对象。 如果想自己处理响应，可以在方法中返回该 Response 对象。\nimport { Controller, Req, Res, Get } from '@yunflyjs/yunfly';\n\n@Controller()\nexport class ExampleController {\n@Get('/users')\ngetAll(\n@Req() request: any,\n@Res() response: any\n) {\nreturn response.send('Hello response!');\n}\n}\n\n@Req() 装饰器注入了一个 Request 对象，@Res() 装饰器注入了一个 Response 对象。 如果安装了对应的类型声明，也可以对它们进行声明：","获取-param-参数#获取 Param 参数":"用于获取动态路由参数","param#@Param":"@Get(\"/users/:id\")\ngetOne(\n@Param(\"id\") id: number\n) {\n// 这里可以访问 id\n}","params#@Params":"@Get(\"/users/:id/:name\")\ngetOne(\n@Params() params: {id: number; name: string }\n) {\n// 这里可以访问 params.id, params.name\n}","获取-query-参数#获取 Query 参数":"获取通过 get 传递的参数","queryparam#@QueryParam":"@Get(\"/users\")\ngetUsers(\n@QueryParam(\"name\") name: string\n) {\n// 这里可以访问 name\n}","queryparams#@QueryParams":"@Get(\"/users\")\ngetUsers(\n@QueryParams() query: {name: string; age: number}\n) {\n// 这里可以访问query.name, query.age\n}","get请求单参多值#get请求单参多值":"可以使用 config.sameQueryParam 对 get 参数进行处理\n获取参数值始终为字符串\n\n\nconfig.sameQueryParam = {\nebable: true,\nisArray: false,\n}\n\n@Get(\"/users/by-multiple-ids\")\ngetUsers(@QueryParam(\"ids\", { isArray: true}) ids: string[]) {\n}\n\n// GET /users/by-multiple-ids?ids=a → ids = 'a'\n// GET /users/by-multiple-ids?ids=a&ids=b → ids = 'a,b'\n\n获取参数值始终为数组\n\n\nconfig.sameQueryParam = {\nebable: true,\nisArray: true,\n}\n\n@Get(\"/users/by-multiple-ids\")\ngetUsers(@QueryParam(\"ids\", { isArray: true}) ids: string[]) {\n}\n\n// GET /users/by-multiple-ids?ids=a → ids = ['a']\n// GET /users/by-multiple-ids?ids=a&ids=b → ids = ['a', 'b']","获取-post-参数#获取 Post 参数":"获取通过 post 传递的参数","body#@Body":"@Post(\"/users\")\nsaveUser(\n@Body() user:{name: string; age: number}\n) {\n// 这里可以访问 user.name, user.age\n}","bodyparam#@BodyParam":"@Post(\"/users\")\nsaveUser(\n@BodyParam(\"name\") name: string,\n@BodyParam(\"age\") age: number,\n) {\n// 这里可以访问 name, age\n}","获取-header-参数#获取 Header 参数":"获得 htttp header 头部信息","headerparam#@HeaderParam":"@Post(\"/users\")\nsaveUser(\n@HeaderParam(\"authorization\") token: string\n) {\n// 这里可以获得 token\n}","headerparams#@HeaderParams":"@Post(\"/users\")\nsaveUser(\n@HeaderParams() header: {token: string}\n) {\n// 这里可以获得 header.token\n}","获得-cookie-信息#获得 Cookie 信息":"用于获取 http cookie 头信息","cookieparam#@CookieParam":"@Get(\"/users\")\ngetUsers(\n@CookieParam(\"username\") username: string\n) {\n// 这里可以获得 username\n}","cookieparams#@CookieParams":"@Get(\"/users\")\ngetUsers(\n@CookieParams() cookies: { username: string }\n) {\n// 这里可以获得 cookies.username\n}","获得-session--信息#获得 Session  信息":"用于获取 session 值","sessionparam#@SessionParam":"@Get(\"/login\")\nsavePost(\n@SessionParam(\"user\") user: User,\n@Body() post: Post\n) {}","session#@Session":"@Get(\"/login\")\nsavePost(\n@Session() session: any,\n@Body() post: Post\n) {}\n\n@Session 装饰器装饰的参数默认为必填。如果你的方法中该参数是可选的，需要手动标记为非必填\n\naction(\n@Session(\"user\", { required: false }) user: User\n){}","限制必填参数#限制必填参数":"在装饰器配置 required: true 限制参数为必填：\n@Post(\"/users\")\nsave(\n@Body({\nrequired: true\n}) user: any\n) {\n// 如果请求内没有user参数，该方法不会执行\n}\n\n可以在其它任何参数装饰器中限制必填参数，如 @QueryParam, @BodyParam 等。 如果请求中没有必填参数，yunfly 框架将抛出一个错误。","设置-contenttype#设置 ContentType":"为路由设置 ContentType：\n@Get(\"/users\")\n@ContentType(\"text/cvs\")\ngetUsers() {\n// ...\n}","设置-location#设置 Location":"为路由设置 Location：\n@Get(\"/users\")\n@Location(\"http://github.com\")\ngetUsers() {\n// ...\n}","设置重定向#设置重定向":"为路由设置重定向：\n@Get(\"/users\")\n@Redirect(\"http://github.com\")\ngetUsers() {\n// ...\n}\n通过返回字符串覆写重定向地址：\n@Get(\"/users\")\n@Redirect(\"http://github.com\")\ngetUsers() {\nreturn \"https://www.google.com\";\n}\n使用模板生成重定向：\n@Get(\"/users\")\n@Redirect(\"http://github.com/:owner/:repo\")\ngetUsers() {\nreturn {\nowner: \"pleerock\",\nrepo: \"@yunflyjs/yunfly\"\n};\n}","设置-http-响应代码#设置 HTTP 响应代码":"可以显式设置 HTTP 响应代码：\n@HttpCode(201)\n@Post(\"/users\")\nsaveUser(@Body() user: User) {\n// ...\n}","管理空响应#管理空响应":"对于返回 void 或 Promise<void> 或 undefined 的控制器方法，将自动向客户端抛出 404 错误。 @OnUndefined 装饰器可用于设置这种情况下的状态码。\n@Delete(\"/users/:id\")\n@OnUndefined(204)\nasync remove(@Param(\"id\") id: number): Promise<void> {\nreturn userRepository.removeById(id);\n}\n对于返回值可能为 undefined 的情况，@OnUndefined 也可以发挥作用。下面例子中，当用户 id 不存在时 findOneById 返回 undefined，该路由将返回 404 代码，如果存在则返回 200 代码：\n@Get(\"/users/:id\")\n@OnUndefined(404)\ngetOne(@Param(\"id\") id: number) {\nreturn userRepository.findOneById(id);\n}\n当结果为 undefined 时也可以返回一个错误类：\nimport { HttpError } from '@yunflyjs/yunfly';\n\nexport class UserNotFoundError extends HttpError {\nconstructor() {\nsuper(404, 'User not found!');\n}\n}\n@Get(\"/users/:id\")\n@OnUndefined(UserNotFoundError)\nsaveUser(@Param(\"id\") id: number) {\nreturn userRespository.findOneById(id);\n}\n如果控制器方法返回 null 可以用 @OnNull 装饰器替代。","自定义-header#自定义 Header":"定义任意 Header 信息：\n@Get(\"/users/:id\")\n@Header(\"Catch-Control\", \"none\")\ngetOne(@Param(\"id\") id: number){\n// ...\n}","抛出-http-错误#抛出 HTTP 错误":"抛出 HTTP 错误请参考 错误类使用章节：错误类使用","使用中间件#使用中间件":"@Middleware 装饰器用于自定义中间件， @UseBefore 和 @UseAfter 装饰器使用任何已有的或自定义的 Koa 中间件。","usebefore#@UseBefore":"中间件执行之前做什么事情\nimport { Controller, Get, UseBefore } from \"@yunflyjs/yunfly\";\n// ...\n\n@Get(\"/users/:id\")\n@UseBefore(CheckParams)\ngetOne(@Param(\"id\") id: number) {\n// ...\n}","useafter#@UseAfter":"中间件执行之后做什么事情\nimport { Controller, Get, UseBefore } from \"@yunflyjs/yunfly\";\n// ...\n\n@Get(\"/users/:id\")\n@UseAfter(RecordLog)\ngetOne(@Param(\"id\") id: number) {\n// ...\n}","在方法中使用中间件#在方法中使用中间件":"import { Controller, Get, UseBefore } from \"@yunflyjs/yunfly\";\nlet compression = require(\"compression\");\n\n// ...\n\n@Get(\"/users/:id\")\n@UseBefore(compression())\ngetOne(@Param(\"id\") id: number) {\n// ...\n}","在控制器中使用中间件#在控制器中使用中间件":"import { Controller, UseBefore } from '@yunflyjs/yunfly';\nlet compression = require('compression');\n\n@Controller()\n@UseBefore(compression())\nexport class UserController {}","自定义中间件#自定义中间件":"","定义一个普通中间件#定义一个普通中间件":"import { KoaMiddlewareInterface } from \"@yunflyjs/yunfly\";\nexport class MyMiddleware implements KoaMiddlewareInterface {\nasync use(context: any, next: (err?: any) => Promise<any>): Promise<any> {\nconsole.log(\"do something before execution...\");\nreturn await next()\nconsole.log(\"do something after execution...\");\n}\n}","普通中间件应用#普通中间件应用":"Controller 中应用\n\n\nimport {Controller, UseBefore, UseAfter} from \"@yunflyjs/yunfly\";\nimport {MyMiddleware} from \"./MyMiddleware\";\nimport {loggingMiddleware} from \"./loggingMiddleware\";\n//...\n@Controller()\n@UseBefore(MyMiddleware)\n@UseAfter(loggingMiddleware)\nexport class UserController {\n// ...\n}\n\n方法中使用\n\n\nimport { Get, UseBefore, UseAfter} from \"@yunflyjs/yunfly\";\nimport {MyMiddleware} from \"./MyMiddleware\";\nimport {loggingMiddleware} from \"./loggingMiddleware\";\n@Get(\"/users/:id\")\n@UseBefore(MyMiddleware)\n@UseAfter(loggingMiddleware)\ngetOne(@Param(\"id\") id: number) {\n// ...\n}","定义一个全局中间件#定义一个全局中间件":"import { KoaMiddlewareInterface,Middleware } from \"@yunflyjs/yunfly\";\n\n@Middleware({ type: 'before' })\nexport class MyMiddleware implements KoaMiddlewareInterface {\nasync use(context: any, next: (err?: any) => Promise<any>): Promise<any> {\nconsole.log(\"do something before execution...\");\nawait next()\nconsole.log(\"do something after execution...\");\n}\n}","全局中间件应用#全局中间件应用":"config.routingControllersOptions = {\nmiddlewares: [path.join(__dirname, '../middleware/*')],\n};","更多中间件装饰器说明#更多中间件装饰器说明":"标识\t示例\t描述\t@Middleware({type: \"before\"|\"after\"})\t@Middleware({ type: \"before\"}) class SomeMiddleware\t注册全局中间件\t@UseBefore()\t@UseBefore(CompressionMiddleware)\t请求开始前调用\t@UseAfter()\t@UseAfter(CompressionMiddleware)\t请求结束后调用\t@Interceptor()\t@Interceptor() class SomeInterceptor\t注册全局拦截器\t@UseInterceptor()\t@UseInterceptor(BadWordsInterceptor)\t拦截 Controller / Action，替换某些值","其他装饰器#其他装饰器":"有时候我们需要对接口进行鉴权，这时就需要用到 @Authorized 装饰器了。\n如下图，我们示范如何在 yunfly 使用 @Authorized。\n\nconfig.default.ts 增加对 routingControllersOptions 配置：\n\n\n\n\n{\nconfig.routingControllersOptions = {\n// 代码Demo\nauthorizationChecker: async (action: Action, roles: string[]) => {\n// 这里可以使用action中的request/response对象\n// 如果装饰器定义了可以访问action角色\n// 也可以使用它们来提供详细的鉴权\n// checker必须返回boolean类型(true or false)或者Promise(回执也必须是boolean)\nconst token = action.request.headers['authorization'];\n\nconst user = await getEntityManager().findOneByToken(User, token);\nif (user && !roles.length) return true;\nif (user && roles.find(role => user.roles.indexOf(role) !== -1)) return true;\n\nreturn false;\n})\n}\n}\n\n\n在路由中使用 @Authorized\n\n\n\n\nimport { Controller, Post, Authorized, Body } from '@yunflyjs/yunfly';\n\n@Controller()\nexport class UserController {\n@Authorized()\n@Post('/questions')\nsave(@Body() question: Question) {}\n\n@Authorized('POST_MODERATOR') // 指定角色或角色数组\n@Post('/posts')\nsave(@Body() post: Post) {}\n}\n更多装饰器说明\n标识\t示例\t描述\t@Authorized(roles?: string|string[])\t@Authorized(\"SUPER_ADMIN\") get()\t授权检查\t@CurrentUser(options?: { required?: boolean })\tget(@CurrentUser({ required: true }) user: User)\t注入当前授权的用户\t@Header(headerName: string, headerValue: string)\t@Header(\"Cache-Control\", \"private\") get()\t自定义相应头部信息\t@ContentType(contentType: string)\t@ContentType(\"text/csv\") get()\t自定义响应头部 HTTP Content-Type 信息\t@Location(url: string)\t@Location(\"http://github.com\") get()\t自定义响应头部 HTTP Location 信息\t@Redirect(url: string)\t@Redirect(\"http://github.com\") get()\t自定义响应头部 HTTP Redirect 信息\t@HttpCode(code: number)\t@HttpCode(201) post()\t自定义响应 HTTP code\t@OnNull(codeOrError: number|Error)\t@OnNull(201) post()\t当真实响应的 HTTP code  为 null 时，设置 HTTP code\t@OnUndefined(codeOrError: number|Error)\t@OnUndefined(201) post()\t当真实响应的 HTTP code  为 undefined 时，设置 HTTP code\t@Render(template: string)\t@Render(\"user-list.html\") get()\t渲染给定的 HTML 模板，控制器返回的数据用作模板变量","自定义装饰器#自定义装饰器":"您也可以通过包装现有装饰器或者采用 @yunflyjs/yunfly 提供的方法创建新的装饰器，如下：\n\n使用 @yunflyjs/yunfly 提供的 createParamDecorator 创建参数装饰器\n\n\n\n\nimport { createParamDecorator } from '@yunflyjs/yunfly';\n\nexport function UserFromSession(options?: { required?: boolean }) {\nreturn createParamDecorator({\nrequired: options && options.required ? true : false,\nvalue: action => {\nconst token = action.request.headers['authorization'];\nreturn database.findUserByToken(token);\n},\n});\n}\n\n\n\n通过包装现有装饰器\n\n\n\n\nimport { UseAfter } from '@yunflyjs/yunfly';\nimport { IResponseType } from '../types';\nimport { handleResponseType } from './handle';\n\nexport const ResponseType = function (type: IResponseType) {\n// 进行包装\nreturn UseAfter(handleResponseType(type, true));\n};\n更多详细用法请参考：https://www.npmjs.com/package/routing-controllers#using-middlewares"}},"/document/basic-function/directory-struct":{"title":"目录结构","data":{"":"├── package.json\n├── README.md\n├── tsconfig.json\n├── .gitignore\n├── src\n│    ├── config\n│    │  └── config.default.ts\n│    │  └── config.local.ts (可选)\n│    │  └── config.test.ts  (可选)\n│    │  └── config.release.ts (可选)\n│    │  └── config.prod.ts (可选)\n│    │  └── config.middleware.ts (可选)\n│    ├── controller\n│    │  └── ExampleController.ts\n│    ├── middleware\n│    │  └── ExampleMIddleware.ts\n│    ├── service\n│    │  └── ExampleService.ts\n│    ├── alone\n│    │  └── alone1.ts\n│    │  └── alone2.ts\n│    ├── schedule\n│    │  └── task1.ts\n│    │  └── task2.ts\n│    ├── socket\n│    │  ├── controller\n│    │  │   └── MainController.ts\n│    │  └── middleware\n│    │      └── socketMiddleware.ts\n│    ├── plugin\n│    │   └── yunfly-plugin-email\n│    │       ├── src\n│    │       │   ├── config\n│    │       │   │   └── config.default.ts\n│    │       │   └── app.ts\n│    │       ├── tsconfig.json\n│    │       ├── README.md\n│    │       └── package.json\n│    └── app.ts\n\n\ntsconfig.json Ts规则配置项  详细配置参考\ncontroller BFF controller 层\nmiddleware 中间件\nservice BFF service 层\nalone alone 进程执行文件\nschedule 定时任务文件 （一个文件表示一个定时任务）\nconfig BFF 配置器\napp.ts 可配置服务启动文件","备注#备注":"为保持代码规范一致性 controller、service 文件尽量以大写字母开头，分别以 Controller、Service 后缀结尾。\n根据自身业务的复杂度来决定 controller 和 service 下是否再拆分文件夹。"}},"/document/basic-function/lifehook":{"title":"生命周期","data":{"":"yunfly 提供了4个生命周期钩子，便于开发者可以在 应用开始前、 配置加载完后、 服务初始化后、应用启动后 这些关键生命时刻进行操作。","生命周期事件说明#生命周期事件说明":"字段\t类型\t说明\tbeforeStart\tfunction\tBFF应用开始前执行的内容，此处可做一些日志打印标识\tconfigDidReady\tfunction\tConfig配置文件加载完成，此处可以对Config配置进行更改\tappDidReady\tfunction\t单线程：此处表示初始化koa服务完成。 多线程：此处表示alone进程与所有worker进程初始化koa服务完成。此处可以做一些初始化操作，例如redis初始化。\tafterStart\tfunction\tBFF应用启动完毕之后执行，此处可做一些日志打印标识","使用#使用":"根目录 src 下新建 app.ts 文件，文件内容如下：\nimport { Config } from '@yunflyjs/yunfly'\n\n/**\n* BFF 生命周期\n*\n* @export\n* @class AppLifeHook\n*/\nexport default class AppLifeHook {\nconstructor() { }\n\n// app 启动之前执行\nbeforeStart() {\nconsole.log('---------beforeStart----------')\n}\n\n// config 配置加载完成之后执行\nconfigDidReady(config: Config) {\n// config.name = 'zane'\n}\n\n// 多线程时：当 alone 进程和 worker 进程执行完成之后执行\n// 多线程时，此处的代码将会在 worker 中执行\nappDidReady(config: Config, app: any) {\n\n}\n\n// app 启动之后执行\nafterStart(config: Config) {\nconsole.log('---------afterStart----------')\n}\n\n}\n\n加载插件时，也可以指定在不同生命周期进行加载。详情请看lifeHook参数"}},"/document/basic-function/logger":{"title":"日志","data":{"":"logger 日志库，同时把日志输出到控制台与日志系统中，可以自定义控制台输出能力。","使用#使用":"","使用-logger-api#使用 logger api":"import { logger } from '@yunflyjs/yunfly';\n\nlogger.log('1111');\nlogger.info('hello %d', 'world!');\nlogger.error('some error!');\nlogger.access('access log');\n\n因为框架代理了 console 方法，因此以下使用方式同效。\n\nconsole.log('1111');\nconsole.info('hello %d', 'world!');\nconsole.error('some error!');\nconsole.access('access log');","链式调用#链式调用":"import { logger } from '@yunflyjs/yunfly';\n\n// 颜色输出\nlogger.color('#2e8555').log('1111');\n\n// 日志前缀\nlogger.prefix('yunfly').info('hello %d', 'world!');\n\n// 控制台同步输出\nlogger.window().error('some error!');","日志储存类型#日志储存类型":"框架日志主要分为3种类型的日志：\n\n记录常规业务需求日志的 business.log 日志\n\n\n\n记录错误信息的 error.log 日志\n\n\n\n记录框架请求链路的 access.log 日志","console-与日志储存关系#console 与日志储存关系":"","businesslog#business.log":"console.log\nconsole.info\nconsole.warn\nconsole.trace\nconsole.debug\n\n// 等价于\nlogger.log\nlogger.info\nlogger.warn\nlogger.trace\nlogger.debug\n以上打印日志都会存储到 business.log\n推荐使用 logger.info 进行日志的打印","errorlog#error.log":"console.error\n\n// 等价于\nlogger.error","accesslog#access.log":"console.access\n\n// 等价于\nlogger.access","方法说明#方法说明":"","color#color":"控制台输出日志时附带颜色（开发模式下有效）\nimport { logger } from '@yunflyjs/yunfly';\n\n// 自定义输出颜色\nlogger.color('#2e8555').log('自定义输出颜色');\n\n// 随机输出颜色\nlogger.color().log('随机输出颜色');","window#window":"生产环境下日志默认输出到日志文件中，控制台不输出日志，可以通过 window 方法来定义控制台是否输出日志。\nimport { logger } from '@yunflyjs/yunfly';\n\nlogger.window().log('控制台中也输出日志');","prefix#prefix":"输出日志附加前缀并给当前日志打标识\nimport { logger } from '@yunflyjs/yunfly';\n\nlogger.prefix('yunfly').log('这是输出的日志内容!');\n// output: 【yunfly】: 这是输出的日志内容!\n\n备注：\n\nprefix: 当前log名称, 可通过 process.env.YUNFLY_DEBUG 和 process.env.YUNFLY_DEBUG_TYPE 进行控制输出, 跟 debug 库类似。\n案例二：通过 YUNFLY_DEBUG 环境变量控制日志输出\n\n\nimport { logger } from '@yunflyjs/yunfly';\n\nprocess.env.YUNFLY_DEBUG = 'yunfly';\n\nlogger.prefix('yunfly').info('控制台输出当前日志!');\n// output: 【yunfly】: 控制台输出当前日志!\n\nlogger.prefix('yundoc').info('控制台不会输出当前日志!');\n// output:","onlysign#onlySign":"当使用 prefix 给日志添加标识时，日志输出会附加标识前缀, 如果只想做日志标识而不想输出前缀，这时可通过 onlySign 进行控制。\nimport { logger } from '@yunflyjs/yunfly';\n\nlogger.prefix('yunfly').info('控制台输出有前缀的日志!');\n// output: 【yunfly】: 控制台输出有前缀的日志!\n\nlogger.prefix('yunfly').onlySign().info('控制台不会输出有前缀的日志!');\n// output: 控制台不会输出有前缀的日志!","logfilter#logFilter":"日志信息过滤函数。\n通过链式调用配置日志过滤器\n\n\nimport { logger } from '@yunflyjs/yunfly';\n\nconst logFilter = (logType?: any, ...optionalParams: any[]) =>\noptionalParams.map((item: any) => {\nif (typeof item === 'string') {\n// 过滤密码等敏感字符\nreturn item.replace(/(\"password\\\\?\":\\\\?\")([^\\\\?\"]+)(\\\\?\")/g, (target, $1, $2, $3) => `${$1}${new Array($2.length).join('*')}${$3}`);\n}\nreturn item;\n});\n\nlogger.logFilter(logFilter).info('password: 123456');\n\n通过 api 设置日志过滤器\n\n\nimport { logger } from '@yunflyjs/yunfly';\n\nconst logFilter = (logType?: any, ...optionalParams: any[]) =>\noptionalParams.map((item: any) => {\nif (typeof item === 'string') {\n// 过滤密码等敏感字符\nreturn item.replace(/(\"password\\\\?\":\\\\?\")([^\\\\?\"]+)(\\\\?\")/g, (target, $1, $2, $3) => `${$1}${new Array($2.length).join('*')}${$3}`);\n}\nreturn item;\n});\n\nsetLogFilter(logFilter);\n\nlogger.info('password: 123456');","argumentshandle#argumentsHandle":"日志打印之前对日志参数进行处理函数。\n通过链式调用配置处理器\n\n\nimport { logger } from '@yunflyjs/yunfly';\n\nconst handle = (...args: any[]): any[] => {\nreturn args.map((item)=>{\nreturn item + '加了一点东西!'\n})\n}\n\nlogger.argumentsHandle(handle).info('自定义日志处理逻辑！');\n\n通过 setArgsHandle 配置处理器\n\n\nimport logger, { setArgsHandle } from '@yunflyjs/loggers';\n\nconst handle = (...args: any[]): any[] => {\nreturn args.map((item)=>{\nreturn item + '加了一点东西!'\n})\n}\n\nsetArgsHandle(handle)\n\nlogger.info('自定义日志处理逻辑！');","其他知识#其他知识":"","processenvyunfly_debug#process.env.YUNFLY_DEBUG":"当使用 debug 进行日志打印时， 可以通过环境变量来控制打印的输出\n开发环境有效\n使用场景： 开发模式下，控制台输出的日志太多，可以手动控制输出日志信息。\nprocess.env.YUNFLY_DEBUG = 'logger1';\n\n// output: 【logger1】: logger1\n\nprocess.env.YUNFLY_DEBUG = 'logger1,logger3';\n/*\n* output:\n* 【logger1】: logger1\n* 【logger3】: logger3\n*/","processenvyunfly_debug_type#process.env.YUNFLY_DEBUG_TYPE":"当使用根据环境变量来控制日志输出时，我们可以决定是包含的还是输出，排查设置的才输出。当前环境变量取值为：include 或 exclude\nprocess.env.YUNFLY_DEBUG = 'logger1';\nprocess.env.YUNFLY_DEBUG_TYPE = 'include';\n// output: 【logger1】: logger1\n\nprocess.env.YUNFLY_DEBUG = 'logger1';\nprocess.env.YUNFLY_DEBUG_TYPE = 'exclude';\n/*\n* output:\n* 【logger2】: logger2\n* 【logger3】: logger3\n*/","通过配置控制日志输出内容#通过配置控制日志输出内容":"config.setEnv = {\n'YUNFLY_DEBUG': 'client-request',\n'YUNFLY_DEBUG_TYPE': 'exclude', // exclude | include\n};\n\n备注： 需要安装 @yunflyjs/yunfly-plugin-set-env 插件。","通过环境变量控制日志输出#通过环境变量控制日志输出":"// 在 beforeStart 生命周期中设置环境变量\nprocess.env.YUNFLY_DEBUG_TYPE = 'exclude';\nprocess.env.YUNFLY_DEBUG = 'client-request';\n\nYUNFLY_DEBUG 可选日志参数说明\n\n\n名称\t说明\tclient-request\tclient 端(例如：浏览器)向 BFF发起的 HTTP 请求链路日志\thttp-request\tBFF 发起的 HTTP 请求链路日志\tgrpc-request\tBFF 发起的RPC 请求链路日志\tgrpc-restart\tRPC 请求过程中的 init 和 restart 日志\tservice-crypto\tRPC 请求过程中的 init 和 restart 日志\n\nYUNFLY_DEBUG_TYPE 参数说明\n\nYUNFLY_DEBUG_TYPE 的值为 exclude 或者 include。 当值为 include 时，表示只输出 YUNFLY_DEBUG 定义的日志。"}},"/document/basic-function/middleware-config":{"title":"中间件配置","data":{"":"提示：推荐使用插件模型。\n中间件配置核心是为了直接运行 koa 中间件而存在的产物(已不推荐使用, 推荐使用 routing-controllers 中间件。。src/config 下新增 config.middleware.ts 文件。","中间件案例#中间件案例":"定义一个全局中间件，设置 ctx.name = 'zane'，这样每个请求都会带上 name 参数\nimport { KoaApp, Config } from '@yunflyjs/yunfly'\nexport default function KoaMiddleware(app: KoaApp, config: Config) {\n// 挂载中间件\napp.use(async (ctx: any, next: any) => {\nctx.name = 'zane'\nawait next()\n})\n}"}},"/document/basic-function/middleware":{"title":"中间件(Middleware)","data":{"":"BFF中间件就是 koa 中间件，koa 中间件是洋葱圈模型。每次我们编写一个中间件，就相当于在洋葱外面包了一层。","从目录加载中间件#从目录加载中间件":"在 config.routingControllersOptions.middlewares 中指定文件夹，即可加载该目录下所有全局中间件：\nconfig.routingControllersOptions = {\nmiddlewares: [path.join(__dirname, '../middleware/*')],\n};","开发中间件#开发中间件":"开发一个普通中间件\n\n\nimport { KoaMiddlewareInterface, Context } from \"@yunflyjs/yunfly\";\n\nexport class MyMiddleware implements KoaMiddlewareInterface {\nasync use(context: Context, next: (err?: any) => Promise<any>): Promise<any> {\nconsole.log(\"do something before execution...\");\nawait next()\nconsole.log(\"do something after execution...\");\n}\n}","使用中间件#使用中间件":"","controler-级别中间件#Controler 级别中间件":"你可以对一个 Controler 使用自定义的中间件\n\n\n使用 @UseBefore 和 @UseAfter 来决定中间件的执行时机\n\nimport { Controller, UseBefore, UseAfter } from \"@yunflyjs/yunfly\";\nimport { MyMiddleware } from \"./MyMiddleware\";\n//...\n@Controller()\n@UseBefore(MyMiddleware)\nexport class UserController {\n// ...\n}","method-级别中间件#Method 级别中间件":"可以只针对于某个 Method 使用中间件\n\n\n使用 @UseBefore 和 @UseAfter 来决定中间件的执行时机","method-中间件#method 中间件":"如果您只需中间件作用于具体的方法，则是在方法前进行注入。如下面注入的 @UseBefore 和 @UseAfter，只作用于 getOne 方法。\nimport { Get, UseBefore, UseAfter } from \"@yunflyjs/yunfly\";\nimport { MyMiddleware } from \"./MyMiddleware\";\n\n@Get(\"/users/:id\")\n@UseBefore(MyMiddleware)\ngetOne(@Param(\"id\") id: number) {\n// ...\n}","全局中间件#全局中间件":"Controller 和 Method 级别中间件都是手动配置，自定义使用位置。\n\n全局中间件的含义跟 koa 中间件一致，即不需要手动申明，配置一次全局生效。\n\n升级为全局中间件只需要在普通中间件基础之上添加 @Middleware 中间件即可实现。\nimport { KoaMiddlewareInterface, Context, Middleware } from \"@yunflyjs/yunfly\";\n\n@Middleware({ type: 'before' })\nexport class MyMiddleware implements KoaMiddlewareInterface {\nasync use(context: Context, next: (err?: any) => Promise<any>): Promise<any> {\nconsole.log(\"do something before execution...\");\nawait next()\nconsole.log(\"do something after execution...\");\n}\n}\n\nMiddleware 参数说明\n\n\n字段\t类型\t说明\ttype\t\"after\" | \"before\"\t执行时机 等效于 @UseBefore, @UseAfter\tpriority\tboolean\t优先级，值越小，优先级越高","使用#使用":"config.default.ts 文件增加 routingControllersOptions 配置进行全局中间件的加载。这样每个请求都会经过这些全局中间件。\n{\nconfig.routingControllersOptions = {\nmiddlewares: [path.join(__dirname, '../middleware/*')],\n}\n}\n详细中间件使用方式请 参考文档","插件中间件#插件中间件":"你还可以从插件中加载中间件，例如 @yunflyjs/yunfly-plugin-logger 中间件。\n安装依赖\n\n\nyarn add @yunflyjs/yunfly-plugin-logger\n\n使用插件中间件\n\n\n/**\n* yunfly 插件\n* 数组顺序就是插件的加载顺序\n*/\nimport { PluginConfig } from '@yunflyjs/yunfly';\n\nconst plugins: PluginConfig[] = [\n{\nname: 'log',\npackage: '@yunflyjs/yunfly-plugin-logger',\n},\n];\n\nexport default plugins;\n\n配置插件参数\n\n\nconfig.log = {\nenable: true,\n......\n}\n\n插件中间件代码案例","中间件执行顺序#中间件执行顺序":"","执行顺序#执行顺序":"插件中间件 > 项目业务中间件","中间件权重#中间件权重":"priority 参数可以调整中间件执行顺序，数字越大，执行顺序越靠前。\nimport { KoaMiddlewareInterface, Context, Middleware } from '@yunflyjs/yunfly';\n\n@Middleware({ type: 'before', priority: 10 })\nexport class MyMiddleware implements KoaMiddlewareInterface {\nasync use(context: Context, next: (err?: any) => Promise<any>): Promise<any> {\nconsole.log('当前中间件权重为10');\nreturn await next();\n}\n}"}},"/document/basic-function/plugin-config":{"title":"插件配置","data":{"":"config 用于配置插件启动时所需要的配置项, plugin 用来做插件的定义, 它决定项目可以使用那些插件。\nsrc/config 文件目录下新增 config.plugin.ts 文件用来管理项目的插件。","完整的插件案例#完整的插件案例":"/**\n* yunfly 插件\n* 数组顺序就是插件的加载顺序\n*/\nimport * as path from 'path'\n//\nconst plugins: {[key:string]: string}[] = [\n/**\n* hello 插件\n* 使用path模式\n*/\n{\nname: 'hello',\npath: path.join(__dirname, '../plugin/yunfly-plugin-hello'),\n},\n/**\n* redis 插件\n* 使用npm包模式\n*/\n{\nname: 'redis',\npackage: '@yunflyjs/yunfly-plugin-redis'\n}\n];\n//\nexport default plugins;","插件类型#插件类型":"export interface PluginConfig {\nname: string;\npath?: string;\npackage?: string;\nasync?: boolean;\nlifeHook?: 'beforeStart' | 'appDidReady' | 'afterStart';\npriority?: number;\n}","参数说明#参数说明":"字段\t类型\t必选\t说明\tname\tstring\t是\t当前插件配置的唯一标识 name, 跟 config.default.ts 中字段保持一致, name 字段很有用，它用来标识是否有重复插件和插件覆盖的能力\tpackage\tstring\t否\tnpm包插件名，例如: @yunflyjs/yunfly-plugin-redis。 (备注：package 与 path 必须有一个字段为真)\tpath\tstring\t否\t本地开发 插件目录地址 (备注：package 与path 必须有一个字段为真)\tasync\tboolean\t否\t若为 false，表示同步加载插件，加载完才会加载下一个插件；否则为异步加载，不阻塞其他插件加载（默认值为： true）。\tlifeHook\tstring\t否\t可选值：beforeStart、configDidReady、appDidReady、afterStart，表示在哪个生命周期进行加载。默认在 appDidReady 周期下加载插件。想进一步了解生命周期可看\tpriority\tnumber\t否\t插件自定义执行顺序, 数字越小约先执行，默认值：50"}},"/document/basic-function/plugin":{"title":"插件","data":{"":"","插件概述#插件概述":"插件是对框架能力的增强，它可以保证 yunfly 框架本身的简洁、稳定、高效，还可以促进业务逻辑的复用，生态圈的形成。","为什么要用插件#为什么要用插件":"中间件加载其实是有先后顺序的, koa 中间件无法管理这种顺序\n中间件的定位是拦截用户请求，并在它前后做一些事情，例如：鉴权、安全检查、访问日志等等。但实际情况是，有些功能是和请求无关的，例如：redis、apollo、定时任务、消息订阅、业务逻辑等等。\n有些功能包含非常复杂的初始化逻辑，需要在应用启动的时候完成。这显然也不适合放到中间件中去实现。\n\n综上几点，我们需要一套更加强大的机制，来管理、运行那些相对独立的业务逻辑。","插件使用#插件使用":"下面以 redis 插件为案例\n\n安装 redis npm包\n\n\n\n\nyarn add @yunflyjs/yunfly-plugin-redis\n\n\nconfig/config.plugin.ts 下声明插件\n\n\n\n\n/**\n* yunfly 插件\n* 数组顺序就是插件的加载顺序\n*/\nconst plugins: {[key:string]: string}[] = [\n/**\n* redis 插件\n* 使用npm包模式\n*/\n{\nname: 'redis',\npackage: '@yunflyjs/yunfly-plugin-redis'\n}\n];\n//\nexport default plugins;\n\n\nconfig.default.ts 中新增 redis 插件配置\n\n\n\n\n/**\n* 使用私有的redis库\n*/\nconfig.redis = () => {\nreturn {\nenable: true,\nhost: 'xxx',\npassword: 'xxx',\nport: 'xxx',\n}\n};","插件配置参数说明#插件配置参数说明":"字段\t类型\t必选\t说明\tname\tstring\t是\t当前插件配置的唯一标识name, 跟config.default.ts中字段保持一致, name 字段很有用，它用来标识是否有重复插件和插件覆盖的能力\tpackage\tstring\t否\tnpm包插件名，例如: @yunflyjs/yunfly-plugin-redis。 (备注：package与path必须有一个字段为真)\tpath\tstring\t否\t本地开发插件目录地址 (备注：package与path必须有一个字段为真)\tasync\tboolean\t否\t若为 true，表示同步加载插件，加载完才会加载下一个插件；否则为异步加载，不阻塞其他插件加载。\tlifeHook\tstring\t否\t可选值：beforeStart、configDidReady、appDidReady、afterStart，表示在哪个生命周期进行加载。默认在 appDidReady 周期下加载插件。参考：框架生命周期介绍\tpriority\tnumber\t否\t默认值为：50, 值越小越先执行插件","package-和-path#package 和 path":"package 是 npm 方式引入，也是最常见的引入方式\npath 是绝对路径引入，如应用内部抽了一个插件，但还没达到开源发布独立 npm 的阶段\n\n\n关于这两种方式的使用场景，可以参见：渐进式开发。","开发插件#开发插件":"当前文档只是对插件使用的描述，若想要了解更多请查看：插件开发篇"}},"/document/basic-function/service":{"title":"服务(service)","data":{"":"Service 主要用于逻辑处理, RPC, HTTP接口聚合等能力。\n\n常规案例介绍","简单逻辑处理#简单逻辑处理":"逻辑\n\n\nimport { Service } from '@yunflyjs/yunfly';\n\n@Service()\nexport default class ExampleService {\n\n/**\n* 简单逻辑计算\n*\n* @memberof ExampleService\n*/\nsum (request: {a: number, b: number}): number {\nreturn a + b;\n}\n\n}\n\n使用\n\n\nimport { JsonController, Inject, Get, QueryParam } from \"@yunflyjs/yunfly\";\nimport { ExampleService } from \"../service/ExampleService\";\n\n@JsonController('/example')\nexport class ExampleController {\n@Inject() private exampleService: ExampleService;\n\n@Get('/sum')\nsum (\n@QueryParam('a') a: number,\n@QueryParam('b') b: number,\n) {\nreturn this.exampleService.sum({ a, b });\n}\n}","请求-http-接口#请求 HTTP 接口":"逻辑\n\n\nimport { Service } from '@yunflyjs/yunfly';\n\n@Service()\nexport default class ExampleService {\n\n/**\n* 发起 HTTP 请求\n*\n* @memberof ExampleService\n*/\nasync getDataFromAxios(): Promise<string> {\ntry {\nconst url = 'https://xxx.com/api/get-some-thing'\nconst res = await axios.get(url);\nreturn res.data;\n} catch (err) {\nthrow err;\n}\n}\n}\n\n使用\n\n\nimport { JsonController, Inject, Get, QueryParam } from \"@yunflyjs/yunfly\";\nimport { ExampleService } from \"../service/ExampleService\";\n\n@JsonController('/example')\nexport class ExampleController {\n@Inject() private exampleService: ExampleService;\n\n@Get('/get-data-from-axios')\nasync getDataFromAxios () {\nreturn await this.exampleService.getDataFromAxios();\n}\n}","请求-rpc-接口#请求 RPC 接口":"逻辑\n\n\nimport { Service } from '@yunflyjs/yunfly';\nimport { MetaData } from '../../types/common.type';\nimport { exampleServiceV2 } from '../../grpc-code-gen/yued/grpc-server-example/example/ExampleService';\n\n@Service()\nexport default class ExampleService {\n\nasync doSomething(request: {name: string;age:number}): Promise<any> {\nconst { error, response }: any = await exampleServiceV2.DoSomething({\nrequest\n});\n\nif (error) {\nthrow error;\n}\n\nreturn response;\n}\n}\n\n使用\n\n\nimport { JsonController, Inject, Get, QueryParams } from \"@yunflyjs/yunfly\";\nimport { ExampleService } from \"../service/ExampleService\";\n\n@JsonController('/example')\nexport class ExampleController {\n@Inject() private exampleService: ExampleService;\n\n@Get('/get-data-from-axios')\nasync DoSomething (\n@QueryParams() params: {name: string;age:number}\n) {\nreturn await this.exampleService.DoSomething({ request: params });\n}\n}"}},"/document/basic-function/timing-task":{"title":"定时任务","data":{"":"绝大部分场景下，HTTP 请求相应模型时满足我们的需求的，某些特殊场景下需要定时任务的支持。框架内部集成了定时任务能力。","使用#使用":"1、根目录 src 下新增 schedule 文件夹\n2、schedule 新增定时任务文件（可任意命名，建议命名规范 如：id-task.ts、source-task.ts）\n3、按如下固定格式进行代码的编写\n\n\nimport { KoaApp, Config } from '@yunflyjs/yunfly'\n\nexport default function schedule () {\nreturn {\nschedule: {\ncron: '*/5 * * * * *',\nenable: false,\ntype: 'worker'  // 可选值 worker: 随机选择一个worker执行， all: 所有worker都执行, 默认为worker\n},\ntask: (config: Config, app?: KoaApp) => {\nconsole.log('scheduleCronstyle:' + new Date());\n}\n}\n}","说明#说明":"其中 schedule 为配置项\ncron 为定时规则，（通用），使用规则请参考：node-schedule，node-cron\nenable 配置项来决定是否启用  true为启用，false为不启用\ntype 在 cluster 模式下， 值为 worker 时，表示随机选择一个 worker 执行定时任务， 值为 all 时，表示所有 worker 都执行定时任务\ntask 即为需要实现的定时任务逻辑","cron-表达式范例#Cron 表达式范例":"每隔5秒执行一次：*/5 * * * * *\n每隔1分钟执行一次：0 */1 * * * *\n每天23点执行一次：0 0 23 * * *\n每天凌晨1点执行一次：0 0 1 * * *\n每月1号凌晨1点执行一次：0 0 1 1 * *\n每月最后一天23点执行一次：0 0 23 L * *\n每周星期天凌晨1点实行一次：0 0 1 * * L\n在26分、29分、33分执行一次：0 26,29,33 * * * *\n每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * *\n\n注意点：\n\n\n由于定时任务服务是针对于单台机器单个服务，因此当我们的服务为集群时（即多个service服务，也就是处理同一件事情有多个定时任务时），需要做好定时任务逻辑的唯一处理原则，防止多个定时任务重复的处理某个逻辑的行为。\n建议需要使用定时任务的服务，前期只启动一台server服务"}},"/document/high-function/context":{"title":"Context 活动对象","data":{"":"在框架中想要获取 context 活动对象需要一层一层的传递。current 插件提供能在任意位置(不限于 controller、servicer、plugin、function)获取当前的 context 对象。","使用#使用":"安装依赖\n\n\n\n\nyarn add @yunflyjs/yunfly-plugin-current-context\n\n\nconfig.plugin.ts 中声明插件\n\n\n\n\nconst plugins: { [key: string]: string }[] = [\n{\nname: 'currentContext',\npackage: '@yunflyjs/yunfly-plugin-current-context',\npriority: 3\n},\n];\nexport default plugins;\n\n\n开启配置\n\n\n\n\nconfig.currentContext = {\nenable: true // 默认值：false\n};","自定义函数中获取ctx对象#自定义函数中获取ctx对象":"import { getCurrentContext } from '@yunflyjs/yunfly-plugin-current-context'\n// 获得koa 的 ctx对象\nconst ctx = getCurrentContext();","在-service-中获取ctx对象#在 Service 中获取ctx对象":"// service\nimport { getCurrentContext } from '@yunflyjs/yunfly-plugin-current-context'\nimport { Context } from '@yunflyjs/yunfly'\nimport { Service } from \"typedi\";\n\n@Service()\nexport default class ExampleService {\n\nasync getContextInService(): Promise<Object> {\n// 在service代码中获取当前的context对象\nconst ctx: Context = getCurrentContext();\nconst res = {\nconfig: ctx.config,\n}\n}\n}"}},"/document/high-function/err-class-use":{"title":"错误类使用","data":{"":"","基础使用方式#基础使用方式":"import { BadRequestError } from '@yunflyjs/yunfly'\n\n@Get(\"/file\")\nasync getFileContent(\n@Param(\"filename\", { required: true }) filename string,\n@Param(\"branch\") branch: string\n) {\nif (branch && !['master', 'release', 'test'].includes(branch)) {\nthrow new BadRequestError(\"branch 必须为 master、release或test 分支\")\n}\nconst file = await this.gitlabRepository.getFile(filename, branch);\nreturn file;\n}\n当用户请求参数有问题时，首先会在阿里云记录日志，在 config.error 配置中 errCode 为 true 时会返回：\n{\n\"code\": 400,\n\"msg\": \"branch 必须为 master、release或test 分支\"\n}","内置-error-类说明#内置 Error 类说明":"","yunkeerror-类#YunkeError 类":"yunfly 内置了一些错误类，便于大家更好地快速定位问题以及统一错误信息。所有的内置 Error 类都是继承于 YunkeError ，我们首先了解一下 YunkeError 类包含的内容：\nYunkeError\n\n\ninterface YunkeError {\n// 错误名\nname: string\n// HTTP 状态码\nhttpCode?: number\n// 自定义错误码\ncode?: number | string\n// 错误信息\nmessage?: string\n// 错误详情\n// 因为有些信息不能返回给用户，但是需要记录到阿里云，故通过此属性保留\nmessageDetail?: any\n// 错误堆栈信息\nstack?: string;\n}\n\nname\n\n会自动读取当前 Error 类的类名，不需要配置，自动会有。\ncode\n\ncode 的命名有三种规则：\n规则 1：http 错误类http 错误类 code 参考业界标准，例如 400、401、403、500、503 等。\n规则 2：yunfly 框架及周边生态从 10000 开头，每个应用占 100 个间隔，例如 redis 错误为 10100 - 10199，默认值是 10100\n规则 3：rpc 调用错误rpc 调用错误根据 golang 语言返回的结果确定，如果没有，则默认为 -1。\n​\n规则 4：用户自定义错误严格上，用户自定义错误只要不和上述规则冲突即可，推荐从 40000 开始。\n​\nhttpCode\n\n对于内置错误类而言，http 状态码规则如下：\nHTTP 错误类，HTTP 状态码和 code 码是相同的，例如 401，http 状态码和错误码都为 401\n对于 rpc 调用错误，统一 500\nyunfly 框架及周边生态错误错误，导致服务器报错的，就是 500，其他视情况而定\n用户自定义错误类，就由用户自己确定\nmessage\n\n错误信息，可自定义。\nmessageDetail\n\n错误详情，例如在 rpc 调用时出现错误时，会返回很多的错误信息，这个信息实际是不需要给用户看的，我们可以通过赋值给 messageDetail 属性来达到最终记录到阿里云日志的效果（框架会读这个字段）。\nstack\n\n错误堆栈信息\n​","http-error#HTTP Error":"继承于 YunkeError 的错误类，用来表示 HTTP 请求相关错误。\n错误类\t含义\tHTTP 状态码\tcode 码\tBadRequestError\t参数错误\t400\t400\tUnauthorizedError\t用户未登录\t401\t401\tForbiddenError\t用户无权限\t403\t403\tNotFoundError\t找不到相关资源\t404\t404\tMethodNotAllowedError\t方法不允许\t405\t405\tTooManyRequestsError\t过多请求\t429\t429\tInternalServerError\t代码不严谨导致的服务器错误\t500\t500\tBadGatewayError\t网关错误\t502\t502\tServiceUnavailableError\t服务不可用\t503\t503\tGatewayTimeoutError\t网关超时\t504\t504","rpc-error#Rpc Error":"继承于 YunkeError 的错误类，用来表示 RPC 请求相关错误。\n错误类\t含义\tHTTP 状态码\tcode 码\tRpcError\tRPC 错误\t500\tcode 由 go 返回的决定，默认值是 -1","yunfly-框架及周边生态-error#yunfly 框架及周边生态 Error":"继承于 YunkeError 的错误类，用来表示 yunfly 框架以及周边生态（如：redis、apollo等）错误\n错误类\t含义\tHTTP 状态码\tcode 码范围\tYunflyError\tyunfly 框架自身异常\t500\t10000 ~ 1099\tApolloError\tApollo 错误\t500\t10100 ~ 10199\tRedisError\tRedis 错误\t500\t10200 ~ 10299\tEctdError\tECTD 错误\t500\t10300 ~ 10399\tMysqlError\tMysql 错误\t500\t10400 ~ 10499\tMongoDBError\tMongoDB 错误\t500\t10500 ~ 10599\tGrpcError\tGrpc 错误\t500\t10600 ~ 10699","错误类抛出方式#错误类抛出方式":"错误类可以有四种抛出方式，分别为：\n1、全部使用默认值\n\n\nthrow new BadRequestError()\n\n2、更改 message 信息\n\n\nthrow new BadRequestError('用户名不为空') // 仅修改 message\n\n3、更改更多的信息\n\n\n与已有参数是 merge 关系\n\nthrow new BadRequestError({ message: '用户名不为空', code: 400001 }) // 同时修改 message 和 httpCode\n\n4、传递已有的错误\n\n\nimport { RpcError } from '@yunflyjs/errors'\nconst { error, response } = await userServiceV2.getUser({\nrequest,\nmetadata,\n})\n\nif (error) {\nthrow new RpcError(error) // 抛出已有的 Error 类\n}\n\n5、针对 RpcError 和 InternalServerError\n\n因为 RpcError 和 InternalServerError 是基于已有的 Error 类进行抛错的，而已有的 Error 类的 message 属性实际是不需要展示给用户的。例如下图错误，我们只需要记录日志即可。所以针对这两个类做了特殊处理，将他们的第一个参数的 message 属性当做 messageDetail，并且提供了第二个参数作为 message，如果没传，则默认为 “服务器异常，请重试”，具体使用方式如下：\n\ntry {\n// ...\n} catch (error) {\nthrow new InternalServerError(error) // 无第二个参数情况下，message 为 “服务器异常，请重试”\nthrow new InternalServerError(error, '出错了~') // 传了参数，则为传递的参数 “出错了~”\n}\n\n// 道理同上\nthrow new RpcError(error)\nthrow new RpcError(error, '出错了~')","error-类扩展#Error 类扩展":"内置类肯定是没办法满足所有需求的，我们还需要定义一些自己的业务类，具体步骤如下：\nimport { YunkeError, YunkeErrorOptions } from '@yunflyjs/errors'\n\n// 继承 YunkeError\nclass CustomError extends YunkeError {\n// 其他几个信息也可以自定义\nconstructor(options?: YunkeErrorOptions) {\nsuper(options)\nthis.code = this.code ?? 40001\nthis.message = this.message ?? '自定义错误信息'\n}\n}"}},"/document/high-function/framework-dev":{"title":"框架开发","data":{"":"yunfly 提供了一套强大的插机制, 支持内置一系列的插件组合成一个新的框架。\n下面举一个简单的例子， 在 @yunflyjs/yunfly 基础之上搭配一个 @yunflyjs/yunfly-plugin-redis 插件组合成一个新的框架。\n\n底层技术\n\n@yunflyjs/yunfly 作为底层基础库\n@yunflyjs/yunfly-plugin-redis 作为框架内置插件","开发步骤#开发步骤":"","1-创建框架文件夹#1. 创建框架文件夹":"mkdir yunfly-framework-example\n\ncd yunfly-framework-example","2-安装依赖#2. 安装依赖":"安装 dependencies 依赖\n\n\nyarn add @yunflyjs/yunfly @yunflyjs/yunfly-plugin-redis\n\n安装 devDependencies 依赖\n\n\nyarn add typescript@4 gts@0 --dev","3-配置-packagejson#3. 配置 package.json":"识别为Yunfly框架最核心的字段为 \"framework\": \"yunfly\"。\n\n{\n// 配置 name 字段\n\"name\": \"@yunflyjs/yunfly-framework-example\",\n// 配置版本\n\"version\": \"1.0.0\",\n// 入口文件\n\"main\": \"build/index.js\",\n// typings 类文件\n\"typings\": \"build/index.d.ts\",\n// 【核心字段】标识当前库为 yunfly 框架\n\"framework\": \"yunfly\",\n// node 版本\n\"engines\": {\n\"node\": \">=12.17.0\"\n},\n// 允许上次 npm 包的文件\n\"files\": [\n\"bin\",\n\"build\"\n],\n// 配置 scripts 脚本命令\n\"scripts\": {\n\"build\": \"npm run clean && npm run compile\",\n\"dev\": \"tsc --watch\",\n\"clean\": \"gts clean\",\n\"compile\": \"tsc -p .\",\n\"prepublishOnly\": \"npm run build\"\n}\n}\n\n此刻完整的 package.json 为\n\n\n{\n\"name\": \"@yunflyjs/yunfly-framework-example\",\n\"version\": \"1.0.0\",\n\"main\": \"build/index.js\",\n\"typings\": \"build/index.d.ts\",\n\"framework\": \"yunfly\",\n\"engines\": {\n\"node\": \">=12.17.0\"\n},\n\"files\": [\n\"build\"\n],\n\"scripts\": {\n\"build\": \"npm run clean && npm run compile\",\n\"dev\": \"tsc --watch\",\n\"clean\": \"gts clean\",\n\"compile\": \"tsc -p .\",\n\"prepublishOnly\": \"npm run build\"\n},\n\"dependencies\": {\n\"@yunflyjs/yunfly\": \"^1.0.1\"\n},\n\"devDependencies\": {\n\"gts\": \"0\",\n\"typescript\": \"4\"\n}\n}","4-tsconfigjson#4. tsconfig.json":"根目录下创建 tsconfig.json 文件\n\n\n{\n\"compilerOptions\": {\n\"rootDir\": \"./src\",\n\"outDir\": \"./build/\",\n\"module\": \"commonjs\",\n\"target\": \"es6\",\n\"strict\": true,\n\"allowJs\": false,\n\"noUnusedLocals\": true,\n\"removeComments\": true,\n\"declaration\": true,\n\"skipLibCheck\": true,\n\"importHelpers\": true,\n\"esModuleInterop\": true,\n\"resolveJsonModule\": true,\n\"moduleResolution\": \"node\",\n\"experimentalDecorators\": true,\n\"forceConsistentCasingInFileNames\": true,\n\"emitDecoratorMetadata\": true,\n\"noEmitOnError\": true,\n\"noUnusedParameters\": false,\n\"strictPropertyInitialization\": false,\n\"sourceMap\": false,\n\"declarationDir\": \"./build/\"\n},\n\"include\": [\n\"src/**/*.ts\"\n],\n\"exclude\": [\n\"node_modules\",\n\"src/__tests__\"\n]\n}","5-插件核心逻辑#5. 插件核心逻辑":"创建 src/index.ts 文件, 用于框架导出变量\n\n\nimport FlyApp from '@yunflyjs/yunfly'\nimport { cacheRedis, getRedis } from '@yunflyjs/yunfly-plugin-redis';\n\nexport * from '@yunflyjs/yunfly'\nexport {\ncacheRedis,\ngetRedis\n}\nexport default FlyApp;\n\n创建 src/config/config.default.ts 文件\n\n\nimport { Config } from '@yunflyjs/yunfly';\n\nexport default function config(): Config {\nconst config: Config = {};\nconfig.redis = {\nenable: false,\n}\nreturn config;\n}\n\n创建 src/config/config.plugin.ts 文件\n\n\nimport { PluginConfig } from \"@yunflyjs/yunfly\";\n\nconst plugins: PluginConfig[] = [\n{\nname: 'redis',\npackage: '@yunflyjs/yunfly-plugin-redis',\npriority: 50,\n},\n];\n\nexport default plugins;","6-发布-npm-包#6. 发布 npm 包":"发布到自己的私仓或npm。","7-使用#7. 使用":"安装 npm 包\n\n\n\n\nyarn add @yunflyjs/yunfly-framework-example\n\n\n配置脚本命令\n\n\n\n\n{\n\"scripts\": {\n\"dev\": \"cross-env NODE_ENV=dev PORT=3000 yunfly\",\n\"watch:dev\": \"cross-env NODE_ENV=dev PORT=3000 yunfly --watch\"\n}\n}\n\n\n启动应用\n\n\n\n\nyarn watch:dev // open: http://127.0.0.1:3000","总结#总结":"根据以上的案例可以看出，开发框架最核心的步骤包括：\n\npackage.json 中配置 \"framework\": \"yunfly\"字段标识前库包于 yunfly 框架。\n\n\n\nsrc/config/config.plugin.ts 中启用需要的插件集合","框架开发演进图#框架开发演进图":"","yunfly-框架#yunfly 框架":"","定制你自己的框架#定制你自己的框架":"","抽象更上层的框架#抽象更上层的框架":""}},"/document/high-function/link-trace":{"title":"链路追踪","data":{"":"","概念#概念":"一个请求从发起到结束中间经过的所有服务(或流程)都能通过一个标识进行关联起来，这个标识通常为trace-id，所有从 Client -> BFF -> Service 的请求日志都应自动打上 trace-id 的标识。链路追踪的实现没有固定的方式，当前提供了两种方式","使用-currentcontext-实现链路追踪#使用 currentContext 实现链路追踪":"链路追踪 trace-id 依赖 currentContext 能力。需要确保 currentContext 已启用，安装并启用currentContext插件。\n使用, 例如 BFF 发起的 axios 请求中传递 trace-id\n\n\nimport { getCurrentTrace, metadata } from '@yunflyjs/yunfly-plugin-current-context'\n\n// 在 node.js 发起 http 请求\naxios({\nmethod: 'post',\nurl: 'http://xxx.com/api/get-msg',\nheaders: {\n// 链路 trace-id\n'trace-id': getCurrentTrace(),\n// 自定义透传头\n'name': metadata.get('name'),\n},\n})\n.then(function (response) {\n// do something\n});","使用-apm-实现链路追踪#使用 apm 实现链路追踪":"apm 使用的是 elastic-apm-node, apm 对应用的性能损耗较大, 请慎重使用。\n链路追踪核心依赖 apm 服务，需要安装 apm 插件。\n安装依赖\n\n\nyarn add @yunflyjs/yunfly-plugin-apm\n\nconfig.plugin.ts 中声明插件\n\n\nconst plugins: { [key: string]: string }[] = [\n{\nname: 'apm',\npackage: '@yunflyjs/yunfly-plugin-apm',\npriority: 5\n},\n];\nexport default plugins;\n\nconfig.default.ts 配置项 （可选）\n\n\n// body参数配置\nconfig.apm = {\n// 开启 apm 服务\nactive: process.env.NODE_ENV === 'production',\n};"}},"/document/high-function/local-dev":{"title":"本地开发","data":{"":"为了提升开发者体验，框架提供了便捷的方式在本地进行开发、调试、单元测试等。","脚本命令#脚本命令":"开发模式下支持代码热更新命令。\n\npackage.json 文件 scripts 中添加命令：\n{\n\"scripts\" : {\n\"dev\": \"cross-env NODE_ENV=dev yunfly\",\n\"watch:dev\": \"cross-env NODE_ENV=dev yunfly --watch\",\n}\n}","环境配置可选#环境配置【可选】":"开发模式下优先读取 src/config/config.local.ts 配置。配置优先级：local > defalut\n// 可删除此文件、内容也可为空\n// 本地环境时读取，此配置项\nimport { Config } from '@yunflyjs/yunfly';\n\nconst config = () => {\nconst config: Config = {};\n// 案例：开发模式下关闭 cluster\nconfig.cluster = {\nenable: false\n};\nreturn config;\n};\nexport default config;","环境变量#环境变量":"","node_env#NODE_ENV":"Node_ENV 只有 dev, production 两个值，开发环境下使用 dev。","runtime_env#RUNTIME_ENV":"RUNTIME_ENV 环境变量默认为 local","port#PORT":"可以传递 PORT 环境变量来启动相应的端口号。\n\"dev\": \"cross-env NODE_ENV=dev PORT=3000 yunfly\","}},"/document/high-function/multi-progress":{"title":"多进程模型","data":{"":"Node.js 进程只能运行在一个 CPU 上，无法充分利用多核CPU。\nNode.js 官方提供cluster模块，Yunfly 框架内置 cluster 能力。","cluster-是什么#cluster 是什么":"在服务器上同时启动多个进程\n每个进程里都跑的是同一份源代码\n这些进程可以同时监听一个端口","使用#使用":"yunfly 已内置 cluster 插件，只需进行开启即可。\nconfig.cluster = {\nenable: true,\n}\n详细配置说明\n字段\t类型\t必选\t说明\tenable\tboolean\t是\t是否开启集群环境，不开启则保持以前状态\tuseAloneWorker\tboolean\t否\t是否开启 alone 进程（默认：true）\tcount\tnumber\t否\tworker进程数（默认开发环境1个进程，生产环自动获取docker容器的cpu核数）\tenv\tObject\t否\tcluster进程能获取到的环境env变量，（默认 process.env）\ttitle\tstring\t否\tcluster集群组名称 （默认： yunfly-{{package.name}}）\tmode\tnull | test\t否\t运行模型，若值为test时，开发环境可自定义 count 数量","进程分类#进程分类":"yunfly cluster 参考了 egg cluster 模型理念，设计了 3 种分类。如下图：\n\n┌─────────────────────┐      ┌─────────────────────┐\n│          master     │ ---- │        alone        │\n└─────────────────────┘      └─────────────────────┘\n/   /  |   \\    \\\n/    /   |    \\     \\\n/     /    |     \\      \\\n/      /     |      \\       \\\n/        /      |       \\        \\\n/         /       |        \\         \\\n/           /        |         \\           \\\n┌───────┐    ┌───────┐     ┌───────┐  ┌───────┐   ┌───────┐\n│ worker│    │ worker│     │ worker│  │ worker│   │ worker│   ......\n└───────┘    └───────┘     └───────┘  └───────┘   └───────┘","master-进程#Master 进程":"主要负责 worker 进程 alone 进程的启动。","worker-进程#Worker 进程":"Worker 进程负责处理真正的用户请求和定时任务的处理，Worker 运行的是业务代码，相对会比 Alone 和 Master 进程上运行的代码复杂度更高，稳定性也低一点，当 Worker 进程异常退出时，Master 进程会重启一个 Worker 进程。","alone-进程#Alone 进程":"alone 进程是由 child_process fork 出的一个子进程，它比较稳定，只有发生致命错误时才会退出进程。\n当 alone 发生致命错误导致退出后，会重新 fork 一个新的 alone 进程继续执行任务。\nalone 进程比较适合处理一些需要在单进程上运行的任务， 例如定时接口的拉取，定时任务。\n当你不需要 alone 进程时你也可以选择不启动它，config.cluster.useAloneWorker = false 即可。","alone-进程用法#alone 进程用法":"由于 alone 进程比较特殊，这里说明一下 alone 用法。\n在根目录 src 下面创建 alone 文件夹\n在 src/alone 里面新增的文件都会在 alone 进程中执行\n案例： 在alone进程中创建一个定时器任务\n\n\n\nexport default function Alone(config: any) {\nlet i = 0\nsetInterval(() => {\nconsole.log('console alone worker msg:', i++)\n}, 3000)\n}\n\n备注：\n\n\n\nalone 文件夹下可以创建多个文件任务\n文件必须以函数形式进行导出","master-vs-alone-vs-worker#Master VS Alone VS Worker":"开启集群模式时，应用启动会启动这三类进程。\n类型\t进程数量\t作用\t稳定性\t是否运行业务代码\tMaster\t1\t进程管理，进程间消息转发\t非常高\t否\tAlone\t1\t后台运行工作\t高\t少量\tWorker\tn\t执行业务代码\t一般\t是","进程间通信#进程间通信":"worker 进程是 node.js 模块中的 cluster fork 出来的 worker 进程，因此它可以和 app 进程进行通信\nalone 进程是使用 node.js 模块中的 child_process fork出来的worker进程，因此它也可以和 app 进程进行通信\n因为进程间是独立的，worker 进程和 alone 进程也没有父子级关系，因此它们之间不能相互通信。要做到相互通信需要通过 app 进程进行转发，转发规则可看下面代码示例。","worker-进程给-alone-进程发送消息#worker 进程给 alone 进程发送消息":"先安装依赖\n\n\nyarn add sendmessage\n\n代码示例\n\n\n// worker 进程代码 发送消息\nconst sendmessage = require('sendmessage');\n\nsendmessage(process,{\naction: 'worker-to-alone',\nfrom:'worker',\nto: 'alone',\ndata: 'from worker msg to alone process'\n})\n\n// alone 进程代码 接受消息\nprocess.on('message',(msg) => {\nconst {action,from,to,data} = msg || {}\nif(action === 'worker-to-alone' && from === 'worker' && to === 'alone') {\nconsole.log('received msg from worker.msg:',msg)\n}\n})\n\n\n字段\t类型\t说明\taction\tstring\t自定义事件名称（可随意自定义）\tfrom\tstring\t值为 worker， 标识消息来源进程\tto\tstring\t值为 alone， 标识消息接收进程\tdata\tany\t发送的消息","alone-进程给-worker-进程发送消息#alone 进程给 worker 进程发送消息":"先安装依赖\n\n\nyarn add sendmessage\n\n代码示例\n\n\n// alone 进程代码 发送消息\nconst sendmessage = require('sendmessage');\n\nsendmessage(process,{\naction: 'alone-to-worker',\nfrom:'alone',\nto: 'worker',\ntype: 'worker',\ndata: 'from alone msg to worker process'\n})\n\n// worker 进程代码 接受消息\nprocess.on('message',(msg) => {\nconst {action,from,to,data} = msg || {}\nif(action === 'alone-to-worker' && from === 'alone' && to === 'worker') {\nconsole.log('received msg from worker.msg:',msg)\n}\n})\n\n字段\t类型\t说明\taction\tstring\t自定义事件名称（可随意自定义）\tfrom\tstring\t值为 alone， 标识消息来源进程\tto\tstring\t值为 worker，标识接受进程\ttype\tstring\t值为 worker 或 all，worker: 表示消息随机发送给一个worker进程， all: 表示消息发送给所有worker进程 （默认： worker）\tdata\tany\t发送的消息","定时任务#定时任务":"在某些特殊场景下，我们只希望某些逻辑只运行在一个进程中（例如定时任务），yunfly 提供了两种方案来解决这种问题。","方案一-使用随机的worker单进程运行任务#方案一： 使用随机的worker单进程运行任务":"框架提供了单worker进程运行任务的能力，只需要在代码中监听 random-select-worker 事件即可：\n// 代码案例\ncluster.worker.on('message', (msg: AnyOptionConfig) => {\nconst { from, to, action } = msg || {}\nif (\nfrom === 'app' &&                   // 确保是app进程发来的消息\nto === 'worker' &&                  // 确保是发给worker进程的\naction === 'random-select-worker'   // 确保是随机选择一个worker执行的事件\n) {\n// 这里的任务会随机运行在一个worker进程中\n// 所以可以在这里执行定时任务\n}\n})","方案二-使用-alone-进程运行任务#方案二： 使用 alone 进程运行任务":"在alone进程中运行的任务只会在一个进程中运行，它的概念本身就能满足我们的需求。\n参考 Alone 进程使用方法\n\n注意事项：\n\n由于进程之间是相互独立的，如果在alone进程执行的任务需要传递给worker进程，则需要做一些进程间通讯的操作。 参考进程间通信","开发环境下的reload策略#开发环境下的reload策略":"1、开发环境下，worker进程数始终为1，不能更改\n2、开发环境下，不启用refork功能 （即：worker异常退出之后不进行fork新的worker）\n3、开发环境reload模式下，只对worker进行进行reload，主进程master 和app进程不进行重启，减少重启耗时\n4、开发模式下，不停的更改文件时，触发机制有默认500毫秒的延迟时间，以防止不停重启（此时间可以调整： 配置 cluster.reloadDelay 即可）","附录#附录":"","cluster-时序图#cluster 时序图":"","cluster启动模型图#cluster启动模型图":"","服务稳定性保证#服务稳定性保证":"","cluster启动成功案例#cluster启动成功案例":"","多进程负债均衡图#多进程负债均衡图":""}},"/document/high-function/param-trans":{"title":"参数透传","data":{"":"","概念#概念":"通常场景下，当我们的应用有发起 RPC 或 HTTP 请求时，请求参数会从 Middleware -> Controller -> Service -> HTTP | RPC 逐层传递。参数透传概念：参数的传递直接忽略某几层的传递，直达最终的 RPC 或者 HTTP层。而不用中间一层一层传递。\n// 从 controller 直达 grpc\nController -> GRPC\n\n// 从 middleware 直达 grpc\nMiddleware -> GRPC","前置条件#前置条件":"参数透传依赖 currentContext 能力。需要确保 currentContext 已启用，安装并启用currentContext插件。","使用#使用":"","透传-api#透传 Api":"透传支持以下 Api\nimport { metadata } from '@yunflyjs/yunfly-plugin-current-context'\n\n// 获取单个字段\nmetadata.get('xxx'); => any[]\n\n// 获取所有 metadata 信息\nmetadata.getMap('xxx'); => {[props:string]: any}\n\n// 设置某个字段的值\nmetadata.set('xxx','xxx'); => void\n\n// 给某个字段push值\nmetadata.add('xxx','xxx'); => void\n\n// 删除metadat字段\nmetadata.remove('xxx','xxx'); => void","参数透传案例#参数透传案例":"","controller-中透传#Controller 中透传":"import { Get } from '@yunflyjs/yunfly'\nimport { metadata } from '@yunflyjs/yunfly-plugin-current-context'\n\n// 案例：Controller中使用\nclass SomeController {\n\nGet('/user')\nasync getUser() {\n// 通过 metadata.add 添加\nmetadata.add('name','zhang');\nconsole.log(metadata.get('name')); // ['zhang']\n\nmetadata.add('name','san');\nconsole.log(metadata.get('name')); // ['zane','san']\n\nmetadata.set('name','lisi');\nconsole.log(metadata.get('name')); // ['lisi']\n\nmetadata.remove('name');\nconsole.log(metadata.get('name')); // undefined\n\nreturn true;\n}\n}","middleware-中透传#Middleware 中透传":"import { KoaMiddlewareInterface, Context } from \"@yunflyjs/yunfly\";\nimport { metadata } from '@yunflyjs/yunfly-plugin-current-context'\n\nexport class MyMiddleware implements KoaMiddlewareInterface {\nasync use(context: Context, next: (err?: any) => Promise<any>): Promise<any> {\n// 从 JWT 中获取 appid 参数\nconst { appid } = context.state.payload || {};\n// 添加 metadata\nmetadata.add('addid',appid);\nawait next()\n}\n}","util-函数中透传#Util 函数中透传":"import { metadata } from '@yunflyjs/yunfly-plugin-current-context'\n\nexport function AddMetadata () {\nconst { appid } = getMetadataFromService();\nmetadata.add('appid',appid);\n}"}},"/document/high-function/plugin-dev":{"title":"插件开发","data":{"":"","插件模型#插件模型":"┌─────────────────────────┐\n│        yunfly           │\n└─────────────────────────┘\n|\n|\n┌─────────────────────────┐\n│         koa app         │\n└─────────────────────────┘\n/   /    /     |      \\    \\    \\\n/     /     /      |       \\     \\       \\\n/      /       /       |        \\      \\        \\\n/        /        /        |         \\        \\         \\\n┌───────┐ ┌────────┐ ┌───────┐ ┌───────┐ ┌────────┐ ┌────────┐ ┌─────────┐ ┌──────────┐\n│ jwt   │ │response│ │ logger│ │ error │ │ session│ │ redis  │ │security │ │prometheus│ ......\n└───────┘ └────────┘ └───────┘ └───────┘ └────────┘ └────────┘ └─────────┘ └──────────┘","目录结构#目录结构":". yunfly-plugin-xxx\n├── package.json\n├── src\n│   ├── app.ts (可选)\n│   ├── config\n│   |   ├── config.default.ts\n│   |   ├── config.local.ts (可选)\n│   |   ├── config.test.ts (可选)\n│   |   ├── config.release.ts (可选)\n│   |   ├── config.prod.ts (可选)\n│   |   ├── config.middleware.ts (可选)\n│   ├── middleware (可选)\n│   |   └── SomeMiddleware.js\n│   ├── controller (可选)\n│   |   ├── SomeController.ts\n│   ├── service (可选)\n│   |   ├── SomeService.ts\n│   ├── schedule (可选)\n│   |   ├── task1.ts\n│   |   ├── task2.ts\n│   ├── __tests__  (可选)\n│   |   ├── test.xxx1.ts\n│   |   └── test.xxx2.ts\n│   |   └── 其他文件\n├── README.md\n├── tsconfig.json\n├── .gitignore\n├── .gitlab-ci.yml\n├── .eslintrc.js\n├── jest.config.js\n├── grpc-code-gen.config.js\n└── grpc-service.dev.config.js\n\n插件目录说明\n插件入口文件为 app.ts\n插件 config 同样支持多环境，config配置优先级：应用 config > yunfly config > plugin config\n插件支持 controller, 插件 controller 默认会自动增加相应插件名的路由前缀\n插件支持定时任务","命名规范#命名规范":"插件命名规范\n\n\nnpm 包名以 yunfly-plugin 开头，且为全小写，例如：yunfly-plugin-xx。比较长的词组用中划线：yunfly-plugin-hello-world\n对应的 npm 包名使用 @yunflyjs/yunfly-plugin-xxx 为准\n\n\npackage.json 书写规范\n\n\n遵循 yunfly 模板库规范\n在 keywords 里加上 yunfly、yunfly-plugin 等关键字，便于索引","使用插件配置#使用插件配置":"我们看下面示例来说明 plugin 配置\n/**\n* yunfly 插件\n* 不配置 lifeHook 的情况下，数组顺序就是插件的加载顺序\n*/\nimport * as path from 'path'\n//\nconst plugins: {[key:string]: string}[] = [\n/**\n* 使用 path 模式，插件在项目目录\n* async 为 true，表示 同步加载插件，加载完才会加载下一个插件\n* lifeHook 为 beforeStart，表示在 beforeStart 生命周期下进行加载\n*/\n{\nname: 'hello',\npath: path.join(__dirname, '../plugin/yunfly-plugin-hello'),\nasync: true,\nlifeHook: 'beforeStart',\n},\n/**\n* 使用npm包模式\n*/\n{\nname: 'redis',\npackage: '@yunflyjs/yunfly-plugin-redis',\n}\n];\n//\nexport default plugins;\n\n字段\t类型\t必选\t说明\tname\tstring\t是\t当前插件配置的唯一标识 name, 跟 config.default.ts 中字段保持一致, name 字段很有用，它用来标识是否有重复插件和插件覆盖的能力\tpackage\tstring\t否\tnpm包 插件名，例如: @yunflyjs/yunfly-plugin-redis。 (备注：package 与 path 必须有一个字段为真)\tpath\tstring\t否\t本地开发 插件目录地址 (备注：package 与path 必须有一个字段为真)\tasync\tboolean\t否\t若为 true，表示同步加载插件，加载完才会加载下一个插件；否则为异步加载，不阻塞其他插件加载。\tlifeHook\tstring\t否\t可选值：beforeStart、configDidReady、appDidReady、afterStart，表示在哪个生命周期进行加载。默认在 appDidReady 周期下加载插件。框架生命周期介绍\tpriority\tnumber\t否\t默认值为：50, 值越小越先执行插件","执行顺序#执行顺序":"我们看下面的示例进行说明：\n\nimport * as path from 'path'\n\nconst plugins: {[key:string]: string}[] = [\n{\nname: 'a',\npackage: '@yunflyjs/yunfly-plugin-a',\n},\n{\nname: 'b',\npackage: '@yunflyjs/yunfly-plugin-b',\n},\n{\nname: 'c',\npackage: '@yunflyjs/yunfly-plugin-c',\npriority: 10\n},\n/**\n* 使用npm包模式\n*/\n{\nname: 'd',\npackage: '@yunflyjs/yunfly-plugin-d',\nlifeHook: 'beforeStart',\n}\n];","默认情况按数组顺序执行#默认情况按数组顺序执行":"上面案例中 a,b 插件执行顺序为 a > b","按生命周期分组执行#按生命周期分组执行":"如果插件有 lifeHook 生命周期配置，则插件会根据生命周期分类，并按数组顺序执行。默认情况下，在插件没有配置 lifeHook 时，插件会在 appDidReady 生命周期钩子进行加载，按数组顺序执行。但是案例的 d 配置了 lifeHook: 'beforeStart'，beforeStart 生命周期钩子早于 appDidReady 生命周期钩子（生命周期说明可看)上面案例中 a,b,d 执行顺序为 d > a > b","插件执行顺序权重#插件执行顺序权重":"插件第一优先级通过生命周期分组，组内根据权重值进行排序，权重值越小越先执行插件，若无权重值，则默认数组执行顺序。上面案例中 插件 c 设置了权重,由于插件默认权重值为50，因此最终案例插件执行顺序为： d > c > a > b","开发同步插件#开发同步插件":"当后续的业务依赖插件执行完成时，就需要插件同步化，开发一个同步插件需要在 app.ts 中导出一个同步函数即可：\n例如：\n\n\nimport { ApolloConfig, Config, KoaApp } from \"@yunflyjs/yunfly\";\n//\nexport default async function AsyncPlugin(\n{ koaApp, pluginConfig, config }: {koaApp:KoaApp; pluginConfig:PluginConfig; config:Config}\n) {\n// 返回一个 promise 即同步插件\nreturn await getMsgFromApi();\n}","插件分类#插件分类":"插件大致可分为以下4中类型：","1-常规插件#1. 常规插件":"可以在应用初始化时执行一些操作，例如注入环境变量，拉取接口等事情, 常规插件参考案例","2-定时任务插件#2. 定时任务插件":"顾名思义即在插件中执行定时任务，定时任务插件参考案例","3-中间件插件#3. 中间件插件":"以插件的方式向应用总注入中间件，中间件插件参考案例","4-路由插件#4. 路由插件":"插件中暴露路由，安装插件即可直接使用，路由插件中可以有 controller, service, middleware, schedule 等, 可以认为路由插件就是一个小型的应用，可以独立运行。 路由插件参考案例","路由插件如何访问#路由插件如何访问":"插件支持controller的加载, 你可以通过npm包的方式来开发通用的api。","解决插件路由冲突#解决插件路由冲突":"案例： 现有一个 @yunflyjs/yunfly-plugin-controller-example 插件：\n\nExampleController.ts 核心代码如下:\nimport { HeaderParam, QueryParam, Get, JsonController } from \"routing-controllers\"\n@JsonController('/example')\nexport default class TestController {\n@Inject() private exampleService: ExampleService\n@Get('/hello')\nasync example(): Promise<string> {\nreturn 'hello world.'\n}\n}\nconfig/config.default.ts 配置:\nconfig.controllerExample = {\n//\n}\n\n\n使用默认配置，插件内部默认会以插件名称作为插件路由的前缀\n\n\n\n\n// 因此默认对外暴露的路由为\n/yunfly-plugin-example/example/hello\n\n\n使用自定义路由，config插件配置中声明 routePrefix 配置\n\n\n\n\n// 空\nconfig.controllerExample = {\nroutePrefix: '',\n}\n// 此配置对外暴露的路由为\n/example/hello\n\n// /plugin前缀\nconfig.controllerExample = {\nroutePrefix: '/plugin',\n}\n// 此配置对外暴露的路由为\n/plugin/example/hello","渐进式开发#渐进式开发":"由配置可以知道，在Yunfly插件里, 有 path 和 package 两种加载模式，那我们该如何选择呢？\n下面以实际案例，一步步进行演示，如何渐进式地进行代码演进。","最初始的状态#最初始的状态":"假设我们现在需要实现一个发送邮件的功能，实现如下能力：\n\n\n// 邮件的配置从config中获取\nconst message = {\nfrom: \"sender@server.com\",\nto: \"receiver@sender.com\",\nsubject: \"Message title\",\ntext: \"Plaintext version of the message\",\nhtml: \"<p>HTML version of the message</p>\"\n};\nctx.email.sendMail(message);\n\nYunfly现有能力，我们可以选择开发一个 koa 中间件或者写一个 npm 包：\n\n增加配置config.email\n\n\n\n\nconfig.email = {\nhost: 'xxxxxx',\nport: 587,\nsecure: false,\nuser: 'xxx',\npass: 'xxx',\n}\n\n\n核心代码 config.middleware.ts实现\n\n\n\n\nimport { KoaApp, Config } from '@yunflyjs/yunfly'\nimport { Context } from \"koa\"\nconst nodemailer = require(\"nodemailer\");\n//\nexport default function KoaMiddleware(app: KoaApp, config: Config) {\n// 把邮件能力抽离为一个koa中间件\nconst transporter = nodemailer.createTransport({\nhost: config.email.host,\nport: config.email.port,\nsecure: config.email.secure, // true for 465, false for other ports\nauth: {\nuser: config.email.user, // generated ethereal user\npass: config.email.pass, // generated ethereal password\n},\n});\n\n// 挂载到context对象下\napp.context.email = transporter;\n}","插件的雏形#插件的雏形":"我们很明显能感知到，这段逻辑是具备通用性的，可以写成插件。\n但一开始的时候，功能还没完善，直接独立插件，维护起来比较麻烦。\n此时，我们可以把代码写成插件的形式，但并不独立出去。","新的实现#新的实现":"应用/src/plugin 文件夹下新增 yunfly-plugin-email 插件文件夹，Node应用目录结构如下：\n\n\n\n\n. bff-example\n├── node_modules\n├── src\n│   ├── alone\n│   ├── config\n│   ├── controller\n│   ├── service\n│   ├── utils\n│   └── plugin\n│   │   └── yunfly-plugin-email\n│   │       ├── src\n│   │       │   ├── config\n│   │       │   │   └── config.default.ts\n│   │       │   └── app.ts\n│   │       ├── .gitlab-ci.yml\n│   │       ├── tsconfig.json\n│   │       ├── README.md\n│   │       └── package.json\n│   └── app.ts\n├── README.md\n├── tsconfig.json\n├── .gitignore\n├── .gitlab-ci.yml\n├── .eslintrc.js\n├── jest.config.js\n├── package.json\n\n核心代码实现：\n应用/src/plugin/yunfly-plugin-email/src/app.ts 代码实现\n\n\nimport { ApolloConfig, Config, KoaApp } from \"@yunflyjs/yunfly\";\n//\nexport default function EmailPlugin(\n{ koaApp, pluginConfig, config }: {koaApp:KoaApp; pluginConfig:PluginConfig; config:Config}\n) {\nconst {host,port,secure,user,pass} = pluginConfig;\nconst transporter = nodemailer.createTransport({\nhost,\nport,\nsecure,\nauth: {\nuser,\npass,\n},\n});\n// 挂载到context对象下\napp.context.email = transporter;\n}\n\n\n应用/src/config/config.default.ts 下增加config.email配置项\n\n\n\n\nconfig.email = {\nhost: 'xxxxxx',\nport: 587,\nsecure: false,\nuser: 'xxx',\npass: 'xxx',\n}\n\n\n应用/src/config/config.plugin.ts中通过path来挂载插件。\n\n\n\n\nimport * as path from 'path'\nconst plugins: {[key:string]: string}[] = [\n{\nname: 'eamil',\npath: path.join(__dirname, '../plugin/yunfly-plugin-email'),\n}\n];\nexport default plugins;\n\n\n应用/package.json中配置插件地址（此处是为了把插件中的npm包安装在全局的node_modules中）\n\n\n\n\n\"dependencies\": {\n\"@yunflyjs/yunfly\": \"*\",\n\"@yunflyjs/yunfly-plugin-email\": \"./src/plugin/yunfly-plugin-email\"\n},","抽成独立插件#抽成独立插件":"经过一段时间开发后，该模块的功能成熟，此时可以考虑抽出来成为独立的插件。\n\n直接将 应用/src/plugin/yunfly-plugin-email 独立出来 发布一个  @yunflyjs/yunfly-plugin-email的npm包.\n\n\n\n安装插件\n\n\n\n\nyarn add @yunflyjs/yunfly-plugin-email\n\n\n移除plugin/yunfly-plugin-email 目录\n\n\n\n移除plugin/yunfly-plugin-email 的 package.json的本地依赖\n\n\n\nconfig/config.plugin.ts中修改依赖声明为package方式\n\n\n\n\nplugins.push({\nname: 'eamil',\npath: '@yunflyjs/yunfly-plugin-email',\n})","渐进式开发总结#渐进式开发总结":"综上所述，大家可以看到我们是如何一步步渐进地去进行框架演进.\n一般来说，当多个应用中有可能会复用到的代码时，直接放到 plugin 目录去。\n当该插件功能稳定后，即可独立出来作为一个 node module。\n如此以往，应用中相对复用性较强的代码都会逐渐独立为单独的插件。\n当你的应用逐渐进化到针对某类业务场景的解决方案时，将其抽象为独立的 framework 进行发布。\n当在新项目中抽象出的插件，下沉集成到框架后，其他项目只需要简单的重新 yarn install 下就可以使用上，对整个团队的效率有极大的提升。","插件覆盖#插件覆盖":"yunfly 设计的插件模式中,插件之间是可以覆盖的\n因此你可以开发一个适合于自己的插件来覆盖 yunfly 内置的插件\n你也可以自己开发一个插件来覆盖其他需要被覆盖的插件","插件覆盖规则#插件覆盖规则":"当框架检测到插件名（即: plugin.name）相同时, 会启用插件覆盖能力, 相同插件名情况下, 后加载的插件会覆盖前加载的插件。\n\n\n备注: 插件覆盖只检测 plugin.name 字段, 因此 path 和 package 模式都支持\n\n例如：你想覆盖 yunfly 中内置的 log 插件","package-包模式#package 包模式":"开发自定义的 log 插件\n\n\n\n\n// npm 包\n@yunflyjs/yunfly-plugin-my-logger\n\n\nconfig.plugin.ts中声明自定义的 log 插件\n\n\n\n\n/**\n* yunfly 插件\n* 数组顺序就是插件的加载顺序\n*/\nconst plugins: {[key:string]: string}[] = [\n/**\n* 使用自定义的log插件覆盖yunfly log插件\n* 使用npm包模式\n*/\n{\nname: 'log',\npackage: '@yunflyjs/yunfly-plugin-my-logger'\n}\n];\nexport default plugins;","path-模式#path 模式":"src/plugin/yunfly-plugin-my-logger 下开发自定义的 log 插件逻辑\nconfig.plugin.ts 中声明自定义的 log 插件\n\n\nimport * as path from 'path'\n/**\n* yunfly 插件\n* 数组顺序就是插件的加载顺序\n*/\nconst plugins: {[key:string]: string}[] = [\n/**\n* 使用自定义的log插件覆盖yunfly log插件\n* 使用npm包模式\n*/\n{\nname: 'log',\npath: path.join(__dirname, '../plugin/yunfly-plugin-my-logger'),\n},\n];\nexport default plugins;\n\n其他插件同理","插件即node服务#插件即Node服务":"当yunfly插件类型为Yunfly Controller Plugin类型时, 插件支持路由、rpc, 同时插件本身便可以是一个Node服务。\n插件目录结构\n\n\n. yunfly-plugin-controller-example\n├── package.json\n├── src\n│   ├── app.ts\n│   ├── config\n│   |   ├── config.default.ts\n│   ├── middleware\n│   |   └── SomeMiddleware.js\n│   ├── controller\n│   |   ├── SomeController.ts\n│   ├── service\n│   |   ├── SomeService.ts\n│   └── __tests__\n│       ├── test.xxx1.ts\n│       └── test.xxx2.ts\n├── README.md\n├── tsconfig.json\n├── .gitignore\n├── .gitlab-ci.yml\n├── .eslintrc.js\n├── jest.config.js\n├── grpc-code-gen.config.js\n└── grpc-service.dev.config.js\n\n插件安装@yunflyjs/yunfly为devDependencies依赖","最佳实践#最佳实践":"下面我们通过对几种常见类型的插件进行举例。","常规插件#常规插件":"常规插件可以是执行某一段逻辑的代码, 可以是 koa 中间件, 也可以是注册一个全局服务。\n常规插件的核心入口为 app.ts，下面跟着我步骤来创建一个常规插件, 以 @yunflyjs/yunfly-plugin-probe 插件为例。\n\n插件目录结构\n\n\n. yunfly-plugin-probe\n├── src\n|   ├── app.ts\n│   ├── config\n│   |   ├── config.default.ts\n├── README.md\n├── tsconfig.json\n├── .gitignore\n├── .gitlab-ci.yml\n├── .eslintrc.js\n├── jest.config.js\n├── package.json\n\n\napp.ts 代码实现\n\n\nimport Koa from 'koa';\ninterface ProbeOption {\nkoaApp: Koa<Koa.DefaultState, Koa.DefaultContext>;\npluginConfig: {enable: boolean;}\n}\nexport default function YunflyProbePlugin({ koaApp, pluginConfig }: ProbeOption): void {\nif(!pluginConfig.enable) {\nreturn;\n}\nkoaApp.use(async(ctx: Koa.Context, next: any) => {\nif (ctx.req.url === '/debug/vars') {\nctx.set('Content-Type', 'application/json; charset=utf-8');\nctx.status = 200;\nctx.body = { code: 200, data: 'success' };\nreturn;\n}\nawait next();\n});\n}\n\n\nconfig.default.ts 代码实现\n\n\nimport { Config } from '@yunflyjs/yunfly';\nexport default function config(): Config {\nconst config: Config = {};\n// body参数配置\nconfig.probe = {\nenable: true\n};\nreturn config;\n}\n\n\npackage.json 核心配置。\n\n\n{\n\"name\": \"@yunflyjs/yunfly-plugin-probe\",\n\"version\": \"1.0.0\",\n\"main\": \"./dist/app.js\",\n\"typings\": \"dist/app.d.ts\",\n\"scripts\": {\n\"build\": \"gts clean && tsc\"\n},\n\"files\": [\n\"dist\"\n],\n\"devDependencies\": {\n\"@yunflyjs/yunfly\": \"^3.1.20\"\n}\n}\n\n\n插件使用请参考： 配置","定时任务插件#定时任务插件":"我们可以发布一个定时任务的 plugin, 定时任务插件需要创建一个固定的 schedule 文件夹，schedule 中的每一个文件即是一个定时任务。下面以 @yunflyjs/yunfly-plugin-schedule-example 插件为例。\n\n插件目录结构\n\n\n. yunfly-plugin-schedule-example\n├── src\n|   ├── app.ts\n│   ├── config\n│   |   ├── config.default.ts\n│   ├── schedule\n│   |   ├── task1.ts\n│   |   ├── task2.ts\n├── README.md\n├── tsconfig.json\n├── .gitignore\n├── .gitlab-ci.yml\n├── .eslintrc.js\n├── jest.config.js\n├── package.json\n\n\napp.ts 代码实现\n\n\n定时任务不依赖于 app.ts 入口，因此我们默认为一个空函数即可\n\n\nexport default function YunflyPlugin(): void {\n// do nothing\n}\n\n\ntask 代码实现\n\n\nimport { Config, FlyApp } from '@yunflyjs/yunfly';\nexport default function schedule() {\nreturn {\nschedule: {\ncron: '*/5 * * * * *',\nenable: true,\ntype: 'worker', // 可选值 worker: 随机选择一个worker执行， all: 所有worker都执行, 默认为worker\n},\ntask: (config: Config, app?: FlyApp) => {\nconsole.log(`yunfly example schedule plugin task: ${ new Date()} (5s一次)`);\n},\n};\n}\n\n\npackage.json 核心配置。\n\n\n{\n\"name\": \"@yunflyjs/yunfly-plugin-schedule-example\",\n\"version\": \"1.0.0\",\n\"main\": \"./dist/app.js\",\n\"typings\": \"dist/app.d.ts\",\n\"scripts\": {\n\"build\": \"gts clean && tsc\"\n},\n\"files\": [\n\"dist\"\n]\n}\n\n\n插件使用请参考： 配置","中间件插件#中间件插件":"插件可以是一个 middleware (一般建议，一个插件推荐只做一件事情)。下面以 @yunflyjs/yunfly-plugin-logger 插件为例。\n\n插件目录结构\n\n\n. yunfly-plugin-schedule-example\n├── src\n|   ├── app.ts\n│   ├── config\n│   |   ├── config.default.ts\n│   ├── middleware\n│   |   ├── LoggerMiddleware.ts\n├── README.md\n├── tsconfig.json\n├── .gitignore\n├── .gitlab-ci.yml\n├── .eslintrc.js\n├── jest.config.js\n├── package.json\n\n\napp.ts 代码实现\n\n\n定时任务不依赖于 app.ts 入口，因此我们默认为一个空函数即可\n\n\nexport default function YunflyPlugin(): void {\n// do nothing\n}\n\n\nLoggerMiddleware.ts 插件实现\n\n\nimport { Context } from 'koa';\nimport { KoaMiddlewareInterface, Middleware } from 'routing-controllers';\n@Middleware({ type: 'before' })\nexport default class LoggerMiddleware implements KoaMiddlewareInterface {\nasync use(context:Context, next:(err?:any) => Promise<any>):Promise<any> {\nconsole.info('yunfly-plugin-logger begin...');\nawait next();\nconsole.info('yunfly-plugin-logger end...');\n}\n}\n\n\npackage.json 核心配置。\n\n\n{\n\"name\": \"@yunflyjs/yunfly-plugin-logger\",\n\"version\": \"1.0.0\",\n\"main\": \"./dist/app.js\",\n\"typings\": \"dist/app.d.ts\",\n\"scripts\": {\n\"build\": \"gts clean && tsc\"\n},\n\"files\": [\n\"dist\"\n],\n\"devDependencies\": {\n\"routing-controllers\": \"^0.7.7\"\n}\n}\n\n\n插件使用请参考： 配置","路由插件#路由插件":"顾名思义，路由插件主要用于拓展路由。下面以 @yunflyjs/yunfly-plugin-controller-example 插件为例。\n\n插件目录结构\n\n\n. yunfly-plugin-controller-example\n├── package.json\n├── src\n│   ├── app.ts\n│   ├── config\n│   |   ├── config.default.ts\n│   ├── middleware\n│   |   └── SomeMiddleware.js\n│   ├── controller\n│   |   ├── SomeController.ts\n│   ├── service\n│   |   ├── SomeService.ts\n│   └── __tests__\n│       ├── test.xxx1.ts\n│       └── test.xxx2.ts\n├── README.md\n├── tsconfig.json\n├── .gitignore\n├── .gitlab-ci.yml\n├── .eslintrc.js\n└── jest.config.js\n\n\napp.ts 代码实现\n\n\n定时任务不依赖于 app.ts 入口，因此我们默认为一个空函数即可\nexport default function YunflyPlugin(): void {\n// do nothing\n}\n\n\n\n3.1. UserController 代码实现\nimport { Get, Inject, JsonController, QueryParam } from '@yunflyjs/yunfly';\nimport * as types from '../grpc-code-gen/yued/grpc-server-example/types';\nimport UserService from '../service/UserService';\n//\n@JsonController('/user')\nexport default class UserController {\n@Inject() private userService: UserService\n//\n@Get('/gen-user-info')\nasync genToken(\n@QueryParam('user_id') user_id: number,\n): Promise<types.user.GetUserInfoResponse> {\nreturn await this.userService.getUserInfo({ user_id });\n}\n}\n\n3.2. UserService.ts 代码实现\nimport { Service } from 'typedi';\nimport { userServiceV2 } from '../../grpc-code-gen/yued/grpc-server-example/user/UserService';\nimport * as types from '../../grpc-code-gen/yued/grpc-server-example/types';\n//\n@Service()\nexport default class UserService {\n//\nasync getUserInfo(request: types.user.GetUserInfoRequest, metadata?: any ): Promise<types.user.GetUserInfoResponse> {\nconst { error, response }: any = await userServiceV2.GetUserInfoV2({\nrequest, metadata,\n});\nif (error) {\nthrow error;\n}\nreturn response;\n}\n}\n\n\nconfig.default.ts 代码实现\n\n\n\n\nimport { Config } from '@yunflyjs/yunfly';\n//\nexport default function config(apolloConfig: any = {} /* V3.1.14+新增参数 */): Config {\nconst config: Config = {};\n// 插件配置\nconfig.routingControllersExample = {\nroutePrefix: '/yunfly-plugin-controller-example',\n};\nreturn config;\n}\n\n\npackage.json 核心配置。\n\n\n\n\n{\n\"name\": \"@yunflyjs/yunfly-plugin-controller-example\",\n\"version\": \"1.0.0\",\n\"main\": \"./dist/app.js\",\n\"typings\": \"dist/app.d.ts\",\n\"scripts\": {\n\"watch:dev\": \"cross-env NODE_ENV=dev YUNFLY_TYPE=link yunfly --watch\",\n\"grpc-gen\": \"grpc-code-gen gen\",\n\"build\": \"gts clean && tsc\",\n},\n\"files\": [\n\"dist\",\n\".grpc-code-gen\",\n\"grpc-code-gen.config.js\",\n\"grpc-service.dev.config.js\"\n],\n\"devDependencies\": {\n\"@yunflyjs/yunfly\": \"^1.0.0\"\n},\n\"optionalDependencies\": {\n\"grpc\": \"^1.24.6\"\n}\n}\n备注：\n\ncontroller 插件安装 @yunflyjs/yunfly npm包之后，可以是一个完整的Node小型应用","附录#附录":"","插件架构图#插件架构图":"","插件插拔模型#插件插拔模型":"","插件代码插拔模型#插件代码插拔模型":""}},"/document/high-function/unit-test":{"title":"单元测试","data":{"":"单元测试 文档待输出..."}},"/document/introduction/characteristic":{"title":"特性","data":{"":"基于 Koa 开发, 底层框架性能优异。\n基于 Typescript 进行项目开发，更安全，更高效。\n基于 routing-controllers 进行路由的定义，完善的注解API，开发效率更高\n提供基于 Yunfly 强大的插件能力\n高度扩展的框架开发机制\n内置多进程能力\n渐进式开发"}},"/document/introduction/framework-differences":{"title":"与社区框架差异","data":{"":"能力\tyunfly\teggjs\tnestjs\tTypescript\t✅\t❌[支持但不友好]\t✅\tcluster\t✅\t✅\t❌\topenapi\t✅\t❌\t✅\t框架约束\t部分约束\t约束\t自由\t扩展模型\t插件\t插件\t模块"}},"/document/introduction/introduce":{"title":"介绍","data":{"":"Yunfly 一款高性能 Node.js WEB 框架, 使用 Typescript 构建我们的应用。\n使用 Koa2 做为 HTTP 底层框架, 使用 routing-controllers 、 typedi 来高效构建我们的 Node 应用。Yunfly 在 Koa 框架之上提升了一个抽象级别, 但仍然支持 Koa 中间件。在此基础之上, 提供了一套强大的插件系统, 给开发者提供更强大更灵活的能力。","框架技术栈#框架技术栈":"Koa2 node.js http 框架, async await异步编程 参考文档\nfind-my-way 一款高性能的 http 路由器 参考文档\ntypescript 微软开发的自由和开源的编程语言, 它是JavaScript的一个超集, 添加了可选的静态类型和基于类的面向对象编程 参考文档\nrouting-controllers  使用装饰器的方式来进行路由的开发 参考文档\ntypedi: 依赖注入插件工具  参考文档\ngrpc: 一个高性能、开源和通用的 RPC 框架  参考文档\nlog4js: javascript 的 log 日志插件 参考文档"}},"/document/introduction/performance":{"title":"性能","data":{"":"yunfly 框架底层 web 库为 koa, 路由开发模型库为 routing-controllers, 路由命中库为 find-my-way。koa 对于写业务来说性能是足够优异的，routing-controllers 使用装饰器的方式来进行路由的开发，对于开发者来说是很提效的。框架剔除了低效的 koa-router 更换为高效的 find-my-way。框架未内插件，开发者可以根据自己的需求定制插件。","性能压测#性能压测":"以下性能测试为同一台机器同样的容器场景下压测3分钟得出的结果。","容器环境#容器环境":"1G1核 Docker 容器","hello-world-场景#hello world 场景":"web框架\tqps\t备注\tyunfly\t6400\t使用 koa 为底层库\teggjs\t3950\t使用 koa 为底层库\tnestjs\t2900\t使用 express 为底层库\tnestjs\t7200\t使用 fastify 为底层库","1000-个路由场景#1000 个路由场景":"web框架\tqps\t备注\tyunfly\t6100\t使用 koa 为底层库\teggjs\t1680\t使用 koa 为底层库\tnestjs\t2050\t使用 express为底层库\tnestjs\t6550\t使用 fastify为底层库"}},"/document/openapi/jsonschema":{"title":"fast-typescript-to-jsonschema","data":{"":"生成typescript类型的jsonschema数据","特性#特性":"编译Typescript文件以获取完整的类型信息\n将所需的属性、继承、注释、属性初始值转换为jsonschema","使用#使用":"1.安装依赖\nyarn add fast-typescript-to-jsonschema -D\n2.创建type.ts文件，内容如下:\ninterface ITest {\nattr1: string;\nattr2: number;\nattr3?: boolean;\n}\n\n创建test.js文件，内容如下:\n\n3.1 通过文件生成 jsonschema\nconst { default: genTypeSchema } = require('fast-typescript-to-jsonschema');\nconst path = require('path');\n\n// 目标文件\nconst file = path.resolve(__dirname, './type.ts');\n\n// 生成数据\ngenTypeSchema.genJsonDataFormFile(file);\n\n// 获得当前文件对应的所有jsonschema数据\nconst json = genTypeSchema.genJsonData();\n\n// 获得具体的某个type的jsonschema数据\nconst jsonSchema = genTypeSchema.getJsonSchema(file, 'ITest');\n\n// 返回结果\nconsole.log(jsonSchema);\n3.2 通过 code 生成 jsonschema\nconst { default: genTypeSchema } = require('fast-typescript-to-jsonschema');\n\nconst code = `\ninterface ITest {\nattr1: string;\nattr2: number;\nattr3?: boolean;\n}\n`\n// generate data\ngenTypeSchema.genJsonDataFromCode(code);\n\n// get all jsonschema data of current file\nconst json = genTypeSchema.genJsonData();\n\n// get jsonschema of specific type\nconst jsonSchema = genTypeSchema.getJsonSchema('ITest');\n\n// result\nconsole.log(jsonSchema);\n4.执行脚本\nnode ./test.js\njsonSchema返回结果如下:\n{\n\"additionalProperties\": false,\n\"properties\": {\n\"attr1\": {\n\"type\": \"string\",\n},\n\"attr2\": {\n\"type\": \"number\",\n},\n\"attr3\": {\n\"type\": \"boolean\",\n},\n},\n\"required\": [\n\"attr1\",\n\"attr2\",\n],\n\"type\": \"object\",\n}\n\nexample 案例地址：\nhttps://github.com/yunke-yunfly/fast-typescript-to-jsonschema/tree/master/example","注释#注释":"示例1\ninterface Interface_1 {\nattr: string;\n}\n结果:\n{\n\"additionalProperties\": false,\n\"properties\": {\n\"attr\": {\n\"type\": \"string\",\n},\n},\n\"required\": [\n\"attr\",\n],\n\"type\": \"object\",\n}\n示例2\ninterface Interface_4 {\nattr: string[];\n}\n结果:\n{\n\"additionalProperties\": false,\n\"properties\": {\n\"attr\": {\n\"items\": {\n\"type\": \"string\",\n},\n\"type\": \"array\",\n},\n},\n\"required\": [\n\"attr\",\n],\n\"type\": \"object\",\n}\n\n更多支持的类型解析请看,目录如下:\n\n接口\n1.1简单类型\n1.2联合类型\n1.3交叉类型\n1.4数组类型\n1.4.1简单数组类型\n1.4.2复杂数组类型\n\n\n1.5嵌套\n1.5.1简单嵌套\n1.5.2联合嵌套\n1.5.3交叉嵌套\n1.5.4数组交叉\n1.5.5循环嵌套\n\n\n1.6索引类型\n\n\n模块\n1.1简单导出\n1.2导出重命名\n\n\n继承\n1.1简单继承\n1.2多继承\n\n\n枚举\n1.1数字枚举\n1.2字符串枚举\n1.3计算枚举\n1.4复杂枚举\n1.4.1简单接口转枚举\n1.4.2复杂接口转枚举\n\n\n\n\n泛型\n1.1简单\n1.2复杂泛型\n\n\n命名空间\n1.1简单\n1.2复杂\n\n\ntype类型\n1.1基本类型\n1.2复杂\n1.2.1联合类型\n1.2.2联合数组\n1.2.2引用枚举\n\n\n\n\n工具函数\n1.1对象工具\n1.1.1Omit\n1.1.1.1简单\n1.1.1.2联合\n1.1.1.3引入\n\n\n1.1.2Pick\n1.1.2.1简单\n1.1.2.2引入\n\n\n\n\n\n\n注释\n1.1单行注释\n1.2单行注释默认值\n1.3多行注释\n1.4多行注释默认值\n1.5单行多行注释默认值","贡献#贡献":"我们非常欢迎您的贡献，您可以通过以下方式与我们共建。\n提交GitHub 问题以报告错误或提出问题。\n提出拉取请求以改进我们的代码。\n贡献指南。"}},"/document/openapi/openapi":{"title":"routing-controllers-to-openapi","data":{"":"routing-controllers项目构建时生成 openapi v3 schema。\n通过TS文件生成AST语法树，分析AST语法树生成openapiv3数据。进而导入到postman、swagger 等平台进行数据展示。","使用#使用":"","1-安装依赖#1. 安装依赖":"yarn add routing-controllers-to-openapi --dev","2-新增script命令#2. 新增script命令":"\"scripts\": {\n\"gen-openapi\": \"gen-openapi\",\n}","3-生成openapi数据#3. 生成openapi数据":"yarn gen-openapi","案例#案例":"Controller案例代码\n\n\nimport { HeaderParam, JsonController, BodyParam, Post } from 'routing-controllers';\nexport interface Response {\n// code返回码\ncode: number;\n// 返回信息\nmessage: string;\n}\n\n/**\n* 测试案例controller\n*\n* @export\n* @class TestController\n*/\n@JsonController('/example')\nexport default class ExampleController {\n/**\n* do something\n*\n* @param {string} orgcode 租户号\n* @param {string} name 姓名\n* @param {number} age 年龄\n* @returns {Promise<Response>}\n* @memberof ExampleController\n*/\n@Post('/test')\nasync getTest(\n@HeaderParam('orgcode') orgcode: string,\n@BodyParam('name') name: string,\n@BodyParam('age') age: number,\n): Promise<Response> {\nreturn {\ncode: 0,\nmessage: 'success'\n}\n}\n}\n\ngenerate openapi schema\n\n\n{\n\"openapi\": \"3.0.3\",\n\"info\": {\n\"title\": \"routing-coontrollers-to-openapi-test\",\n\"description\": \"Buildtime OpenAPI v3 spec generation for routing-controllers\",\n\"version\": \"1.0.0\"\n},\n\"tags\": [\n{\n\"name\": \"ExampleController\",\n\"description\": \"测试案例controller\"\n}\n],\n\"paths\": {\n\"/example/test\": {\n\"post\": {\n\"tags\": [\n\"ExampleController\"\n],\n\"summary\": \"do something\",\n\"description\": \"ExampleController.getTest 测试案例controller \",\n\"operationId\": \"ExampleController.post.getTest.rhBCjZZSMY\",\n\"responses\": {\n\"200\": {\n\"description\": \"\",\n\"content\": {\n\"application/json\": {\n\"schema\": {\n\"type\": \"object\",\n\"properties\": {\n\"code\": {\n\"type\": \"number\",\n\"description\": \"接口返回code码字段\"\n},\n\"data\": {\n\"type\": \"object\",\n\"properties\": {\n\"code\": {\n\"type\": \"number\",\n\"description\": \"code返回码\"\n},\n\"message\": {\n\"type\": \"string\",\n\"description\": \"返回信息\"\n}\n},\n\"required\": [\n\"code\",\n\"message\"\n],\n\"additionalProperties\": false\n},\n\"msg\": {\n\"type\": \"string\",\n\"description\": \"接口返回信息字段\"\n}\n},\n\"required\": [\n\"code\",\n\"data\"\n]\n}\n}\n}\n}\n},\n\"parameters\": [\n{\n\"name\": \"orgcode\",\n\"in\": \"header\",\n\"description\": \"租户号 (@HeaderParam, 类型：string)\",\n\"required\": true,\n\"schema\": {\n\"type\": \"string\"\n}\n}\n],\n\"requestBody\": {\n\"description\": \"\",\n\"content\": {\n\"application/json\": {\n\"schema\": {\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\n\"type\": \"string\",\n\"description\": \"@BodyParam：姓名\"\n},\n\"age\": {\n\"type\": \"number\",\n\"description\": \"@BodyParam：年龄\"\n}\n},\n\"required\": [\n\"name\",\n\"age\"\n]\n}\n}\n}\n}\n}\n}\n},\n\"components\": {\n\"schemas\": {}\n}\n}","config-配置#Config 配置":"","项目根目录下创建yundocconfigjs文件#项目根目录下创建yundoc.config.js文件":"// yundoc.config.js\nconst path = require('path');\nmodule.exports = {\nroutePrefix: '/api', // routing-controllers路由前缀\ncontrollers: [path.join(process.cwd(), \"./src/controller/*\")],\nfilterFiles: [],\nrequiredType: 'typescript', // typescript | routing-controllers\nservers: [\n{\nurl: 'http://127.0.0.1:3000',\ndescription: '开发环境域名前缀',\n}\n],\n// 自定义统一 response 返回结构（可选）\nresponseSchema: {\ntype: 'object',\nproperties: {\ncode: {\ntype: \"number\",\ndescription: \"接口返回code码字段\",\n},\n// data配置必填，格式固定请不要更改\ndata: {\n$ref: \"#Response\",\n},\nmsg: {\ntype: \"string\",\ndescription: \"接口返回信息字段\",\n}\n},\nrequired: [\n\"code\",\n\"data\",\n]\n}\n}","参数说明#参数说明":"字段\t类型\t必填\t说明\troutePrefix\tstring\t否\t路由前缀，跟routing-controllers保持一致\tcontrollers\tstring|string[]\t否\t需要解析的controller文件或需要解析的controller文件夹，默认：/src/controller/*，可根据文件名匹配，例如: /src/**/*Controller.ts，备注： 必须是绝对路径\trequiredType\ttypescript | routing-controllers\t否\tcontroller参数必填模式，默认使用typescript\tfilterFiles\tstring[]\t否\t过滤解析的npm包或者ts文件\toutfile\tstring\t否\topenapi数据存放文件，备注：必须是绝对路径\tservers\t{url：string,description?:string}[]\t否\tapi根路由与描述\tresponseSchema\tResponseSchemaObject\t否\t返回数据包裹层数据格式，由于大部分BFF使用了内置的返回包裹，在controller级别无法解析，因此开发给使用方进行自定义。","responseschema-参数说明#responseSchema 参数说明":"responseSchema严格遵循JsonSchema数据格式\n字段\t类型\t必填\t说明\ttype\tstring\t是\t值为object，固定值不要更改（描述当前schema数据类型）\tproperties\t{[prop:string]: {type?:string;$ref?:string;description?:string}}\t否\t当前对象的属性描述信息。\trequired\tstring[]\t否\t描述当前object的必填字段，若无必填字段则不需要此参数\n\nproperties 字段描述\n\n\n字段\t类型\t必填\t说明\ttype\tstring\t是\t此处type只需要填写简单类型，例如：string,number,boolean\t$ref\tstring\t是\t此处为固定值：#Response, 不要更改\tdescription\tstring\t否\t当前字段描述信息\n\n备注： properties 中 $ref 和 type必须有一项为真。","routing-controllers-支持项# routing-controllers 支持项":"","支持的api介绍#支持的Api介绍":"Controller装饰器支持\nMethod装饰器支持\n参数装饰器支持\n@Body装饰器支持类型\n@BodyParam装饰器支持类型\n@Body,@BodyParam装饰器混用\n@QueryParams装饰器解析\n@QueryParam,@QueryParams混用\nResponse返回类型支持\n工具函数支持说明\n注释支持说明\n参数必填说明\n参数默认值说明\nany|never|null类型说明\n常见复杂类型解码\n提示说明","controller装饰器支持#Controller装饰器支持":"目前Controller装饰器只支持Controller 与 JsonController 装饰器。\nController路由只支持静态路由，不支持动态路由。\n\n\n支持\n\n\n// 支持\n@Controller('/main')\n\n// 支持\n@JsonController('/main')\n\n不支持\n\n\n// 动态Controller路由不支持\n@JsonController('/main/:id')\n\n// 非路由装饰器会被忽略\n// 不支持\nJWTMiddleware()\n\n\n非路由装饰器，则会被忽略","method装饰器支持#Method装饰器支持":"","-仅支持以下请求装饰器#* 仅支持以下请求装饰器":"@Get、@Post、@Put、@Patch、@Delete、@Head 它们会会被相应的解析为以下HTTP请求类型\n@Get -> get\n@Post -> post\n@Put -> put\n@Patch -> path\n@Delete -> delete\n@Head -> head","-method装饰器对动态路由的支持#* Method装饰器对动态路由的支持":"// 支持\n@Get('/test/:id')\n\n// 支持\n@Get('/test/:id/:name')\n\n// 支持\n@Get('/test/:id/com/:age')\n备注：\n\n动态路由参数会动解析为path参数，并会被解析为必填参\n动态路由会跟@Param、@Params装饰器进行合并，从而解析出注释、默认值等信息","-动态路由path参数展现形式#* 动态路由path参数展现形式":"动态路由参数会被解析为path类型参数，展示形式为路径参数, 展示效果如下：","参数装饰器支持#参数装饰器支持":"","-仅支持以下参数装饰器#* 仅支持以下参数装饰器":"path参数类型装饰器\nParam、Params\ncookie参数类型装饰器\nCookieParam、CookieParams\nheader参数类型装饰器\nHeaderParam、HeaderParams、Session、SessionParam\nquery参数类型装饰器\nQueryParam、QueryParams、State、UploadedFile、UploadedFiles\nbody参数类型装饰器\nBody、BodyParam","-参数装饰器类别#* 参数装饰器类别":"参数装饰器会被分为 path、cookie、header、query、body","body装饰器支持类型#@Body装饰器支持类型":"备注：以下内容同样适用于 Params HeaderParams CookieParams Session State UploadedFiles","-body装饰器强烈推荐定义为接口类型#* @Body装饰器（强烈推荐定义为接口类型）":"interface BodyInterface{\nname: string;\nage: number;\n}\n// 支持 强烈推荐类型\n@Body() body: BodyInterface             // 接口类型","-body装饰器支持以下类型但不推荐使用#* @Body装饰器支持以下类型，但不推荐使用":"interface AAA {\nother1: string;\n}\ninterface BBB {\nother2: string;\n}\n\n// 以下方式支持，但不推荐使用\n@Body() body1: AAA | BBB,               // 联合类型\n@Body() body2: AAA & BBB,               // 交叉类型\n@Body() body3: Array<BBB>,              // 数组类型\n@Body() body4: Array<BBB & AAA>,        // 数组类型\n@Body() body5: Array<BBB | AAA>,        // 数组类型\n@Body() body6: BBB[],                   // 数组类型\n@Body() body7: (BBB | AAA)[],           // 数组类型\n@Body() body8: (BBB & AAA)[],           // 数组类型","-body装饰器支持以下类型但强烈不推荐使用#* @Body装饰器支持以下类型，但强烈不推荐使用":"enum Label {\nLABEL_OPTIONAL = 1,\nLABEL_REQUIRED = 2,\nLABEL_REPEATED = 3,\n}\n\n// 以下方式支持，但强烈不推荐使用\n@Body() body1: any,                          // any类型 它将被解析为object类型\n@Body() body2: never,                        // never类型 它将被解析为object类型\n@Body() body3: null,                         // null类型 它将被解析为object类型\n@Body() body4: string,                       // 基础类型\n@Body() body5: string | number,              // 基础类型\n@Body() body6: Label,                        // 枚举类型\n@Body() body7: number[],                     // 基础数组类型\n@Body() body8: (number | string)[],          // 基础数组类型\n@Body() body9: Array<number>,                // 基础数组类型\n@Body() body10: Array<number | string>,      // 基础数组类型\n@Body() body11: Label[],                     // 枚举数组类型\n@Body() body12: Array<Label | string>,       // 枚举数组类型","bodyparam装饰器支持类型#@BodyParam装饰器支持类型":"备注：以下内容同样适用于 Param HeaderParam CookieParam SessionParam UploadedFile","-bodyparam装饰器强烈推荐定义为基础类型#* @BodyParam装饰器（强烈推荐定义为基础类型）":"type AAA = number;\n\n// 支持 强烈推荐类型\n@BodyParam('param1') param1: string,        // 基础类型string\n@BodyParam('param2') param2: number,        // 基础类型number\n@BodyParam('param3') param3: boolean,       // 基础类型boolean\n@BodyParam('param4') param4: AAA,           // 基础类型number","-bodyparam装饰器支持以下类型但不推荐使用#* @BodyParam装饰器支持以下类型，但不推荐使用":"enum Label {\nLABEL_OPTIONAL = 1,\nLABEL_REQUIRED = 2,\nLABEL_REPEATED = 3,\n}\n\n// 以下方式支持，但不推荐使用\n@BodyParam('param1') param1: string | number,           // 联合类型\n@BodyParam('param2') param2: Label,                     // 枚举类型\n@BodyParam('param3') param3: Label|number,              // 基础联合类型\n@BodyParam('param4') param4: string[],                  // 基础数组类型\n@BodyParam('param5') param5: (string|boolean)[],        // 基础数组类型\n@BodyParam('param6') param6: Array<string>,             // 基础数组类型\n@BodyParam('param7') param7: Array<string|number>,      // 基础数组类型","-bodyparam装饰器支持以下类型但强烈不推荐使用#* @BodyParam装饰器支持以下类型，但强烈不推荐使用":"interface AAA {\nother1: string;\n}\ninterface BBB {\nother2: string;\n}\n\n// 以下方式支持，但强烈不推荐使用\n@BodyParam('param1') param1: any,                         // any类型 它将被解析为object类型\n@BodyParam('param2') param2: never,                       // never类型 它将被解析为object类型\n@BodyParam('param3') param3: null,                        // null类型 它将被解析为object类型\n@BodyParam('param4') param4: AAA,                         // 接口类型\n@BodyParam('param5') param5: AAA|BBB,                     // 接口联合类型\n@BodyParam('param6') param6: AAA&BBB,                     // 接口交叉类型\n@BodyParam('param7') param7: AAA[],                       // 接口数组类型\n@BodyParam('param8') param8: (AAA|BBB)[],                 // 接口数组类型\n@BodyParam('param9') param9: (AAA&BBB)[],                 // 接口数组类型\n@BodyParam('param10') param10: Array<AAA>,                // 接口数组类型\n@BodyParam('param11') param11: Array<AAA|BBB>,            // 接口数组类型\n@BodyParam('param12') param12: Array<AAA&BBB>,            // 接口数组类型","bodybodyparam装饰器混用#@Body,@BodyParam装饰器混用":"@Body装饰器实际上是包含了 @BoryParam装饰器的参数，因此解析过程中会给出提示建议：不推荐同时使用@Body与@BodyParam装饰器，请单独使用@Body或@BodyParam装饰器。\n实际处理过程中，会把所有的@BoryParam进行合并，合并为interface接口类型，再结合@Body参数处理为 联合类型。\n\n处理案例：\ninterface AAA {\nparam1: string;\nparam2: string;\n}\n// method\n@Post('/test')\nasync test(\n@Body() body1: AAA;\n@BodyParam(\"param1\") param1: string,\n@BodyParam(\"param2\") param2: string,\n): Promise<string> {}\n\n// 处理为\n{\n\"anyOf\": [\n{\n\"$ref\": \"#/definitions/AAA\"\n},\n{\n\"type\": 'object',\n\"properties\": {\n\"param1\": {\n\"type\":'string'\n},\n\"param2\": {\n\"type\": 'string'\n}\n}\n}\n],\n\"definitions\": {\n\"AAA\": {\n\"type\": 'object',\n\"properties\": {\n\"param1\": {\n\"type\":'string'\n},\n\"param2\": {\n\"type\": 'string'\n}\n}\n},\n}\n}\n\n备注\n\n\n\n对于同时使用@Body和@BoryParam，会被处理为联合类型，因此并不推荐两者同时使用，解析的api参数会存在多余的情况,从而带来困惑。","queryparams装饰器解析#@QueryParams装饰器解析":"备注：以下内容同样适用于 Params HeaderParams CookieParams Session State UploadedFiles\n\n\n非body类型参数都会做打平处理，即interface 接口类型会被解析为多个参数。","-以下参数类型是等效的#* 以下参数类型是等效的":"interface AAA {\nparam1: string;\nparam2: string;\n}\n\n@Get('/test')\nasync test(\n@QueryParams() params: AAA,\n): Promise<string> {}\n\n// 等效于\n\n@Get('/test')\nasync test(\n@QueryParam('param1') param1: string,\n@QueryParam('param2') param2: string,\n): Promise<string> {}\n以上两种写法，解析出来的参数是等效的。","queryparamqueryparams混用#@QueryParam,@QueryParams混用":"@QueryParams 装饰器 实际上是包含了@QueryParam 装饰器的参数, 由于@QueryParams装饰器会被打平，因此如果有相同的参数key,那么解析出来的数据参数就会有重复，从而导致数据校验不通过。\n案例：\n\n\n// 以下装饰器解析解析数据会报错，由于params2参数重复\ninterface AAA {\nparams1: string;\nparams2: string;\n}\n@Get('/test')\nasync test(\n@QueryParams() params: AAA,\n@QueryParam('params2') params2: string,\n@QueryParam('params3') params3: string,\n): Promise<string> {}\n备注：\n\n当同时使用@QueryParam与 @QueryParams 装饰器时，不要有相同的参数key,不然会导致解析的数据校验不通过。","response返回类型支持#Response返回类型支持":"支持Promise与非Promise场景\n\n\ninterface Response {\ncode: number;\ndata: { name: string };\nmsg: string;\n}\n\n// 支持非Promise场景解析\n@Get('/test')\ntest(): Response {}                                   // 支持非Promise场景\n\n// 支持Promise场景解析\n@Get('/test')\nasync test(): Promise<Response> {}                    // 支持Promise场景","-response返回类型强烈推荐返回接口类型#* Response返回类型强烈推荐返回接口类型":"interface Response {\ncode: number;\ndata: { name: string };\nmsg: string;\n}\n\n// 支持 强烈推荐类型\n@Get('/test')\nasync test(): Promise<Response> {}                      // 接口类型","-response返回类型支持以下类型但不推荐使用#* Response返回类型支持以下类型，但不推荐使用":"interface AAA {\nother1: string;\n}\ninterface BBB {\nother2: string;\n}\nenum Label {\nLABEL_OPTIONAL = 1,\nLABEL_REQUIRED = 2,\nLABEL_REPEATED = 3,\n}\n\n// 以下方式支持，但不推荐使用\nasync test(): Promise: <string> {}                          // 字符串类型\nasync test(): Promise: <string | number> {}                 // 基础联合类型\nasync test(): Promise: <Label> {}                           // 枚举类型\nasync test(): Promise: <number[]> {}                        // 基础数组类型\nasync test(): Promise: <(number | string)[]> {}             // 数组联合类型\nasync test(): Promise: <Array<number>> {}                   // 数组类型\nasync test(): Promise: <Array<number | string>> {}          // 数组类型\nasync test(): Promise: <Label[]> {}                         // 枚举数组类型\nasync test(): Promise: <Array<Label | string>> {}           // 枚举数组类型\nasync test(): Promise: <AAA | BBB> {}                       // 联合类型\nasync test(): Promise: <AAA & BBB> {}                       // 交叉类型\nasync test(): Promise: <Array<BBB>> {}                      // 数组类型\nasync test(): Promise: <Array<BBB & AAA>> {}                // 数组类型\nasync test(): Promise: <Array<BBB | AAA>> {}                // 数组类型\nasync test(): Promise: <BBB[]> {}                           // 数组类型\nasync test(): Promise: <(BBB | AAA)[]> {}                   // 数组类型\nasync test(): Promise: <(BBB & AAA)[]> {}                   // 数组类型","-response返回类型支持以下类型但强烈不推荐使用#* Response返回类型支持以下类型，但强烈不推荐使用":"// 以下方式支持，但强烈不推荐使用\nasync test(): Promise: <any>,                          // any类型 它将被解析为object类型\nasync test(): Promise: <never>,                        // never类型 它将被解析为object类型\nasync test(): Promise: <null>,                         // null类型 它将被解析为object类型","-response-使用外层传入的schema-嵌套#* Response 使用外层传入的Schema 嵌套":"某些情况下routing-controllers搭建的Node框架，对controller返回类型会做一个公共的处理, 因此没有很好办法获取到准确的返回外层信息。 在yunke.config.js中提供了responseSchema参数 responseSchema详细配置说明，来进行自定义的外层包裹。","-目前只支持成功状态下的type类型解析#* 目前只支持成功状态下的type类型解析":"","工具函数支持说明#工具函数支持说明":"目前支持Omit,Pick,Record三个工具函数\n\n\ntype ToolFn_1 = Omit<{ a: number; b: string; c: boolean; }, \"b\">;\n\n// 得到\n{\n\"type\": \"object\",\n\"properties\": {\n\"a\": {\n\"type\": \"number\"\n},\n\"c\": {\n\"type\": \"boolean\"\n}\n},\n\"required\": [\n\"a\",\n\"c\"\n]\n}\n\nPick\n\n\ntype ToolFn_9 = Pick<{ a: number; b: string; c: boolean; }, \"b\">;\n\n// 得到\n{\n\"type\": \"object\",\n\"properties\": {\n\"b\": {\n\"type\": \"string\"\n}\n},\n\"required\": [\n\"b\"\n]\n}\n\nRecord\n\n\ntype ToolFn_13 = Record<\"home\" | \"about\" | \"contact\" | string, number>\n\n// 得到\n{\n\"type\": \"object\",\n\"properties\": {\n\"home\": {\n\"type\": \"number\"\n},\n\"about\": {\n\"type\": \"number\"\n},\n\"contact\": {\n\"type\": \"number\"\n}\n},\n\"required\": [\n\"home\",\n\"about\",\n\"contact\"\n],\n\"definitions\": {},\n\"additionalProperties\": {\n\"type\": \"number\"\n}\n}","注释支持说明#注释支持说明":"vs code 编辑器，推荐大家安装 Document This 插件，使用快捷键生成注释, 快捷键：Ctrl+Alt+D and again Ctrl+Alt+D 。","1-注释支持类型#1. 注释支持类型":"单行注释\n多行注释\n\n\n// 支持单行注释\n\n/**\n*\n* 支持多行注释\n*\n*/","2-interface-注释案例#2. interface 注释案例":"interface AAA {\n// 姓名\nname: string;\n/**\n* 年龄\n*/\nage: number;\n}","3-interface-复杂注释#3. interface 复杂注释":"interface AAA {\n// @param {string} [name='zane'] 姓名\nname: string;\n/**\n* 年龄\n* @param {number} [age=25]\n*/\nage: number;\n}","4-method函数参数注释支持#4. method函数参数注释支持":"行内注释\n\n\n// -----简单注释----------\n\n// 获得用户信息（方法名注释）\n@Get('/test')\nasync getUserInfo(\n// 姓名\n@QueryParam(\"name\") name: string,\n/**\n* 年龄\n*/\n@QueryParam(\"age\") age: number,\n): Promise<{name: string}> {}\n\n\n// -----复杂注释----------\n\n// 获得用户信息（方法名注释）\n@Get('/test')\nasync getUserInfo(\n// @param {string} [name='zane'] 姓名\n@QueryParam(\"name\") name: string = 'zane',\n/**\n* 年龄\n* @param {number} [age=25]\n*/\n@QueryParam(\"age\") age: number = 25,\n): Promise<{name: string}> {}\n\n函数顶部注释\n\n\n// -----简单注释----------\n\n/**\n* 获得用户信息（方法名注释）\n* @param {string} name 姓名\n* @param {number} age 年龄\n*/\n@Get('/test')\nasync getUserInfo(\n@QueryParam(\"name\") name: string,\n@QueryParam(\"age\") age: number,\n): Promise<{name: string}> {}\n\n\n// -----复杂注释----------\n/**\n* 获得用户信息（方法名注释）\n* @param {string} [name='zane'] 姓名\n* @param {number} [age=25] 年龄\n*/\n@Get('/test')\nasync getUserInfo(\n@QueryParam(\"name\") name: string = 'zane',\n@QueryParam(\"age\") age: number = 25,\n): Promise<{name: string}> {}","5-块级注释-method-描述支持#5. 块级注释 method 描述支持":"// -----简单注释----------\n\n/**\n* 获得用户信息（方法名注释）\n* @description 方法级别的描述信息\n* @param {string} name 姓名\n* @param {number} age 年龄\n*/\n@Get('/test')\nasync getUserInfo(\n@QueryParam(\"name\") name: string,\n@QueryParam(\"age\") age: number,\n): Promise<{name: string}> {}","6-注释优先级说明#6. 注释优先级说明":"interface注释  > 函数顶部注释 > 方法行内注释","参数必填说明#参数必填说明":"参数必填支持两种模式\n\n\n\ntypescript\nrouting-controllers","1-依赖于ts-interface-本身的必填与非必填#1. 依赖于Ts interface 本身的必填与非必填":"interface AAA {\nname: string;\nage?: number;\n}\n解析以上代码结果如下：\nname: 必填\nage: 非必填\n\n\n更复杂的常见\n\n\ninterface BBB {\nattr4: string;\nattr5?: string;\n}\ninterface CCC {\nattr6: string;\nattr7?: string;\n}\ninterface AAA {\nattr1: string;\nattr2: BBB;\nattr3?: CCC;\n}\n解析以上代码结果如下：\nattr1: 必填\nattr4：必填\nattr5：非必填\nattr6：非必填\nattr7：非必填","2-依赖于routing-controllers自带的required参数#2. 依赖于routing-controllers自带的{required}参数":"@Get('/test')\nasync test(\n@QueryParam(\"name\",{required: true}) name: string,\n@QueryParam(\"age\") age: number,\n): Promise<{name: string}> {}\n解析以上代码结果如下：\nname: 必填\nage: 非必填\n\n\ninterface AAA {\nsome1: string;\nsome2?: number;\n}\n\n@Get('/test')\nasync test(\n@QueryParams() parames: AAA;\n@QueryParam(\"name\",{required: true}) name: string,\n@QueryParam(\"age\") age: number,\n): Promise<{name: string}> {}\n解析以上代码结果如下：\nsome1: 必填\nsome2: 非必填\nname: 必填\nage: 非必填","3-必填优先级说明#3. 必填优先级说明":"interface > required","参数默认值说明#参数默认值说明":"默认值支持单行注释和多行注释","1-interface-赋默认值#1. interface 赋默认值":"interface AAA {\n// @param {string} [name='zane'] 用户\nname: string;\n/**\n* @param {number} [age=25] 年龄\n*/\nage: number;\n}\n解析以上代码解析默认值结果如下：\nname: zane\nage: 25","2--method函数行内参数默认值#2.  method函数行内参数默认值":"@Get('/test')\nasync test(\n@QueryParam(\"name\",{required: true}) name: string='zane',\n@QueryParam(\"age\") age: number=25,\n): Promise<{name: string}> {}\n解析以上代码解析默认值结果如下：\nname: zane\nage: 25","3--method函数行内参数备注获取默认值#3.  method函数行内参数备注获取默认值":"@Get('/test')\nasync test(\n// @param {string} [name='zane'] 用户\n@QueryParam(\"name\",{required: true}) name,\n/**\n* @param {number} [age=25] 年龄\n*/\n@QueryParam(\"age\") age,\n): Promise<{name: string}> {}\n解析以上代码解析默认值结果如下：\nname: zane\nage: 25","4-函数顶部注释获得默认值#4. 函数顶部注释获得默认值":"/**\n* 获得用户信息\n* @param {string} [name='zane'] 姓名\n* @param {number} [age=25] 年龄\n*/\n@Get('/test')\nasync getUserInfo(\n@QueryParam(\"name\") name: string = 'zane',\n@QueryParam(\"age\") age: number = 25,\n): Promise<{name: string}> {}\n解析以上代码解析默认值结果如下：\nname: zane\nage: 25","5-interface-获得默认值#5. interface 获得默认值":"interface AAA {\n// @param {string} [name='zane'] 用户\nname: string;\n/**\n* @param {number} [age=25] 年龄\n*/\nage: number;\n}\n/**\n* 获得用户信息\n*/\n@Get('/test')\nasync getUserInfo(\n@QueryParams() name: AAA,\n): Promise<{name: string}> {}\n解析以上代码解析默认值结果如下：\nname: zane\nage: 25","5-默认值优先级#5. 默认值优先级":"参数默认赋值 > interface > 顶部注释 > 行内注释","anynevernull类型说明#any|never|null类型说明":"any,never,null 三种类型都会被转换为object类型， 即{type:'object'}, 不会有属性。","1-any-类型#1. any 类型":"any类型代表任意类型，此种情况下，解释器并不知道你需要解析为什么类型，因此只能解析为object类型，解析为任意其他类型都会有误判。因此不建议 参数/返回值等出现any类型。","2-never-类型#2. never 类型":"never 类型代表从来不会出现的值的类型, 由于openapi中必须有一个类型，因此此处解析为 object 类型。不推荐项目中使用此类型。","3-null-类型#3. null 类型":"null类型本质上还是属于object, 由于openapi中不存在null类型，因此解析为object类型。不推荐项目中使用此类型。","常见复杂类型解码#常见复杂类型解码":"","1-联合类型#1. 联合类型":"interface A {\nname: string;\n}\ninterface B {\nname1: string\n}\n\ninterface SomeInterface {\nattr: A|B\n}\n将被解析为：\n{\n\"type\": \"object\",\n\"properties\": {\n\"attr\": {\n\"anyOf\": [\n{\n\"$ref\": \"#/definitions/A\"\n},\n{\n\"$ref\": \"#/definitions/B\"\n}\n]\n}\n},\n\"required\": [\n\"attr\"\n],\n\"definitions\": {\n\"A\": {\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\n\"type\": \"string\"\n}\n},\n\"required\": [\n\"name\"\n]\n},\n\"B\": {\n\"type\": \"object\",\n\"properties\": {\n\"name1\": {\n\"type\": \"string\"\n}\n},\n\"required\": [\n\"name1\"\n]\n}\n}\n}","2-交叉类型#2. 交叉类型":"interface A {\nname: string;\n}\ninterface B {\nname1: string\n}\ninterface SomeInterface {\nattr: A&B\n}\n将被解析为：\n{\n\"type\": \"object\",\n\"properties\": {\n\"attr\": {\n\"allOf\": [\n{\n\"$ref\": \"#/definitions/A\"\n},\n{\n\"$ref\": \"#/definitions/B\"\n}\n]\n}\n},\n\"required\": [\n\"attr\"\n],\n\"definitions\": {\n\"A\": {\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\n\"type\": \"string\"\n}\n},\n\"required\": [\n\"name\"\n]\n},\n\"B\": {\n\"type\": \"object\",\n\"properties\": {\n\"name1\": {\n\"type\": \"string\"\n}\n},\n\"required\": [\n\"name1\"\n]\n}\n}\n}","3-联合数组类型#3. 联合数组类型":"interface A {\nname: string;\n}\ninterface B {\nname1: string\n}\ninterface SomeInterface {\nattr: Array<A&B>\n}\n将被解析为：\n{\n\"type\": \"object\",\n\"properties\": {\n\"attr\": {\n\"type\": \"array\",\n\"items\": {\n\"allOf\": [\n{\n\"$ref\": \"#/definitions/A\"\n},\n{\n\"$ref\": \"#/definitions/B\"\n}\n]\n}\n}\n},\n\"required\": [\n\"attr\"\n],\n\"definitions\": {\n\"A\": {\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\n\"type\": \"string\"\n}\n},\n\"required\": [\n\"name\"\n]\n},\n\"B\": {\n\"type\": \"object\",\n\"properties\": {\n\"name1\": {\n\"type\": \"string\"\n}\n},\n\"required\": [\n\"name1\"\n]\n}\n}\n}","4-interface-深度嵌套#4. interface 深度嵌套":"interface A {\nname: string;\nattr: B;\n}\ninterface B {\nname1: string;\n}\ninterface SomeInterface {\nattr: A\n}\n将被解析为：\n{\n\"type\": \"object\",\n\"properties\": {\n\"attr\": {\n\"$ref\": \"#/definitions/A\"\n}\n},\n\"required\": [\n\"attr\"\n],\n\"definitions\": {\n\"A\": {\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\n\"type\": \"string\"\n},\n\"attr\": {\n\"$ref\": \"#/definitions/B\"\n}\n},\n\"required\": [\n\"name\",\n\"attr\"\n]\n},\n\"B\": {\n\"type\": \"object\",\n\"properties\": {\n\"name1\": {\n\"type\": \"string\"\n}\n},\n\"required\": [\n\"name1\"\n]\n}\n}\n}","5-枚举类型#5. 枚举类型":"","数字枚举#数字枚举":"enum Enum_3 {\nUp = 1,\nDown,\nLeft,\nRight,\n}\n将被解析为：\n{\n\"enum\": [\n1,\n2,\n3,\n4,\n],\n\"type\": \"number\",\n}","字符串枚举#字符串枚举":"enum Enum_1 {\nA = 'A',\nB = 'B',\nC = 'C',\n}\n将被解析为：\n{\n\"enum\": [\n\"A\",\n\"B\",\n\"C\",\n],\n\"type\": \"string\",\n}","计算枚举#计算枚举":"enum Enum_6 {\nA = 1,\nB = A * 2,\nC = A * B + A,\nD = 1 << 2,\n}\n将被解析为：\n{\n\"enum\": [\n1,\n2,\n3,\n4,\n],\n\"type\": \"number\",\n}","6-类型为一个或多个固定值将会被解析为枚举#6. 类型为一个或多个固定值，将会被解析为枚举":"单个值\ninterface SomeInterface {\nattr: '1'\n}\n将被解析为：\n{\n\"type\": \"object\",\n\"properties\": {\n\"attr\": {\n\"type\": \"string\",\n\"enum\": [\n\"1\"\n]\n}\n},\n\"required\": [\n\"attr\"\n]\n}\n多个值\ninterface SomeInterface {\nattr: '1'|'2'|'3'\n}\n将被解析为：\n{\n\"type\": \"object\",\n\"properties\": {\n\"attr\": {\n\"type\": \"string\",\n\"enum\": [\n\"1\",\n\"2\",\n\"3\"\n]\n}\n},\n\"required\": [\n\"attr\"\n]\n}","7-复杂类型的多值场景#7. 复杂类型的多值场景":"interface A {\nname: string;\nattr: B;\n}\ninterface B {\nname1: string;\n}\nenum Label {\nLABEL_OPTIONAL = 1,\nLABEL_REQUIRED = 2,\nLABEL_REPEATED = 3,\n}\n\ninterface SomeInterface {\nattr: '1' | '2' | '3' | true | 1 | Label | Array<A | B>\n}\n将被解析为：\n{\n\"type\": \"object\",\n\"properties\": {\n\"attr\": {\n\"anyOf\": [\n{\n\"$ref\": \"#/definitions/Label\"\n},\n{\n\"type\": \"array\",\n\"items\": {\n\"anyOf\": [\n{\n\"$ref\": \"#/definitions/A\"\n},\n{\n\"$ref\": \"#/definitions/B\"\n}\n]\n}\n},\n{\n\"enum\": [\n\"1\",\n\"2\",\n\"3\",\ntrue,\n1\n]\n}\n]\n}\n},\n\"required\": [\n\"attr\"\n],\n\"definitions\": {\n\"Label\": {\n\"type\": \"number\",\n\"enum\": [\n1,\n2,\n3\n]\n},\n\"A\": {\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\n\"type\": \"string\"\n},\n\"attr\": {\n\"$ref\": \"#/definitions/B\"\n}\n},\n\"required\": [\n\"name\",\n\"attr\"\n]\n},\n\"B\": {\n\"type\": \"object\",\n\"properties\": {\n\"name1\": {\n\"type\": \"string\"\n}\n},\n\"required\": [\n\"name1\"\n]\n}\n}\n}","8-namespace-的解析#8. namespace 的解析":"export namespace NameSpaceParent {\nexport namespace NameSpacechild {\nexport namespace NameSpacechildren {\nexport interface A {\nname: string;\nattr: NameSpaceParent.NameSpacechild.NameSpacechildren.B;\n}\nexport interface B {\nname1: string;\n}\nexport enum Label {\nLABEL_OPTIONAL = 1,\nLABEL_REQUIRED = 2,\nLABEL_REPEATED = 3,\n}\n}\n}\n}\ninterface SomeInterface {\nattr: '1' | '2' | '3' | true | 1 | NameSpaceParent.NameSpacechild.NameSpacechildren.Label | Array<NameSpaceParent.NameSpacechild.NameSpacechildren.A | NameSpaceParent.NameSpacechild.NameSpacechildren.B>\n}\n将被解析为：\n{\n\"type\": \"object\",\n\"properties\": {\n\"attr\": {\n\"anyOf\": [\n{\n\"$ref\": \"#/definitions/NameSpaceParent.NameSpacechild.NameSpacechildren.Label\"\n},\n{\n\"type\": \"array\",\n\"items\": {\n\"anyOf\": [\n{\n\"$ref\": \"#/definitions/NameSpaceParent.NameSpacechild.NameSpacechildren.A\"\n},\n{\n\"$ref\": \"#/definitions/NameSpaceParent.NameSpacechild.NameSpacechildren.B\"\n}\n]\n}\n},\n{\n\"enum\": [\n\"1\",\n\"2\",\n\"3\",\ntrue,\n1\n]\n}\n]\n}\n},\n\"required\": [\n\"attr\"\n],\n\"definitions\": {\n\"NameSpaceParent.NameSpacechild.NameSpacechildren.Label\": {\n\"type\": \"number\",\n\"enum\": [\n1,\n2,\n3\n]\n},\n\"NameSpaceParent.NameSpacechild.NameSpacechildren.A\": {\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\n\"type\": \"string\"\n},\n\"attr\": {\n\"$ref\": \"#/definitions/NameSpaceParent.NameSpacechild.NameSpacechildren.B\"\n}\n},\n\"required\": [\n\"name\",\n\"attr\"\n]\n},\n\"NameSpaceParent.NameSpacechild.NameSpacechildren.B\": {\n\"type\": \"object\",\n\"properties\": {\n\"name1\": {\n\"type\": \"string\"\n}\n},\n\"required\": [\n\"name1\"\n]\n}\n}\n}","提示说明#提示说明":"框架会对常见的类型进行一定的提示，并推荐优化\n所有能提示的类型都会被正确解析，由于UI界面解析规则，或者业务逻辑本身的规则，某些提示类是无法正常的展示的。","例如queryparams-使用较复杂的数组类型#例如：@QueryParams 使用较复杂的数组类型":"interface AAA {\nname: string;\n}\n\n@Get('/test')\nasync test(\n@QueryParam(\"name\") name: AAA[],\n): Promise<{name: string}> {}\n此种场景能正确的解析， 但不能正常的UI展示，从逻辑层面来讲，@QueryParam 本身就应该是简单的基础类型。","例如-anynever-类型将会被解析为-object#例如： any,never 类型将会被解析为 object":"@Get('/test')\nasync test(\n@QueryParam(\"name\") name: any,\n): Promise<{name: string}> {}\n此种情况下，解析器并不知道你需要把 name 定义为什么类型， 因此只能解析为object类型， 但从逻辑层面来讲，@QueryParam 本身就应该是简单的基础类型，不应该为object类型， 这会给查看该接口的人带来困惑。","body-queryparam-等定义为基础类型#@Body @QueryParam 等定义为基础类型":"@Get('/test')\nasync test(\n@QueryParams() name: string,\n): Promise<{name: string}> {}\n\n@Post('/test')\nasync test(\n@Body() name: string,\n): Promise<{name: string}> {}\n从逻辑层面，routing-controllers 层面出发， @QueryParams,@Body装饰器本身就应该定义为复杂类型，或者interface类型，不应该定义为简单的基础类型， 这会给查看该接口的人带来困惑。","还有很多其他场景#还有很多其他场景":"@Body,@BodyParam 不应该混合使用， 原因：@Body本就应该包含所有的@BodyParam, 这会导致解析的接口有重复参数，进而给查看该接口的人带来困惑。\n相同的道理 Param与Params, QueryParam与QueryParams, HeaderParam与HeaderParams, CookieParam与CookieParams, Session与SessionParam, UploadedFile与UploadedFiles。\n\n还有其他等很多提示，这里就不一一列举，都会在编译过程中进行提示。","更多的ts类型解析#更多的Ts类型解析":"参考：fast-typescript-to-jsonschema","example-案例#example 案例":"git clone https://github.com/yunke-yunfly/routing-controllers-to-openapi.git\ncd routing-controllers-to-openapi\nyarn install\nyarn build\nyarn example","贡献#贡献":"我们非常欢迎您的贡献，您可以通过以下方式与我们共建。\n提交GitHub 问题以报告错误或提出问题。\n提出拉取请求以改进我们的代码。\n贡献指南。"}},"/document/openapi/request":{"title":"OpenAPI数据生成前端代码","data":{"":"","简介#简介":"通过 openapi3 或者 swagger 格式的文件生成前端类型定义和请求代码。","特性#特性":"支持 axios 定义\n支持解析过程自定义","使用#使用":"1.：安装依赖\n\n\nyarn add @yunflyjs/openapiv3-gen-typescript -D\n\n创建配置文件\n\n我们在根目录增加 gen-request.config.js，其内容为：\nmodule.exports = {\nmiddleman: {\nopenapi: './openapi.json',\n},\n};\n\n添加 scripts 命令\n\n在 package.json 增加 gen 命令如下：\n{\n\"scripts\": {\n\"gen-request\": \"gen-request\"\n}\n}\n\n生成 request 代码\n\n\nyarn gen-request\n或\nnpx gen-request","生成文件说明#生成文件说明":"|-- common.d.ts  # 公共的类型定义\n|-- types.d.ts  # 导出 types 目录下所有类型定义\n└-- types #  类型目录\n|-- user.d.ts # OssController 对应的接口类型定义\n| └-- oss.d.ts #  UserController 对应的接口的类型定义\n└-- apis # 生成的接口目录\n|-- user.ts # UserController 对应的接口\n└-- oss.ts # OssController 对应的接口","api#API":"属性\t说明\t类型\t是否必填\t默认值\topenapi\t项目配置\tstring\tOpenAPI\t必填\toutputDir\t输出目录\tstring\t必填\t-\taxiosFilePath\t自定义 axios 文件\tstring\t否\t'axios'\tresolver\t自定义解析逻辑\tResolverType\t否\t-\tbannerComment\t顶部注释\tstring\t否\t\tprettierConfig\tprettier 配置文件路径\tstring\t否\t-","openapi#openapi":"必填参数。\nopenapi: openapi 数据 或 openapi 文件地址 或 openapi http 地址","outputdir#outputDir":"输出目录，一般指向前端项目的 src/api 文件，可以使用绝对路径，也可以使用相对路径。","axiosfilepath#axiosFilePath":"一般情况下我们在前端项目中都会对 axios 进行自定义封装，请求接口也是用的我们封装后的 axios，此配置项就是为了满足此定制化的能力，它分两种配置方式：\n绝对路径：如果使用了 path.join(__dirname, xxx) 形式，最终会通过计算 outputDir 和 axiosFilePath 得出相对目录；\n相对路径：如果填的是 ../../utils/request 这样的相对路径，则不会做任何处理，它的含义是指相对于生成后的文件的路径。\n\n还有一点需要注意的是，必须使用 export default 去导出自定义的 axios，因为最终生成的效果为：\nimport request from '../../utils/request';\n如果不填，则默认是使用 axios 库。","bannercomment#bannerComment":"生成文件顶部的说明内容，默认为：\n/* eslint-disable */\n// @ts-nocheck\n/**\n* 此文件由 json-schema-to-request 生成，请不要手动修改！\n* 如果有修改需求，请修改源文件，然后重新生成。\n*/\\n\\n","prettierconfig#prettierConfig":"prettier 配置文件路径，本库在生成完内容后会用 prettier 进行一次代码格式化，考虑到每个项目的格式化配置不太一样，所以提供了此配置，用来指向前端 prettier 的配置文件。","resolver#resolver":"考虑到各种项目的特殊场景，我们提供了个性化的定制能力，具体有：\nexport interface ResolverType {\n// 文件名\nfileName?: (api: Api) => string;\nurl?: (api: Api) => string;\nmethod?: (api: Api) => string;\n// 函数名\nfnName?: (api: Api) => string;\n// 评论\nfnComment?: (api: Api) => string | undefined;\nparams?: ResolverPromiseFn;\nquery?: ResolverPromiseFn;\ncookie?: ResolverPromiseFn;\nheader?: ResolverPromiseFn;\nbody?: ResolverPromiseFn;\nresponse?: ResolverPromiseFn;\n}\n例如我们想要定制化 fileName 也就是输出文件的名称，我们可以这样写：\n{\nresolver: {\nfileName: ({ tags }) => tags[0] + 'Api';\n}\n}\n假如数据为：\n{\n\"/user/logout\": {\n\"get\": {\n\"tags\": [\"user\"],\n\"summary\": \"Logs out current logged in user session\",\n\"description\": \"\",\n\"operationId\": \"logoutUser\",\n\"responses\": {\n\"default\": {\n\"description\": \"successful operation\"\n}\n}\n}\n}\n}\n最后生成的文件名字就是 userApi.ts 和 userApi.d.ts。"}},"/document/plugin/apm":{"title":"@yunflyjs/yunfly-plugin-apm","data":{"":"apm 插件。\n插件功能：\n链路追踪\n参数透传\n性能数据收集\n\n\n使用文档：使用 apm 实现链路追踪"}},"/document/plugin/body-parser":{"title":"@yunflyjs/yunfly-plugin-body-parser","data":{"":"插件功能：\n获取 body 请求参数\n获取 get 请求参数\n\n\n使用文档：获取 Post 请求参数"}},"/document/plugin/current-context":{"title":"@yunflyjs/yunfly-plugin-current-context","data":{"":"在框架中想要获取 context 活动对象需要一层一层的传递。current 插件提供能在任意位置(不限于 controller、servicer、plugin、function)获取当前的 context 对象。\n插件功能：\n在任意位置获取 context 对象\nmetadata 参数透传\n\n\n使用文档：Context 活动对象"}},"/document/plugin/error":{"title":"@yunflyjs/yunfly-plugin-error","data":{"":"yunfly 框架错误处理插件，收集错误信息，给客户端抛出错误。\n插件功能：\n框架统一错误处理\n支持多种自定义错误类\n支持自定义错误code,逻辑\n支持错误日志输出\n\n\n使用文档：异常处理"}},"/document/plugin/jwt":{"title":"@yunflyjs/yunfly-plugin-fast-jwt","data":{"":"JSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。\n什么时候你应该用JWT\nAuthorization (授权) : 单点登录\nInformation Exchange (信息交换) : 信息交换\n\n\n插件功能：\n数据加密\n安全校验\n\n\n使用文档：JWT使用文档"}},"/document/plugin/prisma":{"title":"@yunflyjs/yunfly-plugin-prisma","data":{"":"新一代 orm 工具，框架数据库插件。\n插件功能：\n开箱即用\n支持 MySql SQLite SQL Server MongoDB PostgreSQL\n\n\n使用文档：prisma 详细使用文档"}},"/document/plugin/rate-limiter":{"title":"@yunflyjs/yunfly-plugin-rate-limiter","data":{"":"框架限流插件。\n插件功能：\n应用整体限流\n具体 path 路径限流\n用户级别限流\n\n\n使用文档：限流使用文档"}},"/document/plugin/redis":{"title":"@yunflyjs/yunfly-plugin-redis","data":{"":"redis 插件, 开箱即用。\n使用文档：redis详细使用文档"}},"/document/plugin/secruity":{"title":"@yunflyjs/yunfly-plugin-security","data":{"":"框架安全插件\n插件功能：\nWhitelist(域名白名单)\nMethods(请求类型校验)\nXSS(跨域脚本攻击)\nCSRF\nXframe\nHsts\nCORS\nCSP\n\n\n\n详细文档请参考安全篇。"}},"/document/quality/commit":{"title":"Commit","data":{"":"","背景#背景":"我们为什么要使用统一的 commit message 规范？\n\n方便快速浏览查找，回溯之前的工作内容\n\n\n\n可以直接从 commit 生成 Change log(发布时用于说明版本差异)\n\n\n\n如果我们不统一 commit message 规范？\n\n每个人风格不同，格式凌乱，不能清晰的通过 commit message 看出修改内容\n\n\n\n部分 commit 没有填写 message，事后难以得知对应修改的作用\n\n\n\n所以一份好的 commit message 规范可以提高团队协作的效率，减少代码回溯的时间。","什么样的-git-commit-是合适的#什么样的 Git Commit 是合适的？":"简单来说，Git Commit Message 应该是解释性的。通过阅读 Git Commit Message，应该可以了解到以下信息：\n这是一个什么样的修改？例如，这是一个 Bug 修复，新功能还是文档修改？\n这个修改大概影响的范围是哪些？\n这个修改的目的是什么？\n\n当一份解释性 Git Commit Message 包含足够的信息，那么就可以用于快速地搜索、定位改动。目前市面上常用的规范就是angular的规范，结构如下所示\n<type>(<scope>): <subject>\n<BLANK LINE>\n<body>\n<BLANK LINE>\n<footer>\n其中，类型包含以下类别：\nbuild：针对编译系统或外部依赖的修改，例如修改了 webpack 或 babel 的配置，或是升级了某个 npm 库\nci：针对 CI 系统配置的修改，例如修改了 Travis 或 Circle 的配置文件\ndocs：只针对文档的修改\nfeat：添加新的功能\nfix：修复 Bug\nperf：针对性能提升的优化\nrefactor：代码重构的改动，既没有修复 Bug 也没有添加新功能\nrevert：回滚之前的改动\nstyle：仅仅是针对代码格式的改动，如修复一些 ESLint 的报错\ntest：针对测试的改动，如添加新的测试或是修复已有测试的问题\n\n可选作用域(scope)用于说明当前修改的影响范围。这里的描述一般根据项目不同，会有差异。选填，可以没有。描述(subject)用于简短的描述当前修改的主要内容，长度不超过 50 个字符。（见 50/72 Formatting）正文(body)作为描述的补充，可以提供额外的信息。如果内容比较多，需要注意换行的问题。一般不建议 Commit Message 过长。例如，在 VSCode 中，一行 Commit Message 最长为 72 个字符。另外，从规范语言的角度来说，如果是英文 Commit Message，建议使用第一人称现在时，动词用原型即可。举例来说，写 fix 而不是 fixes 或者 fixed。脚注(footer)是描述的一些补充说明。主要有两种：\n不兼容改动：如果内容包含了不兼容的改动，需要用 BREAKING CHANGE 开头，后面可以补充说明当前不兼容变更的细节、理由以及升级的方案。\nIssues：如果修改有对应的 Issue，那么可以带上相应的 ID，方便后续查找。以 ISSUE 开头，后面跟随一个或多个 Issue ID，如 ISSUE #123 #456。","项目中使用#项目中使用":"1、安装依赖\nyarn add --dev @commitlint/config-angular @commitlint/cli\n# or\nyarn add --dev @commitlint/config-conventional @commitlint/cli\n2、修改 .commitlintrc.js\nmodule.exports = {\n// 继承默认配置\nextends: ['@commitlint/config-angular'] // or ['@commitlint/config-conventional']\n};\n\n@commitlint/config-angular 与 @commitlint/config-conventional 没什么大的区别。\n3、自定义规则\nmodule.exports = {\n// 继承默认配置\nextends: ['@commitlint/config-angular'],\n// 自定义规则\nrules: {\n'type-enum': [\n2,\n'always',\n['upd', 'feat', 'fix', 'refactor', 'docs', 'chore', 'style', 'revert'],\n],\n'header-max-length': [0, 'always', 72],\n},\n}","结合-husky-与-lint-stage-来做-commit-message-校验#结合 husky 与 lint-stage 来做 commit-message 校验":"yarn add --dev husky@^4.3.8 lint-staged@^10.5.4\npackage.json 内配置 husky 配置项\n{\n\"husky\": {\n\"hooks\": {\n\"commit-msg\": \"commitlint -E HUSKY_GIT_PARAMS\"\n}\n}\n},\n更多使用方式可以查看commitlint。","链接#链接":"commitlint\nwhy-use-conventional-commits"}},"/document/quality/cspell":{"title":"Cspell","data":{"":"cspell 是一个用于拼写检查代码的命令行工具和库。一份代码的好与坏，单词拼写的正确性也显得尤为重要。","使用#使用":"","1安装依赖#1、安装依赖":"yarn add cspell --dev","2配置检测规则#2、配置检测规则":"{\n\"version\": \"0.2\",\n\"language\": \"en\",\n\"words\": [\n\"typeof\",\n\"cnpm\"\n],\n\"ignorePaths\": [\n\"package.json\",\n\"node_modules/**\",\n\"**/*.snap\",\n\"coverage/**\",\n\".eslintrc.js\",\n\"cspell.json\",\n\"dist/**\",\n\"build/**\"\n]\n}\n配置详情: https://www.npmjs.com/package/cspell#Customization","3配置脚本命令#3、配置脚本命令":"{\n\"scripts\": {\n\"spell-check:all\": \"cspell \\\"**/*.{txt,ts,tsx,js,json,md}\\\"\"\n}\n}","4执行脚本命令#4、执行脚本命令":"yarn spell-check:all","结合-husky-与-lint-stage-来做-commit-cspell-校验#结合 husky 与 lint-stage 来做 commit-cspell 校验":"yarn add --dev husky@^4.3.8 lint-staged@^10.5.4\npackage.json 内配置 husky 配置项\n{\n\"husky\": {\n\"hooks\": {\n\"pre-commit\": \"yarn spell-check:all\"\n}\n}\n},\n更多使用请参考: https://www.npmjs.com/package/cspell"}},"/document/quality/eslint":{"title":"Eslint","data":{"":"代码风格校验器，这里采用 eslint-plugin-node 进行校验。","使用#使用":"","1安装依赖#1、安装依赖":"yarn add eslint eslint-plugin-node eslint-formatter-pretty --dev\n\n\nRequires Node.js >=8.10.0\nRequires ESLint >=5.16.0","2配置-eslint-规则#2、配置 eslint 规则":"module.exports = {\nextends: [\n\"eslint:recommended\",\n\"plugin:node/recommended\"\n],\nrules: {\n// 这里添加自定义规则\n'import/no-extraneous-dependencies': 0,\n'import/no-unresolved': 0\n},\nignorePatterns: [\n// 需要忽略的文件\n'src/__tests__/**',\n'rollup.config.js',\n'commitlint.config.js'\n],\n};\n更多eslint配置参考：https://eslint.org/docs/user-guide/configuring/configuration-files#configuration-file-formats","3配置脚本命令#3、配置脚本命令":"{\n\"scripts\": {\n\"lint:all\": \"yarn eslint --ext .js,.jsx,.ts,.tsx --format=pretty ./src\"\n}\n}","结合-husky-与-lint-stage-来做-commit-eslint-校验#结合 husky 与 lint-stage 来做 commit-eslint 校验":"yarn add --dev husky@^4.3.8 lint-staged@^10.5.4\npackage.json 内配置 husky 配置项\n{\n\"husky\": {\n\"hooks\": {\n\"pre-commit\": \"yarn lint:all\"\n}\n}\n},\n更多知识请参考：https://eslint.org/"}},"/document/quality/notes":{"title":"Notes","data":{"":"代码注释规范\n好的代码本身就具备自描述，有意义的命名，合理的代码结构，和良好的注释同样重要！","注释概述#注释概述":"","背景#背景":"当第一次接触某段代码，但又被要求在极短的时间内有效地分析这段代码，我们需要什么样的注释信息？\n怎样避免冗长的注释\n在多人协同开发、维护的过程中，需要什么样的注释提高团队的合作效率","优点#优点":"核心逻辑注释，易于理解业务流程实现，提高代码的可读性\n减少团队之间不必要的沟通，提高开发效率\n提高项目代码的可维护性\n代码智能提示\n根据注释生成文档","分类#分类":"类别\t含义\t重要性\t描述性注释\t描述程序功能和程序个组成部分相互关系的高级注释\t重要\t解释性注释\t逐行解释程序如何工作的低级注释\t不重要\t提示性注释\t在某处进行提示的注释\t一般","原则#原则":"注释风格统一\n用简洁的语言清晰描述\n专业词语\n准确反应设计思想和代码逻辑\n描述业务含义\n\n\n注释和代码的一致性\n建议先写注释，再写代码\n\n\n删除无用注释","场景#场景":"难于理解的代码段\n可能存在错误、具有潜在风险的代码段\n浏览器特殊的HACK代码\n想吐槽的产品逻辑\n业务逻辑强相关的代码\n模块间相互关系\n循环和逻辑分支","注释风格#注释风格":"","行内注释#行内注释":"一般用于变量名注释\nlet name = 'tom'; // 姓名","单行注释#单行注释":"注释单独在一行\n// 执行一个函数\nsay();","多行注释#多行注释":"js的多行注释以/*开头，以*/结尾，其中的字符都是注释。所以中间有没有*都可以，但一般建议换行的时候带上一个*\n\n/**\n* 第一行注释\n* 第二行注释\n*/\nsay();","文档化注释#文档化注释":"/**\n* 向某人打招呼\n* @param {string} name\n*/\nfunction say(name: string) {\nconsole.log(`hi ${name}`);\n}","常量#常量":"行内注释\nconst PI = 3.14; // 定义圆周率\n单独注释\n// 定义圆周率\nconst PI = 3.14;","枚举#枚举":"/**\n* @description 登录状态\n* @enum {number}\n*/\nenum LoginStatus {\n// 成功\nSuccess = 1,\n// 失败\nFail = 0,\n// 未知\nUnknown = -1\n}","函数#函数":"/**\n* @description 向某人打招呼\n* @param {string} name\n* @return {boolean}\n*/\nfunction say(name) {\nconsole.log(`hi ${name}`);\nreturn true;\n}\n可选参数\n/**\n* @description 向某人打招呼\n* @param {string} [name]\n* @return {boolean}\n*/\nfunction say(name?:string): boolean {\nconsole.log(`hi ${name}`);\nreturn true;\n}\n默认参数\n/**\n* @description 向某人打招呼\n* @param {string} [name='']\n* @return {boolean}\n*/\nfunction say(name:string = ''): boolean {\nconsole.log(`hi ${name}`);\nreturn true;\n}","类属性方法#类、属性、方法":"/**\n* @description 动物类\n* @class Animal\n*/\nclass Animal {\n// 名称\npublic name: string;\n\nconstructor(name: string) {\nthis.name = name;\n}\n\n/**\n* @description 打招呼\n* @return {string}\n* @memberof Animal\n*/\nsayHi() {\nreturn `My name is ${this.name}`;\n}\n}","文件注释#文件注释":"/**\n* @file 用户信息\n*/","工具#工具":"","jsdoc#jsdoc":"","document-this#Document This":"扩展配置\n\"todohighlight.keywords\": [\n{\n\"text\": \"NOTE:\",\n\"color\": \"white\",\n\"backgroundColor\": \"#6a8aff\",\n},\n{\n\"text\": \"DEBUG:\",\n\"color\": \"white\",\n\"backgroundColor\": \"#8a4af3\",\n},\n],"}},"/document/quality/unit-test":{"title":"单元测试","data":{"":"单元测试能力待开发 ..."}},"/document/secruity/cors":{"title":"CORS","data":{"":"","说明#说明":"当使用XMLHttpRequest从其他域名中获取资源进行跨域通信时使用, 主要设置HTTP头部信息字段。\n\nAccess-Control-Allow-Origin: http://www.example.com\nAccess-Control-Allow-Methods: POST, GET, OPTIONS\nAccess-Control-Allow-Headers: X-TRICORDER\nAccess-Control-Max-Age: 1728000\nAccess-Control-Expose-Headers: Server-Authorization","使用#使用":"新增安全配置 security.cors\n安装依赖\n\n\nyarn add @yunflyjs/yunfly-plugin-security\n\nconfig.security = {\nenable: true,\ncors: {\nenable: false,\norigin: () => {\nreturn \"https://xxx.com/\";\n},\nmaxAge: 3600,\ncredentials: true,\nexposeHeaders: [],\nallowMethods: ['GET', 'POST', 'OPTIONS'],\nallowHeaders: [\n'Content-Type', 'Authorization', 'Accept', 'X-Requested-With', 'x-csrf-token','x-rate-limiter-key',\n'x-rate-limiter', 'trace-branch', 'Cookie', \"token\",'x-timestamp','x-autho-token','trace-id'\n],\n},\n}","参数说明#参数说明":"字段\t类型\t必填\t说明\tenable\tboolean\t否\t是否开启\torigin\tstring/function\t否\t域名规则\tmaxAge\tnumber\t否\t\tcredentials\tboolean\t否\t是否允许携带cookie（备注：origin字段为具体域名时生效）\tallowMethods\tstring[]\t否\t允许的请求协议\tallowHeaders\tstring[]\t否\t允许Request的 Header头信息\texposeHeaders\tstring[]\t否\t允许暴露给浏览器的Header头信息\n参考地址：https://www.npmjs.com/package/koa2-cors"}},"/document/secruity/csp":{"title":"CSP","data":{"":"","说明#说明":"HTTP 响应头Content-Security-Policy允许站点管理者控制用户代理能够为指定的页面加载哪些资源。除了少数例外情况，设置的政策主要涉及指定服务器的源和脚本结束点。这将帮助防止跨站脚本攻击（Cross-Site Script）.","语法#语法":"Content-Security-Policy: <policy-directive>; <policy-directive>","指令#指令":"指令名称\t说明\tchild-src\t为 web workers 和其他内嵌浏览器内容（例如用<frame>和<iframe>加载到页面的内容）定义合法的源地址。\tconnect-src\t限制能通过脚本接口加载的URL。\tdefault-src\t为其他取指令提供备用服务fetch directives。\tfont-src\t设置允许通过@font-face加载的字体源地址。\tframe-src\t设置允许通过类似<frame>和<iframe>标签加载的内嵌内容的源地址。\timg-src\t限制图片和图标的源地址\tmedia-src\t限制通过<audio>、<video>或<track>标签加载的媒体文件的源地址。\tscript-src\t限制JavaScript的源地址。\tstyle-src\t限制层叠样式表文件源。","使用#使用":"安装依赖\n\n\nyarn add @yunflyjs/yunfly-plugin-security\n\n新增安全配置 security.csp\n\n\nconfig.security = {\nenable: true,\ncsp: {\nenable: false,\nreportOnly: false,\ndirectives:{\n'connect-src': ['http://127.0.0.1:3000','https://baidu.com'],\n'default-src': ['self','http://example.com']\n},\nmatch: [],\nignore: [],\n},\n}","参数说明#参数说明":"字段\t类型\t必填\t说明\tenable\tboolean\t否\t是否开启\tmatch\tstring[]\t否\t需要开启csrf规则的url列表，命中规则为indexOf, 值为空则命中所有路由\tignore\tstring[]\t否\t需要忽略csrf规则的url列表，命中规则为indexOf\treportOnly\tboolean\t否\t使用 Content-Security-Policy-Report-Only 指令\tdirectives\tDirectivesConfig\t否\t指令规则 (值为key->value对象类型，value是string[]类型)\n备注：\n\ncsp 相对于来说配置比较繁杂，规则也比较严格。\n在云客现有BFF的使用场景下，它的适用度不高，它的主要使用场景是加载页面时使用，如果只是使用于常规的接口请求并不需要进行配置。\n\n\n更多指令请参考：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy"}},"/document/secruity/csrf":{"title":"CSRF","data":{"":"","csrf常用的防范方案#CSRF常用的防范方案":"通过响应页面时将 token 渲染到页面上，在 form 表单提交的时候通过隐藏域提交上来。\n将 token 设置在 Cookie 中，在提交请求时提交 Cookie，并通过 header 或者 body 带上 Cookie 中的 token，服务端进行对比校验。","使用#使用":"","服务端#服务端":"安装依赖\n\n\nyarn add @yunflyjs/yunfly-plugin-security\n\n新增安全配置 security.csrf\n\n\nconfig.security = {\nenable: true,\ncsrf: {\nenable: true,\nmatch: [],\nignore: [],\nignoreMethods: ['GET', 'HEAD', 'OPTIONS'],\nkeyName: 'x-csrf-token',\nbodyName: '_csrf',\nsaltLength : 8,\nsecretLength: 18,\n}\n}","参数说明#参数说明":"字段\t类型\t必填\t说明\tenable\tboolean\t否\t是否开启\tmatch\tstring[]\t否\t需要开启csrf规则的url列表，命中规则为indexOf, 值为空则命中所有路由\tignore\tstring[]\t否\t需要忽略csrf规则的url列表，命中规则为indexOf\tignoreMethods\tstring[]\t否\t需要忽略csrf规则的请求类型，命中规则为includes\tkeyName\tstring\t否\t获取验证touken值的header key名或cookie key名\tbodyName\tstring\t否\t如果token通过参数传值时，定义的key名称\tsaltLength\tnumber\t否\t盐值长度（一般默认即可）\tsecretLength\tnumber\t否\t加密密钥长度（一般默认即可）","客户端#客户端":"客户端在进入页面或者表单提交时调用 /csrf/token 接口去获得 token。\n\n\n// 获取token地址\n/csrf/token\n\n// 例如 bff-example 项目的接口地址为\nhttp://127.0.0.1:3000/csrf/token\n备注：\n\n调用 api 成功之后，会默认的向页面注入 key 为 csrf.keyName 的 cookie 字段。\n调用 api 成功之后，在body中也会返回 token 字段。","注意事项#注意事项":"每次页面刷新时需要重新调用接口刷新 token\n切换用户时需要重新调用接口刷新 token"}},"/document/secruity/fusing":{"title":"熔断","data":{"":"熔断能力待开发..."}},"/document/secruity/hsts":{"title":"Hsts","data":{"":"","说明#说明":"HTTP Strict Transport Security（通常简称为HSTS）是一个安全功能，它告诉浏览器只能通过HTTPS访问当前资源，而不是HTTP","语法#语法":"Strict-Transport-Security: max-age=<expire-time>\nStrict-Transport-Security: max-age=<expire-time>; includeSubDomains\n\n值\t说明\tmax-age=<expire-time>\t设置在浏览器收到这个请求后的<expire-time>秒的时间内凡是访问这个域名下的请求都使用HTTPS请求。\tincludeSubDomains\t如果这个可选的参数被指定，那么说明此规则也适用于该网站的所有子域名。","使用#使用":"安装依赖\n\n\nyarn add @yunflyjs/yunfly-plugin-security\n\n新增安全配置 security.hsts\n\n\nconfig.security = {\nenable: true,\nhsts: {\nenable: true,\nmaxAge: 15552000,\nincludeSubDomains: true,\nmatch: [],\nignore: [],\n},\n}","参数说明#参数说明":"字段\t类型\t必填\t说明\tenable\tboolean\t否\t是否开启\tmatch\tstring[]\t否\t需要开启csrf规则的url列表，命中规则为indexOf, 值为空则命中所有路由\tignore\tstring[]\t否\t需要忽略csrf规则的url列表，命中规则为indexOf\tmaxAge\tnumber\t否\thttps访问过期时间（默认：15552000，即：180天）\tincludeSubDomains\tboolean\t否\t是否开启子域\n参考地址： https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Strict-Transport-Security"}},"/document/secruity/jwt":{"title":"JWT","data":{"":"","jwt是什么#JWT是什么":"JSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。","什么时候你应该用jwt#什么时候你应该用JWT":"Authorization (授权) : 这是使用JWT的最常见场景。一旦用户登录，后续每个请求都将包含JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的JWT的一个特性，因为它的开销很小，并且可以轻松地跨域使用。\nInformation Exchange (信息交换) : 对于安全的在各方之间传输信息而言，JSON Web Tokens无疑是一种很好的方式。因为JWT可以被签名，例如，用公钥/私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容没有被篡改。","使用#使用":"安装依赖\n\n\nyarn add yarn add @yunflyjs/yunfly-plugin-fast-jwt\n\nconfig/config.plugin.ts 中声明插件\n\n\n/**\n* yunfly 插件\n* 数组顺序就是插件的加载顺序\n*/\nconst plugins: {[key:string]: string}[] = [\n{\nname: 'jwt',\npackage: '@yunflyjs/yunfly-plugin-fast-jwt'\n}\n];\n//\nexport default plugins;\n\nconfig/config.default.ts 中启用插件 config.jwt\n\n\nconfig.jwt = {\nenable: true,\nexpiredPassThrough: false,\nsecret:'YUNFLYJS_JWT_TOKEN_DEMO',\nexpire: '1h',\ntoken: {\ntype: 'cookie',\nkey: 'Authorization',\nhttpOnly: true,\ndomain:'127.0.0.1',\npath:'/',\n// 20分钟后过期\nexpires: () => { return new Date(Date.now() + 60 * 1000 * 20) },\n},\n// token: { type:'header', key: 'Authorization' },\nrsSign: {\nenable: false,\ninterval: 15,\n},\nunless: ['/favicon.ico'],\nglobal: true,\npassThrough: false,\n}\n\njwt.config 还可以是一个函数\n\n\ntype JWTConfig = JWTOptions | ((ctx: Context) => JWTOptions)\n\nconfig.jwt = (ctx: Context) => {\nreturn {\nnable: true,\nexpiredPassThrough: false,\nsecret:'YUNFLYJS_JWT_TOKEN_DEMO',\nexpire: '1h',\n......\n}\n}","配置说明#配置说明":"参数\t类型\t默认值\t必填\t说明\tenable\tboolean\ttrue\t是\t是否启用 JWT 校验\tsecret\tstring\tYUNFLYJS_JWT_TOKEN_DEMO\t是\tJWT 盐值\texpiredPassThrough\tboolean\tfalse\t否\t当JWT过期时是自动重签还是向外抛出过期错误。自动重签会一直不过期，抛出过期错误需要自定义错误处理逻辑\texpire\tstring | number\t3h\t否\t过期时间 Eg: 60, \"2 days\", \"10h\", \"7d\".  (\"120\" is equal to \"120ms\").\ttoken\tJWTTokenOptions\t{ type:'header', key: 'Authorization' }\t否\ttoken配置项 (重要参数，请关注下面说明。)\trsSign\tRsSignOptions\t{ enable: false, interval: 15 }\t否\t自动续签,interval单位为分，默认为15分钟。若开启，当判断过期时间是否快超过interval分钟， 如果快超过就重新生成JWT秘钥。若expire小于等于interval则不处理\tglobal\tboolean\ttrue\t否\t是否全局启用 JWT 校验 (重要参数，请关注下面说明。)\tunless\tstring[]\t['/favicon.ico']\t否\t{ gobbal:true }时，此参数可用，需要排除 JWT 验证的接口\tpassThrough\tboolean\tfalse\t否\t{ gobbal:true }时，此参数可用，校验不通过时是否继续执行","token-参数说明#token 参数说明":"token 表示 JWT 参数传递方式，目前有两种方式进行传递\n1、 通过 header 头进行校验\n2、 通过 cookie 进行校验\n\n\n参数\t类型\t必填\t说明\ttype\t`header\tcookie`\t是\t参数传递方式\tkey\tstring\t是\tJWT 校验的 key 值\thttpOnly\tboolean\t否\ttype:cookie 时有效\tdomain\tboolean\t否\ttype:cookie 时有效\tpath\tstring[]\t否\ttype:cookie 时有效\tmaxAge\tnumber\t否\ttype:cookie 时有效, 一个数字, 表示从 Date.now() 得到的毫秒数\texpires\tDate | ()=>Date\t否\ttype:cookie 时有效, 一个 Date 对象, 表示 cookie 的到期日期 (默认情况下在会话结束时过期) 或者[函数，返回一个Data对象]\tsecure\tboolean\t否\ttype:cookie 时有效, 一个布尔值, 表示 cookie 是否仅通过 HTTPS 发送 (HTTP 下默认为 false, HTTPS 下默认为 true)\tsameSite\tboolean  |  string\t否\ttype:cookie 时有效, 一个布尔值或字符串, 表示该 cookie 是否为 \"相同站点\" cookie (默认为 false). 可以设置为 'strict', 'lax', 'none', 或 true (映射为 'strict')\tsigned\tboolean\t否\ttype:cookie 时有效, 一个布尔值, 表示是否要对 cookie 进行签名 (默认为 false). 如果为 true, 则还会发送另一个后缀为 .sig 的同名 cookie, 使用一个 27-byte url-safe base64 SHA1 值来表示针对第一个 Keygrip 键的 cookie-name=cookie-value 的哈希值. 此签名密钥用于检测下次接收 cookie 时的篡改\toverwrite\tboolean\t否\ttype:cookie 时有效, 一个布尔值, 表示是否覆盖以前设置的同名的 cookie (默认是 false). 如果是 true, 在同一个请求中设置相同名称的所有 Cookie（无论路径或域）是否在设置此Cookie 时从 Set-Cookie 消息头中过滤掉","global-参数说明#global 参数说明":"golbal 是一个比较重要的参数，参数类型为 boolean\nglobal = true\n当global值为true时，则表示当前node服务所有controller接口都进行jwt校验。 global参数通常跟 unless一起配合使用。unless参数表示需要排除jwt校验的controller接口。\nglobal = false\n当global值为false时, 则表示不进行全局使用，此时我们就需要手动进行引入使用。\n手动使用\n\n\nimport { Post, UseBefore } from \"@yunflyjs/yunfly\";\nimport { JWTMiddleware, JWTPassThroughMiddleware } from '@yunflyjs/yunfly/build/middleware/JWTMiddleware'\n\n@JsonController('/user')\n@UseBefore(JWTMiddleware)  //controller手动使用jwt\nexport default class JWTController {\n@Inject()  private userService: UserService;\n//\n@Post('/get-user-info')\n@UseBefore(JWTMiddleware) //具体方法手动使用jwt\nasync getUserMsg()Promise<any> {\nreturn {}\n}\n}","passthrough-参数说明#passThrough 参数说明":"passThrough = false\n\n当 JWT 校验不通过时，直接抛出错误，并阻止后面的程序运行。\n等同于手动方式的 JWTMiddleware\n\n\nimport { Post, UseBefore } from \"@yunflyjs/yunfly\";\nimport { JWTMiddleware } from '@yunflyjs/yunfly/build/middleware/JWTMiddleware'\n@JsonController('/user')\n@UseBefore(JWTMiddleware)  //controller手动使用jwt\nexport default class JWTController {\n//\n@Post('/get-user-info')\n@UseBefore(JWTMiddleware) //具体方法手动使用jwt\nasync getUserMsg()Promise<any> {\nreturn {}\n}\n}\n\npassThrough = true\n\n当 JWT 校验不通过时，继续执行后面的逻辑, 不阻塞流程。\n等同于手动方式的 JWTPassThroughMiddleware\n\n\nimport { Post, UseBefore } from \"@yunflyjs/yunfly\";\nimport { JWTPassThroughMiddleware } from '@yunflyjs/yunfly/build/middleware/JWTMiddleware'\n@JsonController('/user')\n@UseBefore(JWTPassThroughMiddleware)  //controller手动使用jwt\nexport default class JWTController {\n//\n@Post('/get-user-info')\n@UseBefore(JWTPassThroughMiddleware) //具体方法手动使用jwt\nasync getUserMsg()Promise<any> {\nreturn {}\n}\n}","jwt暴露接口说明#JWT暴露接口说明":"JWT暴露出如下的一些方法 generateToken,verifyToken,decodeToken,injectToken,JWTMiddleware,JWTPassThroughMiddleware\n\n\n方法名\t说明\tgenerateToken\t根据自定义参数生成jwt秘钥, 例如用户登录时生成秘钥操作\tverifyToken\t校验jwt秘钥是否有效，自带过期重签功能\tdecodeToken\t解码jwt秘钥，不校验秘钥是否过期，此方法一般不用（慎用）\tinjectToken\t生成的jwt秘钥如何处理，可以设置到header头或者cookie中，具体以config.jwt.token 配置项为准\tJWTMiddleware\t(config.jwt.global=false) 时使用，手动使用JWT中间件方式，当JWT校验失败是直接抛出错误信息，并中断执行\tJWTPassThroughMiddleware\t(config.jwt.global=true) 时使用，手动使用JWT中间件方式，当JWT校验失败时继续执行\n\n使用\n\n\nimport { JsonController, Get } from \"@yunflyjs/yunfly\";\nimport { generateToken, verifyToken } from '@yunflyjs/yunfly/build/middleware/JWTMiddleware'\n//\n@JsonController('/jwt')\nexport default class JWTController {\n@Get('/gen-token')\nasync genToken(\n@Ctx() ctx:Context,\n): Promise<AnyOptions> {\nconst token = generateToken({\nctx,\ndata : {\nname:'zane',\nage: 25,\nhobby:['游泳','爬山']\n},\n})\nreturn { token }\n}\n//\n@Get('/verify-token')\nasync verifyToken(\n@Ctx() ctx: Context,\n): Promise<AnyOptions> {\nreturn await verifyToken({ ctx })\n}\n}\n// verify-token 返回值\n// {\n//   name:'zane',\n//   age: 25,\n//   hobby:['游泳','爬山']\n// }","通过-currentuser-获得-jwt-数据#通过 CurrentUser 获得 JWT 数据":"import { JsonController, Get, CurrentUser, UseBefore } from \"@yunflyjs/yunfly\";\n//\n@JsonController('/jwt')\nexport default class JWTController {\n//\n@Get('/get-jwt-data')\nasync getJWTdata(\n@CurrentUser() user: AnyOptions,\n): Promise<AnyOptions> {\nconst { name, age, hobby } = user || {}\nreturn { name, age, hobby }\n}\n}\n// 解码返回值\n// {\n//   name:'zane',\n//   age: 25,\n//   hobby:['游泳','爬山']\n// }","jwt重签机制-expiredpassthrough#JWT重签机制 expiredPassThrough":"值为 true, 当 JWT 过期时，会自动重签，也就是说 JWT 不会过期，JWT 仅用来做参数校验。\n值为 false, 当 JWT 过期时，会向外抛出 401 错误，此时 JWT 可用来做 登录态校验 + 参数校验。","自动重签规则#自动重签规则":"为了保证服务的正常，当jwt过期时，会拿着过期的密钥进行数据解码，不会阻断当前的request请求（对客户端无影响），但JWT内部会进行过期日志打印和token重签。\n\n使用新的token\n\n\n\nJWT 当前支持 header头 和 cookie 两种方式\n当我们的处理方式为cookie类型时，过期会自动重签并设置新的cookie信息（无需做额外处理）。\n当我们的处理方式为header类型时，过期重签需要进行手动处理。\n\n\n当 JWT 需要签名或者重签时，请求的Header头会返回一个特殊的重签头标识: Set-${key}, 默认标识为Set-Authorization（此处标识取决于你config.jwt.token.key字段）,因此我们需要在客户端统一拦截接口的Header返回头标识，当发现有Set-${key}返回头标识时，取值并覆盖客户端过期的token即可。\n下面以axios为例","全局拦截#全局拦截":"// ---------------------全局拦截---------------------\n// 新增一个全局拦截器\naxios.interceptors.response.use(function (response) {\n// 如果返回token为真时，重新替换本地token\nconst authorization = response.headers['set-authorization'];\nif(authorization) {\nsessionStorage.setItem('token',authorization);\n}\nreturn response;\n}, function (error) {\nreturn Promise.reject(error);\n});","单接口拦截#单接口拦截":"// ----------------------单个接口处理---------------------\naxios({\nmethod: 'post',\nurl: 'http://xxx.com/api/xxx',\ndata: {},\nheaders: {'Authorization': 'xxxxxx'},\n}).then((response)=>{\n// 如果返回token为真时，重新替换本地token\nconst authorization = response.headers['set-authorization'];\nif(authorization) {\nsessionStorage.setItem('token',authorization);\n}\n})\n\n附加： 如果BFF使用cors则需要配置允许的header头字段 exposeHeaders(允许返回的header头信息);\n\n\nconfig.security = {\ncors: {\n// 运行返回头\nexposeHeaders: ['Set-Authorization'],\n},\n}"}},"/document/secruity/methods":{"title":"Methods","data":{"":"BFF 允许的请求 methods, 过滤掉不允许的请求类型","使用#使用":"安装依赖\n\n\nyarn add @yunflyjs/yunfly-plugin-security\n\n新增安全配置 security.methods\n\n\nconfig.security = {\nenable: true,\nmethods: {\nenable: true,\nvalues: ['GET','POST','OPTIONS'],\n}\n}","参数说明#参数说明":"字段\t类型\t必填\t说明\tenable\tboolean\t否\t是否开启\tvalues\tArray<'CONNECT'|'DELETE'|'GET'|'HEAD'|'OPTIONS'|'PATCH'|'POST'|'PUT'|'TRACE'>\t否\t允许的methods类型 （默认值：['GET','POST','OPTIONS']）"}},"/document/secruity/rate-limiter":{"title":"限流","data":{"":"@yunflyjs/yunfly 框架限流插件","说明#说明":"为了防止流量洪峰时应用的崩溃，我们可以采取限流的方式来保护我们的应用，限流有多种规则","限流规则#限流规则":"Node.js应用 整体限流，即： 应用在某一段时间内所有接口的总流量限制\n具体 path 路径限流， 即： 应用在某一段时间内某个具体的 path 路径的流量限制\n具体 path+具体用户限流， 即： 应用在某一段时间内某个 path 单个用户的流量限制","使用#使用":"安装\n\n\nyarn add @yunflyjs/yunfly-plugin-rate-limiter\n\n申明插件 config/config.plugin.ts\n\n\n/**\n* yunfly plugin\n*/\nconst plugins: {[key:string]: string}[] = [\n{\nname: 'rateLimiter',\npackage: '@yunflyjs/yunfly-plugin-rate-limiter',\npriority: 6\n}\n];\n//\nexport default plugins;\n\n开启配置 config/config.default.ts\n\n\nconfig.rateLimiter = {\nenable: true,\nmatch: [],\nignore: [],\nrules: [\n// 限流规则：对整个应用限流\n{\nthreshold: 100,\npos: 'yunfly-example',\nrule_name: '对整个应用限流'\n},\n]\n}","参数说明#参数说明":"interface\n\n\nexport interface RateLimiterConfig {\nenable?: boolean;\nmatch?: string[];\nignore?: string[];\ntype?: 'counter' | 'slideWindow';\nrules?: NeedRateLimiterOption;\n}\n\ninterface NeedRateLimiterOption {\nthreshold: number;\npos: string;\nrule_name?: string;\nargs?: {\nrequest?: ArgsOption[];\nheader?: ArgsOption[];\ncookie?: ArgsOption[];\n};\n}\ninterface ArgsOption {\nkey: string;\nvalue: string;\n}","字段说明#字段说明":"字段\t类型\t必填\t说明\tenable\tboolean\t是\t是否开启配置\ttype\t'counter' | 'slideWindow'\t否\t限流规则算法 counter：计数器  slideWindow：滑动窗口 （默认值：slideWindow，推荐使用slideWindow）\tmatch\tstring[]\t否\t需要开启csrf规则的url列表，命中规则为indexOf, 值为空则命中所有路由\tignore\tstring[]\t否\t需要忽略csrf规则的url列表，命中规则为indexOf\trules\tNeedRateLimiterOption[]\t否\t限流规则","rules-字段说明#rules 字段说明":"字段\t类型\t必填\t说明\tthreshold\tnumber\t是\t限流大小（单机qps）\tpos\tstring\t是\t命中规则：1. Node.js 应用限流，应用名为项目package.name字段 2.path路由限流\targs\tObject\t否\t限流附加命中规则，最多6条，规则之间为且关系\targs.request\tArgsOption[]\t否\t通过query或body参数进行命中（header,cookie同理）\targs.request.key\tstring\t否\t命中key标识\targs.request.value\tstring\t否\t命中标识的value值（当前只支持等于）","流控规则说明#流控规则说明":"字段\t是否重要\t说明\t规则名称\t否\t名称标识\t资源类型\t是\tBFF支持应用级别限流、api路径级别 和 用户级别限流\t资源名称\t是\t当类型为HTTP路由时，需要字节填写api限流地址\t匹配条件\t否\t支持header,cookie,request 三种字段匹配（匹配模式： 全匹配）\t阀值类型\t是\t固定为QPS\t单机QPS阀值\t是\t每秒请求量，（多线程时，实际的限制值是: QPS/线程数）","应用级别限流#应用级别限流":"config.rateLimiter = {\nenable: true,\nrules: [\n// 当 yunfly-example 应用qps大于100时限流生效\n{\nthreshold: 100,\npos: 'yunfly-example',\nrule_name: '对整个应用限流'\n},\n]\n}","api路径级别限流#api路径级别限流":"config.rateLimiter = {\nenable: true,\nrules: [\n// 当path为/api/project/details且header头中有name=zhangshan qps大于10时限流生效\n{\nthreshold: 10,\npos: '/api/project/details',\nrule_name: '对某个具体path限流'\nargs: {\nheader: [\n{\nkey: 'name',\nvalue: 'zhangshan'\n}\n];\n};\n}\n]\n}","用户级别限流#用户级别限流":"config.rateLimiter = {\nenable: true,\nrules: [\n// 当path为/api/project/details 且用户级别qps大于10时限流生效\n{\nthreshold: 10,\npos: '/api/project/details',\nrule_name: '对某个具体path用户级别限流'\nargs: {\nheader: [\n{\nkey: 'x-rate-limiter-user',\nvalue: '*'\n}\n];\n};\n}\n]\n}","获取用户标识#获取用户标识":"默认情况下通过用户 IP 来识别用户。","自定义用户标识#自定义用户标识":"通过 IP 识别用户会有不精准的问题，为了解决此问题支持用户自定义用户标识。\n通过 x-rate-limiter-key 来自定义用户标识， 支持 header, cookie, Request。\n用户标识获取优先级规则\n\n\n优先取 HTTP请求的header头独立用户标识字段（x-rate-limiter-key），\n其次取 Cookie请求头中的（x-rate-limiter-key）\n再次取 Request 参数中的（x-rate-limiter-key）\n最后取 用户的 IP 字段","多条规则命中优先级说明#多条规则命中优先级说明":"有多个规则生效时，谁先生效则限流生效\n多个规则之间相互独立，不互相清零","动态变更规则实时生效#动态变更，规则实时生效":"配置化的限流规则是不够灵活的，对业务来说不能实时生效，基于此插件提供动态更新的 api\n动态更新规则\n\n\nimport { updateRateLimiterRules } from '@yunflyjs/yunfly-plugin-rate-limiter'\n\n// 例如：EtchChange为规则变更监听函数，当规则变更时通过 updateRateLimiterRules api 实时更新限流规则\nEtchChange().then((data: NeedRateLimiterOption)=>{\nupdateRateLimiterRules(data)\n})"}},"/document/secruity/validator":{"title":"Validator","data":{"":"yunfly 底层用的是 routing-controllers，因为 routing-controllers 本身很好地集成 class-validator，所以可以直接使用class-validator进行参数校验。\n推荐结合 @yunflyjs/yunfly-plugin-error 插件一起使用，更好的展示错误信息, 参考地址","使用#使用":"import { Get, JsonController, QueryParams } from '@yunflyjs/yunfly';\nimport { IsEmail, MinLength, MaxLength } from 'class-validator';\n\nclass ParamsVa {\n@IsEmail({\nmessage: 'email 字段不符合邮箱规范!'\n})\nemail: string;\n\n@MinLength(10, {\nmessage: '标题字段太短,最短10个字节',\n})\ntitle: string;\n}\n\n@JsonController('/example')\nexport default class ExampleController {\n\n@Get('/validator')\nasync validator(\n@QueryParams() params: ParamsCheck, // 直接引用 class定义好的ParamsCheck\n): Promise<void> {\nreturn undefined;\n}\n}","常用校验-api#常用校验 API":"","length#@Length":"校验字段长度\n// 大于等于两个字节: x >= 2\n@Length(2)\n// example/validator?name=zhangshan ✅\n// example/validator?name=z ❌\n\n\n// 大于等于2小于等于4个字节： 4 >= x >= 2\n@Length(2, 4)\n// example/validator?name=zhangshan ❌\n// example/validator?name=zs ✅\n\n\n// 自定义提示信息\n@Length(2, 4, {message: '大于等于2小于等于4个字节'})","contains#@Contains":"包含某些信息校验\n// 参数需要包含 hello 信息\n@Contains('hello')\n// example/validator?name=zhangshan ❌\n// example/validator?name=hello-world ✅\n\n// 自定义提示信息\n@Contains('hello', {message: '必须包含hello信息!'})","isint#@IsInt":"判断是否是 number 参数类型，【提示】：不适合 get 请求方式\n// number 类型\n@IsInt()\n\n// 自定义提示信息\n@IsInt({ message: '必须是number类型' });","minmax#@Min、@Max":"@Min: number类型参数必须大于某值\n@Max: number类型参数必须小于某值\n\n\n// x > 1\n@Min(1)\n\n// x < 10\n@Max(10)\n\n// 自定义提示信息\n@Max(10,{ message: '参数值必须小于10' })","isemail#@IsEmail":"参数是否符合邮件格式\n// 是否符合邮件格式\n@IsEmail()\n\n// 自定义提示信息\n@IsEmail({}, { message: '参数不符合邮件格式!' })\n// example/validator?name=zhangshan ❌\n// example/validator?name=752636052@qq.com ✅","isstring#@IsString":"判断是否是 string 类型\n@IsString()\n\n@IsString({ message: '参数必须是 string 类型!' })","minlengthmaxlength#@MinLength、@MaxLength":"@MinLength: 大于等于某个字节长度\n@MaxLength: 小于等于某个字节长度\n\n\n// 必须大于等于10个字节：x >= 10\n@MinLength(10)\n\n// 必须小于等于10个字节：x <= 10\n@MaxLength(10)\n\n// 自定义提示信息\n@MaxLength(10, { message: '参数小于等于10个字节长度!' })\n// example/validator?name=zhangshanwangwu ❌\n// example/validator?name=zhansan ✅","isnotempty#@IsNotEmpty":"非空判断\n@IsNotEmpty()\n\n@IsNotEmpty({ message: '参数不能为空!' })\n// example/validator?name= ❌\n// example/validator?name=zhansan ✅\n更多 API 使用文档请参考: https://www.npmjs.com/package/class-validator"}},"/document/secruity/whitelist":{"title":"Whitelist","data":{"":"BFF 允许的域名白名单, 过滤掉不允许的域名","使用#使用":"安装依赖\n\n\nyarn add @yunflyjs/yunfly-plugin-security\n\n新增安全配置 security.whitelist\n\n\nconfig.security = {\nenable: true,\nwhitelist: {\nenable: true,\nvalues: ['www.baidu.com'],\n},\n};","参数说明#参数说明":"字段\t类型\t必填\t说明\tenable\tboolean\t否\t是否开启\tvalues\tstring[]\t否\t允许通过的 域名  （'*'代表运行所有，'localhost'和'127.0.0.1'不需要添加）"}},"/document/secruity/xframe":{"title":"Xframe","data":{"":"","原理说明#原理说明":"X-Frame-Options HTTP 响应头是用来给浏览器 指示允许一个页面 可否在 <frame>, <iframe>, <embed> 或者 <object> 中展现的标记。站点可以通过确保网站没有被嵌入到别人的站点里面，从而避免 clickjacking 攻击。\n\n\n\nX-Frame-Options 有三个可能的值\n\n\nX-Frame-Options: deny\nX-Frame-Options: sameorigin\nX-Frame-Options: allow-from https://example.com/\n\n值\t说明\tdeny\t表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许\tsameorigin\t表示该页面可以在相同域名页面的 frame 中展示\tallow-from uri\t表示该页面可以在指定来源的 frame 中展示","使用#使用":"安装依赖\n\n\nyarn add @yunflyjs/yunfly-plugin-security\n\n新增安全配置 security.xframe\n\n\nconfig.security = {\nenable: true,\nxframe: {\nenable: true,\nvalue: 'sameorigin',\nmatch: [],\nignore: [],\n}\n}","参数说明#参数说明":"字段\t类型\t必填\t说明\tenable\tboolean\t否\t是否开启\tmatch\tstring[]\t否\t需要开启csrf规则的url列表，命中规则为indexOf, 值为空则命中所有路由\tignore\tstring[]\t否\t需要忽略csrf规则的url列表，命中规则为indexOf\tvalue\tstring\t否\t值为：deny/sameorigin/allow-from uri\n参考地址： https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Frame-Options"}},"/document/secruity/xss":{"title":"XSS","data":{"":"XSS（cross-site scripting跨域脚本攻击）攻击是最常见的 Web 攻击。\n\nXSS 攻击一般分为两类：\n\nReflected XSS（反射型的 XSS 攻击）\nStored XSS（存储型的 XSS 攻击）\n\n\n\n反射型\n\n反射型的 XSS 攻击，主要是由于服务端接收到客户端的不安全输入，在客户端触发执行从而发起 Web 攻击。比如：在某购物网站搜索物品，搜索结果会显示搜索的关键词。搜索关键词填入<script>alert('handsome boy')</script>, 点击搜索。页面没有对关键词进行过滤，这段代码就会直接在页面上执行，弹出 alert。\n存储型\n\n基于存储的 XSS 攻击，是通过提交带有恶意脚本的内容存储在服务器上，当其他人看到这些内容时发起 Web 攻击。一般提交的内容都是通过一些富文本编辑器编辑的，很容易插入危险代码。","防范#防范":"防止表单输入的异常，过滤异常信息字段\n渲染阶段过滤异常信息字段","1-客户端处理#1. 客户端处理":"客户端可使用 js-xss 进行防范\n\njs-xss它有很多辅助函数供我们使用, 这里不做详解, 参考地址： https://github.com/leizongmin/js-xss","2-服务端处理#2. 服务端处理":"安装依赖\n\n\nyarn add @yunflyjs/yunfly-plugin-security\n\n新增安全配置 security.xss\n备注:\n\n\nconfig.xss 是设置的 X-XSS-Protection 头信息，HTTP X-XSS-Protection 响应头是 Internet Explorer，Chrome 和 Safari 的一个特性，当检测到跨站脚本攻击 (XSS (en-US))时，浏览器将停止加载页面\n它并不能够替代手动的输入输出过滤\n\nconfig.security = {\nenable: true,\nxss: {\nenable: true,\nmatch: [],\nignore: [],\nvalue: '1',\n}\n}\n\n字段\t类型\t必填\t说明\tenable\tboolean\t否\t是否开启\tmatch\tstring[]\t否\t需要开启csrf规则的url列表，命中规则为indexOf, 值为空则命中所有路由\tignore\tstring[]\t否\t需要忽略csrf规则的url列表，命中规则为indexOf\tvalue\t`'0'\t'1' | '1;mode=block'`\t否\txss保护类型\n参考地址： https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-XSS-Protection"}},"/document/simple-use/env":{"title":"环境准备","data":{"":"","nodejs-版本#Node.js 版本":"Node.js >= 12.17.0, 推荐使用 node@14+","环境变量#环境变量":"NODE_ENV\tRUNTIME_ENV\t说明\tdev\tlocal\t本地开发环境\tproduction\ttest\t测试环境\tproduction\trelease\t预发布环境\tproduction\tprod\t生产环境\n备注：\n\nNODE_ENV 只区分开发生产环境，主要用来区分本地环境与部署环境\nRUNTIME_ENV 运行时环境, 主要用于不同环境的逻辑区分\n\n\n\n可以在 scripts run 命令中设置 RUNTIME_ENV 环境变量来满足自己的业务需求。\n\n例如：\n\n\nrun 命令\n\n\n{\n\"scripts\":{\n\"run\": \"cross-env PORT=3000 NODE_ENV=production RUNTIME_ENV=test yunfly\",\n}\n}"}},"/document/simple-use/gradually-build":{"title":"逐步搭建","data":{"":"一步一步逐步搭建","设置淘宝镜像源#设置淘宝镜像源":"// npm\nnpm config set registry https://registry.npmmirror.com\n\n// yarn\nyarn config set registry https://registry.npmmirror.com","初始化项目#初始化项目":"","初始化下目录结构#初始化下目录结构":"// 创建目录\nmkdir yunfly-example\ncd yunfly-example\n\n// 初始化 package.json\nyarn init\n\n// 安装依赖\nyarn add @yunflyjs/yunfly\nyarn add cross-env typescript tsconfig-paths gts --dev","配置脚本命令#配置脚本命令":"package.json 中添加 npm scripts 脚本\n\n\n{\n\"scripts\": {\n\"dev\": \"cross-env NODE_ENV=dev PORT=3000 yunfly\",\n\"watch:dev\": \"cross-env NODE_ENV=dev PORT=3000 yunfly --watch\",\n\"run\": \"cross-env PORT=3000 NODE_ENV=production RUNTIME_ENV=prod yunfly\",\n\"build\": \"yarn clean && yarn compile\",\n\"clean\": \"gts clean\",\n\"compile\": \"tsc -p .\"\n}\n}","配置-tsconfigjson#配置 tsconfig.json":"{\n\"compilerOptions\": {\n\"rootDir\": \"./src\",\n\"outDir\": \"./build/\",\n\"module\": \"commonjs\",\n\"target\": \"es2017\",\n\"strict\": true,\n\"allowJs\": false,\n\"noUnusedLocals\": true,\n\"removeComments\": true,\n\"declaration\": true,\n\"skipLibCheck\": true,\n\"importHelpers\": true,\n\"esModuleInterop\": true,\n\"resolveJsonModule\": true,\n\"moduleResolution\": \"node\",\n\"experimentalDecorators\": true,\n\"forceConsistentCasingInFileNames\": true,\n\"emitDecoratorMetadata\": true,\n\"noEmitOnError\": true,\n\"noUnusedParameters\": false,\n\"strictPropertyInitialization\": false,\n\"sourceMap\": false,\n\"declarationDir\": \"./build/\"\n},\n\"include\": [\n\"src/**/*.ts\"\n],\n\"exclude\": [\n\"node_modules\",\n\"src/__tests__\"\n]\n}","编写-controller#编写 Controller":"import { Get, JsonController, BodyParam, Post, QueryParam } from '@yunflyjs/yunfly';\n/**\n* 测试案例controller\n*\n* @export\n* @class TestController\n*/\n@JsonController('/example')\nexport default class ExampleController {\n/**\n* 简单案例 - get\n*\n* @param {string} name 姓名\n* @return {*}  {string}\n* @memberof ExampleController\n*/\n@Get('/simple/get')\nsimple(\n@QueryParam('name') name: string,\n): string {\nreturn name || 'success';\n}\n/**\n* 简单案例 -post\n*\n* @param {string} name 姓名\n* @return {*}  {string}\n* @memberof ExampleController\n*/\n@Post('/simple/post')\nsimple1(\n@BodyParam('name') name: string,\n): string {\nreturn name || 'success';\n}\n}","配置-config#配置 Config":"/**\n* This is an env aggregation default config.\n* (note) this is a minimum config.\n*/\nimport * as path from 'path';\nimport { Config } from '@yunflyjs/yunfly';\n\nconst config = () => {\nconst config: Config = {};\n\n/*\n* routing-controllers configs\n* 1. controllers、middlewares、authorizationChecker 需要使用`path.join`进行文件位置的绝对定位\n* 2. 如果 middlewares 、authorizationChecker中有rpc请求，则需要使用函数包裹。\n*/\nconfig.routingControllersOptions = {\ndefaultErrorHandler: false,\ncontrollers: [path.join(__dirname, '../controller/*')],\nmiddlewares: [path.join(__dirname, '../middleware/*')],\n// middlewares: [\n//   require(path.join(__dirname,'../middleware/xxxMiddleware')).default,\n// ]\ndefaults: {\nnullResultCode: 200,  // 204 | 404\nundefinedResultCode: 200 // 204 | 404\n}\n};\n\nreturn config;\n};\n\nexport default config;\n\n此时目录结构如下：\n\n\nyunfly-example\n├── src\n│   ├── config\n│   │   └── config.default.ts\n│   └── controller\n│       └── ExampleController.ts\n├── package.json\n├── tsconfig.json\n└── yarn.locak","运行项目#运行项目":"yarn dev\nyarn watch:dev\n\n访问应用\n\n\nhttp://127.0.0.1:3000/example/simple/get?name=xxx","生产编译#生产编译":"// 编译\nyarn build\n\n// 运行\nyarn run run"}},"/document/simple-use/quickly-start":{"title":"快速开始","data":{"":"通过框架脚手架快速初始化项目","设置淘宝镜像源#设置淘宝镜像源":"// npm\nnpm config set registry https://registry.npmmirror.com\n\n// yarn\nyarn config set registry https://registry.npmmirror.com","通过脚手架快速初始化#通过脚手架快速初始化":"安装依赖\n\n\nyarn global add @yunflyjs/yunfly-cli\n\n初始化模板\n\n\n# 输入项目名称\nnpx yunfly-cli\n\n# 安装依赖\nyarn install\n\n启动项目\n\n\n// 启动项目\nyarn dev\nyarn watch:dev\n\n访问应用\n\n\nhttp://127.0.0.1:3000/example/simple/get?name=xxx\n\n生产编译\n\n\n// 编译\nyarn build\n\n// 运行\nyarn run run"}},"/document/technology/apm":{"title":"elastic-apm","data":{"":"","概念#概念":"ElasticAPM 是基于Elastic Stack构建的应用程序性能监视系统，它可以嵌入应用进程内部，实时采集各种运行指标并传输到 elasticsearch 平台进行聚合统计，通过 kibana 界面端展示应用系统性能处理能力。node.js 的官方库为 elastic-apm-node, 它提供以下的一些能力：\nhttp 请求响应耗时\nrpc 请求耗时\n函数间调用耗时\n程序异常抛出\n进程CPU，内存使用情况\n拦截 http rpc 请求进行参数透传\n\napm 会对收集到的数据进行图形化展示，把出现性能瓶颈的地方标记出来 ，开发人员定位这些性能问题可以非常便捷，不用再像传统形式那样通过日志记录耗时来一步一步排查。","使用#使用":"安装依赖\n\n\nyarn add @yunflyjs/yunfly-plugin-apm\n增加配置\nconfig.apm = {\nactive: process.env.NODE_ENV === 'production',\n// logLevel: 'fatal',\n};\n\n更多配置参数请参考：https://www.elastic.co/guide/en/apm/agent/nodejs/current/configuration.html","参数透传#参数透传":"","参数透传概念#参数透传概念":"当BFF发起 RPC 或 HTTP 请求时，某些参数不用一层一层的传递，而是 BFF 在直接发起请求时直接使用。","config-参数透传#config 参数透传":"可以在 config 中配置需要透传的参数，请参考以下案例：\nimport { Context } from '@yunflyjs/yunfly';\n\nconfig.translate = (ctx: Context, metadata: any) => {\nconst cookies = cookie.parse(ctx.headers.cookie || '');\nconst orgcode = cookies.orgcode || ctx.headers['orgcode'];\nconst appid = cookies.appid || ctx.headers['appid'];\n\nif (orgcode) { metadata.add('orgcode', orgcode as string); }\nif (appid) { metadata.add('appid', appid as string); }\n};","使用-metadata-函数透传#使用 metadata 函数透传":"可以在客户端请求进入之后的任意位置调用 metadata 函数来进行参数透传，请参考以下案例：\n中间件中透传\n\n\nimport { metadata } from '@yunflyjs/yunfly'\n\nexport default class LoggerMiddleware implements KoaMiddlewareInterface {\nasync use(context: Context, next: (err?: any) => Promise<any>): Promise<any> {\n// 中间件中使用参数透传能力\nmetadata.add('orgcode', 'test-orgcode')\nnext();\n}\n}\n\ncontroller 中使用参数透传\n\n\nimport { metadata, JsonController, QueryParams, Get } from '@yunflyjs/yunfly'\n\n@JsonController(\"/test\")\nexport default class TestController {\n\n@Get(\"/apm-translate\")\nasync APMTranslate(\n@QueryParams() orgcode: string\n): Promise<string> {\n// 路由中使用参数透传能力\nmetadata.add('orgcode', orgcode)\nreturn 'xxxxxx'\n}\n}\n\napm 还有更多的能力，你可以在使用过程中去挖掘"}},"/document/technology/grpc":{"title":"grpc","data":{"":"grpc 能力待完善 ..."}},"/document/technology/http":{"title":"http","data":{"":"在框架内发起一个 HTTP 请求很简单, 我们只需要安装 axios 即可运行。\n安装 axios\n\n\nyarn add axios\n\n请求\n\n\nconst url = 'http://xxx.com/api/get-msg';\n\n// promise\naxios.get(url).then((res)=>{\nconsole.log(res)\n})\n\n// async await\nasync function getData () {\nconst result = await axios.get(url);\n}\naxios 更多用法请参考：http://www.axios-js.com/zh-cn/docs/","参数透传#参数透传":"当 BFF 应用发起 HTTP 请求时，也可以统一向 header 头中传入头信息。具体使用方式请参考：参数透传","ts-类型文件#TS 类型文件":"","openapi-gen-typescript#OpenAPI gen Typescript":"当我们的后端使用的是 JAVA 技术栈时, 后端可以生成完整的 OpenAPI 数据, BFF 或 前端 可以使用 yundoc 把 openapi 生成 ts 代码。详细请参考文档： OpenAPI gen Typescript","proto-gen-typescript#Proto gen Typescript":"当我们后端使用的是 proto 来做接口描述时, BFF 或 前端 可以使用 yungen 把 proto 生成 ts 代码详细参考文档：Proto gen Typescript"}},"/document/technology/prisma":{"title":"prisma","data":{"":"新一代 orm 工具, 支持 MySql SQLite SQL Server MongoDB PostgreSQL","安装#安装":"安装依赖\n\n\n\n\nyarn add @yunflyjs/yunfly-plugin-prisma\n\n\n申明插件\n\n\n\n\nconst plugins: {[key:string]: string}[] = [\n{\nname: 'prisma',\npackage: '@yunflyjs/yunfly-plugin-prisma'\n}\n];\nexport default plugins;\n\n\n启用插件\n\n\n\n\nconfig.prisma = {\nenable: true,\ndb: {\nurl: 'mysql://user:password@localhost:3306/mydb'\n}\n};\nconfig.prisma 配置: 详细说明\n\n初始化 prisma\n\n\n\n\nnpx prisma init\n\n备注：这个命令创建了一个名为 prisma 的新目录，其中包含一个名为 schema.prisma 的文件和一个位于项目根目录中的 .env 文件 schema.prisma 包含prisma 模式以及数据库连接和 prisma 客户端生成器。\n\n\n统一初始化配置\n\n\n\n\nnpx prisma-init --dev\n备注：\nprisma-init 指令说明 参考地址。\n这个命令会更新 .env 和 schema.prisma 文件, 保持配置的一致性。支持 apollo 管理配置。\n\n\n生成 Prisma Client 类型文件\n\n\n\n\nnpx prisma generate\n\n重要提示:\n\n\n\n第一次初始化时，schema.prisma 中需要有 models 配置。\n每次对 Prisma schema 进行更改后，你都需要重新运行命令 prisma generate 去更新生成的 Prisma Client 代码。","使用#使用":"在 Service 中使用 prisma 进行数据的增删改查\nimport { prisma } from '@yunflyjs/yunfly-plugin-prisma';\n\n@Service()\nexport default class UserService {\n\nasync createUser () {\nconst newUser = await prisma.user.create({\ndata: {\nname: 'Alice',\nemail: 'alice@prisma.io',\n},\n});\nreturn newUser;\n}\n\nasync getUserList () {\nconst users = await prisma.user.findMany();\nreturn users;\n}\n\n}\n\n提示： prisma 包含所有自定义 modules 的 Typescript 类型提示, 若 VS CODE 中没有类型提示时，可直接打开一次 node_modules/.prisma/index.d.ts 文件即可","configprisma-配置说明#config.prisma 配置说明":"字段\t类型\t必填\t说明\tenable\tboolean\t是\t是否开启插件\tdb\tDbConfig | ((apolloConfig: ApolloConfig) => DbConfig)\t否\t数据库配置\tclient\tObject\t否\tprisma client 客户端配置项","db-配置说明#db 配置说明":"// interface 类型\ninterface PrismaConfig {\ndb?: DbConfig | ((apolloConfig: ApolloConfig) => DbConfig);\n...\n}\n\ninterface DbConfig {\nurl: string;\ndatabaseUrlKey?: string;\n}\n\nurl: 连接数据库 url 地址，详细请参考：https://prisma.yoga/concepts/database-connectors/mysql#%E8%BF%9E%E6%8E%A5-url\ndatabaseUrlKey: 数据库环境变量名称，默认值为：DATABASE_URL","configclient-配置说明#config.client 配置说明":"interface 类型说明\n\n\ninterface PrismaConfig {\n......\nclient?: {\ndatasources?: Datasources;\nlog?: Array<LogLevel | LogDefinition>;\nerrorFormat?: ErrorFormat;\nrejectOnNotFound?: RejectOnNotFound | RejectPerOperation;\n}\n}\n\n字段\t类型\t说明\tdatasources\tDatasources\t数据源 参考地址\tlog\tArray<LogLevel | LogDefinition>\t确定日志类型和级别 参考地址\terrorFormat\tErrorFormat\t确定 Prisma 返回的错误级别和格式 参考地址\trejectOnNotFound\tRejectOnNotFound | RejectPerOperation\t抛错说明 参考地址","prisma-init-命令行参数#prisma-init 命令行参数":"prisma-init 命令行支持：--dev, --prod, --debug 三个指令\n// 设置环境变量 NODE_ENV = dev，适合于开发环境\nnpx prisma-init --dev\n\n// 设置环境变量 NODE_ENV =production\nnpx prisma-init --prod\n\n// 设置环境变量 DEBUG = prisma-plugin 显示调试信息\nnpx prisma-init --dev --debug","prisma-cli-命令行参数说明#Prisma cli 命令行参数说明":"","prisma-init#prisma init":"初始化 prisma, 用于项目的第一次初始化操作, 它只需要执行一次, 它会在项目中创建一个 .env prisma/schema.prisma 的案例文件。当项目中已存在相关文件时，它会提示文件已存在。\n// 默认初始化\nnpx prisma init\n\n// 指定数据库初始化\nnpx prisma init --datasource-provider mysql\n\n// 指定url进行初始化。 备注：它会检测数据库是否能链接成功\nnpx prisma init --url 'mysql://user:password@localhost:3306/mydb'","prisma-generate#prisma generate":"初始化 prisma 客户端代码, 它的核心能力是生成 Typescript 类型, 初始化 prisma 服务。 会在 node_modules/.prisma 下自动生成所有 modules 的类型文件, 方便开发人员开发, 提升开发效率。\n// 默认初始化客户端代码，当modules有变动时需要重新执行此命令\nnpx prisma generate\n\n// watch 模式生成客户端代码，当 prisma/schema.prisma 文件有改动时，会自动生成客户端代码\nnpx prisma generate --watch","prisma-studio#prisma studio":"图形化管理数据库数据，可以增删改查，不推荐使用，功能不够强大，推荐本地数据库管理工具，例如：Navicat\nnpx prisma studio","prisma-migrate#prisma migrate":"从Prisma模型创建迁移，将其应用于数据库, 它会同步 schema.prisma 中定义的 model 到数据库。\n// 同步 model 到数据库，会创建 migrations 用于储存同步记录\nnpx prisma migrate dev\n\n// 为当前迁移命名\nnpx prisma migrate dev --name=init\n\n// 根据本地 migrations 文件下迁移记录充值 数据库\nprisma migrate reset\n\n// 为生产环境做数据同步\nprisma migrate deploy\n备注:\n可以增加 --name=init 参数为当前迁移命名\n当 model 没有变化时，不会生成新的迁移\n当删除本地 migrations 中迁移记录时，运行 reset 命令会删除数据库相关系信息，请慎重执行。","prisma-db-pull#prisma db pull":"从现有数据库中提取模式，更新Prisma模型\n// 通过数据库表生成 schema.prisma 模型\nnpx prisma db pull\n\n// 只在控制台打印生成的 schema.prisma\nnpx prisma db pull --print\n\n// 强制覆盖本地定义的 model\nnpx prisma db pull --force","prisma-db-push#prisma db push":"将Prisma模型状态推送到数据库\n// 直接同步本地 model 到数据库中 （慎重操作：没有迁移记录，推荐使用 prisma migrate）\nnpx prisma db push\n\n命令行万能发 --help\n\n\nnpx prisma --help\nnpx prisma generate --help\nnpx prisma db pull --help\nprisma 指令：参考文档"}},"/document/technology/prometheus":{"title":"Prometheus","data":{"":"","介绍#介绍":"Node应用错误信息，接口请求次数，RPC性能，HTTP请求性能数据分析与统计，实时查看当前服务QPS,容器运行状况，Node使用资源情况等。 并能自定义各种指标，从而进行监控告警。","使用#使用":"安装依赖\n\n\nyarn add @yunflyjs/yunfly-plugin-prometheus\n\n增加config配置项（可选配置，可忽略）：\n\n\nconfig.prometheus = {\nenable: true,\nlog: false,\nresCodeKeyName: 'code',\n}\n备注：\n升级框架后所有监控指标已经内置， 接下来就是定制我们的图表了。","prometheus-内置指标#prometheus 内置指标":"此次为常用查询语句，请根据你可以根据自己的需要来定制化你的图表语句。","指标名称说明#指标名称说明":"指标名称\t含义\t1. yunfly_client_request_total\tBFF Client请求数量记录 (BFF QPS)  (lable: ['path', 'method', 'status', 'code', 'orgcode'])\t3. yunfly_third_request_total\tBFF HTTP请求数量记录 (HTTP QPS)  (lable: ['path',  'method', 'status', 'code'])\t4. yunfly_http_request_total\tBFF http请求数量记录 (HTTP QPS)  (lable: ['path',  'method', 'status'])\t5. yunfly_error_total\t错误日志的记录次数 (lable: ['type', 'code'], type值类型: ['default'/'rejection'/'exception'])\t7. yunfly_third_error_total\tBFF http请求错误记录次数 (lable: ['code'])\t8. yunfly_http_error_total\tBFF 第三方http接口错误记录次数 (lable: ['path', 'method', 'status'])\t9. yunfly_process_exit_total\t工作进程致命错误退出记录 (lable:  ['type']，type值类型：['worker'/'alone'])\t10. yunfly_res_tracing_h_total\t完整的client请求耗时 lable: ['path', 'method', 'status', 'code']\t12. yunfly_third_tracing_h_total\tBFF http请求耗时 (lable: ['path', 'method', 'status', 'code'])\t13. yunfly_http_tracing_h_total\tBFF http请求耗时 （ labelNames: ['path', 'method', 'status']）","k8s集群环境下一个完整的指标数据案例#K8S集群环境下一个完整的指标数据案例":"yunfly_client_request_total{\napp = \"example-nodejs\",\ncode = \"0\",\ninstance = \"xx.xx.xx.xx:xx\",\njob = \"xxx\",\nkubernetes_namespace = \"xxx\",\nkubernetes_pod_name = \"xxx\",\nmethod = \"GET\",\npath = \"/test/jest\",\npod_template_hash = \"7d564d4bc6\",\nstatus = \"200\"\n}","prometheus查询语句教学#prometheus查询语句教学":"","yunfly_client_request_total#yunfly_client_request_total":"客户端请求QPS[5m][按app分类]\nsum(rate(yunfly_client_request_total[5m]))  by (app)\n\n// 指定BFF名称\nsum(rate(yunfly_client_request_total{app=\"bff-example\"}[5m]))\n\n// 指定租户号\nsum(rate(yunfly_client_request_total{orgcode=\"gzminjieadmin_test\"}[5m]))  by (app)\n\n// 指定path地址\nsum(rate(yunfly_client_request_total{path=\"/test/api\"}[5m]))  by (app)\n负载最高的前10条接口[5m][按app,path分类]\nsum(topk(10,increase(yunfly_client_request_total{}[5m]))) by (app, path)\n\n// 指定BFF名称\nsum(topk(10, increase(yunfly_client_request_total{app=\"bff-example\"}[5m]))) by (path)\n\n\n可根据path, method, status, code, orgcode 进行条件限制\n\n\n\nLable字段\t类型\t描述\tpath\tstring\tapi地址\tmethod\tstring\t请求方式[GET/POST]\tstatus\tnumber\thttp请求返回状态码，成功：200\tcode\tstring/number\tapi请求body对象中返回的code值 [此参数由于是body中返回的字段，因此取决于业务方返回是否定义此字段]\torgcode\tstring\t租户号 [租户号取header头或者cookie信息中的orgcode字段，若业务方未带则为空]","yunfly_res_tracing_h_total#yunfly_res_tracing_h_total":"接口平均耗时[5m][按app分类]\nsum(increase(yunfly_res_tracing_h_total_sum[1m])) by (app) / sum(increase(yunfly_res_tracing_h_total_count[1m])) by (app)\n\n// 指定BFF名称\nsum(increase(yunfly_res_tracing_h_total_sum{app=\"bff-example\"}[1m])) / sum(increase(yunfly_res_tracing_h_total_count{app=\"bff-example\"}[1m]))\n95%百分位耗时[5m][按app分类]\nhistogram_quantile(0.95, sum(rate(yunfly_res_tracing_h_total_bucket[5m])) by (le,app))\n\n// 指定BFF名称\nhistogram_quantile(0.95, sum(rate(yunfly_res_tracing_h_total_bucket{app=\"bff-example\"}[5m])) by (le))\n一段时间内平均请求耗时最高的前10条API地址\ntopk(10,sum(rate(yunfly_res_tracing_h_total_sum{app=\"bff-yunke-performance\"}[1m])) by (path) / sum(rate(yunfly_res_tracing_h_total_count{app=\"bff-yunke-performance\"}[1m])) by (path))\n\n\n可根据path, method, status, code 进行条件限制","yunfly_third_request_total#yunfly_third_request_total":"Node 应用内部发起的 HTTP 请求总数HTTP请求QPS[5m][按app分类]\nsum(rate(yunfly_third_request_total[5m]))  by (app)\n负载最高的前10条RPC请求[5m][按app,path分类]\nsum(topk(10, rate(yunfly_third_request_total{}[5m]))) by (app,path)\n\n字段\t类型\t描述\tpath\tstring\tBFF请求第三方api完整path地址\tmethod\tstring\t请求方式[GET/POST]\tstatus\tnumber\thttp请求返回状态码，成功：200\tcode\tstring/number\tapi请求body对象中返回的code值 [此参数由于是body中返回的字段，因此取决于业务方返回是否定义此字段]","yunfly_third_tracing_h_total_sum#yunfly_third_tracing_h_total_sum":"Node 应用内部发起的 HTTP 请求性能。HTTP接口平均耗时[5m][按app分类]\nsum(increase(yunfly_third_tracing_h_total_sum[1m])) by (app) / sum(increase(yunfly_third_tracing_h_total_count[1m])) by (app)\nHTTP 95%百分位耗时[5m][按app分类]\nhistogram_quantile(0.95, sum(rate(yunfly_third_tracing_h_total_bucket[5m])) by (le,app))","yunfly_http_request_total#yunfly_http_request_total":"HTTP请求QPS[5m][按app分类]\nsum(rate(yunfly_http_request_total[5m]))  by (app)\n负载最高的前10条RPC请求[5m][按app,path分类]\nsum(topk(10, rate(yunfly_http_request_total{}[5m]))) by (app,path)\n\n字段\t类型\t描述\tpath\tstring\tBFF请求第三方api完整path地址\tmethod\tstring\t请求方式[GET/POST]\tstatus\tnumber\thttp请求返回状态码，成功：200","yunfly_http_tracing_h_total_sum#yunfly_http_tracing_h_total_sum":"HTTP接口平均耗时[5m][按app分类]\nsum(increase(yunfly_http_tracing_h_total_sum[1m])) by (app) / sum(increase(yunfly_http_tracing_h_total_count[1m])) by (app)\nHTTP 95%百分位耗时[5m][按app分类]\nhistogram_quantile(0.95, sum(rate(yunfly_http_tracing_h_total_bucket[5m])) by (le,app))","yunfly_error_total#yunfly_error_total":"Node.js 应用错误请求数错误数量[5m][按app分类]\nsum(increase(yunfly_error_total{}[5m])) by (app)\n\n// 指定BFF\nsum(increase(yunfly_error_total{app=\"bff-example\"}[5m]))\n\n// 指定错误类型\nsum(increase(yunfly_error_total{app=\"bff-example\", type=\"rejection\"}[5m]))\n错误频率[5m][按app分类]\nsum(rate(yunfly_error_total{}[5m])) by (app)\n\n字段\t类型\t描述\ttype\tdefault/rejection/exception\t错误类型，rejection：为未捕获的Promise错误, exception：为未捕获的异常错误\tcode\tstring/number\t错误code码","yunfly_third_error_total#yunfly_third_error_total":"BFF第三方HTTP接口请求错误HTTP错误数量[5m][按app分类]\nsum(increase(yunfly_third_error_total{}[5m])) by (app)\n\n// 指定BFF\nsum(increase(yunfly_third_error_total{app=\"bff-example\"}[5m]))\nPRC错误频率[5m][按app分类]\nsum(rate(yunfly_third_error_total{}[5m])) by (app)\n\n字段\t类型\t描述\tcode\tstring/number\tapi请求body对象中返回的code值 [此参数由于是body中返回的字段，因此取决于业务方返回是否定义此字段]\nHTTP错误数量[5m][按app分类]\nsum(increase(yunfly_http_error_total{}[5m])) by (app)\n\n// 指定BFF\nsum(increase(yunfly_http_error_total{app=\"bff-example\"}[5m]))\nPRC错误频率[5m][按app分类]\nsum(rate(yunfly_http_error_total{}[5m])) by (app)\n\n字段\t类型\t描述\tcode\tstring/number\tapi请求body对象中返回的code值 [此参数由于是body中返回的字段，因此取决于业务方返回是否定义此字段]","yunfly_process_exit_total#yunfly_process_exit_total":"Worker进程重启次数[5m][按app分类]\nsum(increase(yunfly_process_exit_total{type=\"worker\"}[5m])) by (app)\n\n// 指定BFF\nsum(increase(yunfly_process_exit_total{type=\"worker\",app=\"bff-example\"}[5m]))\nAlone进程重启次数[5m][按app分类]\nsum(increase(yunfly_process_exit_total{type=\"alone\"}[5m])) by (app)\n\n字段\t类型\t描述\ttype\tworker/alone\t进程类型","bff告警规则使用说明#BFF告警规则使用说明":"","yunfly_client_request_total-1#yunfly_client_request_total":"BFF Client请求数量记录\n\n告警指标需要业务方根据自己的情况进行定制\n\n\n\n案例：\n\n\n// 1分钟内平均QPS大于1000\nsum(rate(yunfly_client_request_total{}[1m])) by (app) > 1000\n\n// 加上条件限制\n// 1分钟内平均QPS大于1000并且 [orgcode=gzminjieadmin_test] 的租户\nsum(rate(yunfly_client_request_total{orgcode=\"gzminjieadmin_test\"}[1m])) by (app) > 1000\n\n// 1分钟内平均QPS大于1000并且 [path='/test/getname'] 的api\nsum(rate(yunfly_client_request_total{path=\"/test/getname\"}[1m])) by (app) > 1000\n\n\n根据自身情况来进行告警条件配置\n告警可配置项[时间/并发量/条件限制]\n可根据path, method, status, code, orgcode 进行条件限制\n\n\n\nLab字段\t类型\t描述\tpath\tstring\tapi地址\tmethod\tstring\t请求方式[GET/POST]\tstatus\tnumber\thttp请求返回状态码，成功：200\tcode\tstring/number\tapi请求body对象中返回的code值 [此参数由于是body中返回的字段，因此取决于业务方返回是否定义此字段]\torgcode\tstring\t租户号 [租户号取header头或者cookie信息中的orgcode字段，若业务方未带则为空]","yunfly_res_tracing_h_total-1#yunfly_res_tracing_h_total":"完整的client请求耗时记录\n\n告警指标需要业务方根据自己的情况进行定制\n\n\n\n案例：\n\n\n// 1分钟内 HTTP 调用时间（P99）持续大于 10 秒 [按pord分类]\nhistogram_quantile(0.99, sum(rate(yunfly_res_tracing_h_total_bucket{}[1m])) by (app, kubernetes_pod_name, le)) > 10000\n\n// 1分钟内 HTTP 调用时间（P95）持续大于 5 秒 [按pord分类]\nhistogram_quantile(0.95, sum(rate(yunfly_res_tracing_h_total_bucket{}[1m])) by (app, kubernetes_pod_name, le)) > 5000\n\n// 1分钟内 HTTP 调用时间（P90）持续大于 3 秒 [按pord分类]\nhistogram_quantile(0.90, sum(rate(yunfly_res_tracing_h_total_bucket{}[1m])) by (app, kubernetes_pod_name, le)) > 3000\n\n// 1分钟内 HTTP 调用时间 平均值 持续大于 1 秒 [按pord分类]\nsum(increase(yunfly_res_tracing_h_total_sum{}[1m])) by (app, kubernetes_pod_name) / sum(increase(yunfly_res_tracing_h_total_count{}[1m])) by (app, kubernetes_pod_name) > 1000\n// 或\nsum(rate(yunfly_res_tracing_h_total_sum{}[1m])) by (app,kubernetes_pod_name) / sum(rate(yunfly_res_tracing_h_total_count{}[1m])) by (app,kubernetes_pod_name) > 1000\n\n\n\n根据自身情况来进行告警条件配置\n告警可配置项[时间/阈值/条件限制]\n可根据path, method, status, code 进行条件限制","yunfly_third_request_total-1#yunfly_third_request_total":"BFF内 HTTP请求数量记录\n\n告警配置请参考 yunfly_client_request_total\n可根据 path, method, status, code 进行条件限制\n\n\n\n字段\t类型\t描述\tpath\tstring\tBFF请求第三方api完整path地址\tmethod\tstring\t请求方式[GET/POST]\tstatus\tnumber\thttp请求返回状态码，成功：200\tcode\tstring/number\tapi请求body对象中返回的code值 [此参数由于是body中返回的字段，因此取决于业务方返回是否定义此字段]","yunfly_third_tracing_h_total#yunfly_third_tracing_h_total":"指标 （BFF内 HTTP请求耗时记录）BFF --- THIRD HTTP 调用时间（P99）持续大于 10 秒\nhistogram_quantile(0.99, sum(rate(yunfly_third_tracing_h_total_bucket{}[5m])) by (app, kubernetes_pod_name, le)) > 10000\n\n\n告警配置请参考 yunfly_res_tracing_h_total\n可根据 path, method, status, code 进行条件限制","yunfly_error_total-1#yunfly_error_total":"错误日志的记录次数\n\n告警指标需要业务方根据自己的情况进行定制\n\n\n\n案例\n\n\n// 5分钟内错误量超过阀值1000\nsum(increase(yunfly_error_total{}[5m])) by (app) > 1000\n\n// 加上条件限制\n// 5分钟内错误量超过阀值1000并且 [type='rejection'] 类型的错误\nsum(increase(yunfly_error_total{type=\"rejection\"}[5m])) by (app) > 1000\n\n\n根据自身情况来进行告警条件配置\n告警可配置项[时间/阈值/条件限制]\n可根据type, code 进行条件限制, 其中type的值为 [default/rejection/exception]\n\n\n\n字段\t类型\t描述\ttype\tdefault/rejection/exception\t错误类型，rejection：为未捕获的Promise错误, exception：为未捕获的异常错误\tcode\tstring/number\t错误code码","yunfly_third_error_total-1#yunfly_third_error_total":"BFF HTTP请求错误记录次数\n\n告警配置请参考 yunfly_error_total\n可根据 code 进行条件限制\n\n\n\n字段\t类型\t描述\tcode\tstring/number\tapi请求body对象中返回的code值 [此参数由于是body中返回的字段，因此取决于业务方返回是否定义此字段]","yunfly_process_exit_total-1#yunfly_process_exit_total":"工作进程致命错误退出记录, 此指标只有在BFF开启了多进程之后才有效\n\n\n// 5分钟内单个pord worker 进程重启次数超过5次预警\nsum(increase(yunfly_process_exit_total{type=\"worker\"}[5m])) by (app, kubernetes_pod_name) > 5\n\n\n// 1小时内单个pord alone 进程重启次数超过1次预警\nsum(increase(yunfly_process_exit_total{type=\"alone\"}[1h])) by (app, kubernetes_pod_name) > 1\n\n\n根据自身情况来进行告警条件配置\n告警可配置项[时间/阈值/条件限制]\n可根据type 进行条件限制, 其中type的值为 [worker/alone]\n\n\n\n字段\t类型\t描述\ttype\tworker/alone\t进程类型"}},"/document/technology/redis":{"title":"redis 插件","data":{"":"","使用#使用":"安装依赖\n\n\n\n\nyarn add @yunflyjs/yunfly-plugin-redis\n\n\nconfig.plugin.ts 中声明插件\n\n\n\n\nconst plugins: { [key: string]: string }[] = [\n{\nname: 'redis',\npackage: '@yunflyjs/yunfly-plugin-redis',\n},\n];\nexport default plugins;\n\n\nconfig.default.ts 中启用插件\n\n\n对象\n\n\nconfig.redis = {\nenable: true,\nhost: '127.0.0.1',\nport: 6379,\n};\n\n函数\n\n\nconfig.redis = () => {\nconst host = apolloConfig['EXAMPLE-REDIS-HOST'];\nconst password = apolloConfig['EXAMPLE-REDIS-PASSWORD'];\nconst port = apolloConfig['EXAMPLE-REDIS-PORT'];\nreturn {\nenable: true,\nhost,\npassword,\nport,\n};\n};\n\ncluster 模式\n\n\nconfig.redis = {\nenable: true,\nstartupNodes: [\n{\nport: 6379,\nhost: '127.0.0.1',\n},\n{\nport: 6379,\nhost: '127.0.0.2',\n},\n],\noptions: {},\n};\n\n框架中使用\n\n\nimport { redis } from @yunflyjs/yunfly-plugin-redis\n\nawait redis.set('key','example');\nawait redis.get('key');","参数说明#参数说明":"字段\t类型\t必填\t说明\tenable\tboolean\t是\t是否开启 redis 能力\thost\tstring\t是\thost 配置\tport\tnumber\t是\tport 配置\n\n其他通用配置项\n\n\n方法名\t类型\t必填\t说明\tusername\tstring\t否\t鉴权用户\tpassword\tstring\t否\t鉴权密码\tdb\tnumber\t是\t默认数据库（默认为 0）\tkeepAlive\tnumber\t否\t持久链接时间\t......\tany\t否\t其他参数\n\noptions 完整参数 interface：\n\n\ninterface RedisCommonConfig {\nusername?: string;\npassword?: string;\ndb?: number;\nkeepAlive?: number;\nfamily?: number;\nnoDelay?: boolean;\nconnectionName?: string;\ndropBufferSupport?: boolean;\nenableReadyCheck?: boolean;\nenableOfflineQueue?: boolean;\nconnectTimeout?: number;\ndisconnectTimeout?: number;\ncommandTimeout?: number;\nautoResubscribe?: number;\nautoResendUnfulfilledCommands?: number;\nlazyConnect?: number;\ntls?: AnyOptionConfig;\nkeyPrefix?: string;\nretryStrategy?: Function;\nmaxRetriesPerRequest?: number;\nreconnectOnError?: Function;\nreadOnly?: boolean;\nstringNumbers?: boolean;\nenableAutoPipelining?: boolean;\nautoPipeliningIgnoredCommands?: string[];\nmaxScriptsCachingTime?: number;\n}","cluster-模式-配置参数说明#cluster 模式 配置参数说明":"方法名\t类型\t必填\t说明\tenable\tboolean\t是\t是否开启\tstartupNodes\tObject[]\t是\tredis 单机节点\tstartupNodes.host\tstring\t是\t链接地址\tstartupNodes.port\tnumber\t是\t端口\toptions\tObject\t否\t其他参数\n\noptions 详细参数 ts 类如下：\n\n\ninterface RedisClusterCommonConfig {\nclusterRetryStrategy?: Function;\ndnsLookup?: any;\nenableOfflineQueue: boolean;\nenableReadyCheck?: boolean;\nscaleReads?: string;\nmaxRedirections?: number;\nretryDelayOnFailover?: number;\nretryDelayOnClusterDown?: number;\nretryDelayOnTryAgain?: number;\nslotsRefreshTimeout?: number;\nslotsRefreshInterval?: number;\nredisOptions?: AnyOptionConfig;\n}\ninterface StartupNodesConfig {\nport: number;\nhost: string;\n}\ninterface RedisClusterConfig {\nenable: boolean;\nstartupNodes: StartupNodesConfig[];\noptions?: RedisClusterCommonConfig;\n}\n\n配置参数含义请参考ioredis： https://www.npmjs.com/package/ioredis","redis-常见使用案例#Redis 常见使用案例":"","字符串-string#字符串 (string)":"如果 key 已经存储其他值， SET 就覆写旧值，且无视类型。","set#set":"将键 key 设定为指定的“字符串”值。\n\n返回值：\n如果 SET 命令正常执行那么回返回 OK，否则如果加了 NX 或者 XX 选项，但是没有设置条件。那么会返回 null。\n\n\n// 设置key：'key1' 的值为'bff-example'，并且 10 秒之后过期。\nawait redis.set('key1', 'bff-example', 'EX', 10); // return \"OK\"\n备注：\n\nkey 尽量带上 团队名或者空间名前缀\nvalue 值是字符串，如果是对象，请做好数据转换处理。\n尽量设置过期时间， 单位为 【秒】。","get#get":"返回 key 的 value。如果 key 不存在，返回特殊值 null。如果 key 的 value 不是 string，就返回错误，因为 GET 只处理 string 类型的 values。\n\n返回值：\nkey 对应的 value，或者 null（key 不存在时）\n\n\nredis.set('key1', 'bff-example', 'EX', 10);\n\nawait redis.get('key1'); // return bff-example\nawait redis.get('key2'); // return null","del#del":"删除字段信息\n\n\nredis.set('key1', 'bff-example', 'EX', 10);\n\nawait redis.del('key1'); // return 'OK'\n\n// 删除多个key\nawait redis.del('key1', 'key2', 'key3');","mget#mget":"返回所有指定的 key 的 value。对于每个不对应 string 或者不存在的 key，都返回特殊值 nil。正因为此，这个操作从来不会失败。\n\n返回值：\n指定的 key 对应的 values 的 list\n\n\nredis.set('key1', 'hello');\nredis.set('key2', 'world');\nredis.set('key3', 'world');\n\nawait redis.mget('key1', 'key2'); // return [\"hello\",\"world\",\"world\"]","mset#mset":"对应给定的 keys 到他们相应的 values 上。MSET 会用新的 value 替换已经存在的 value\n\n返回值：\n总是 OK，因为 MSET 不会失败。\n\n\nawait redis.mset('key1', 'hello', 'key2', 'world'); // return 'OK'\n\nawait redis.get('key1'); // return \"hello\"\nawait redis.mget('key1', 'key2'); // return \"hello\",\"world\"\n\n更多命令请参考： http://www.redis.cn/commands/set.html","集合-sets#集合 (Sets)":"不重复且无序的字符串元素的集合;\nRedis Set 是 String 的无序排列。SADD 指令把新的元素添加到 set 中。对 set 也可做一些其他的操作，比如测试一个给定的元素是否存在，对不同 set 取交集，并集或差，等等。","sadd#sadd":"添加一个或多个指定的 member 元素到集合的 key 中.指定的一个或者多个元素 member 如果已经在集合 key 中存在则忽略.如果集合 key 不存在，则新建集合 key,并添加 member 元素到集合 key 中.\n\n\n返回值：\n返回新成功添加到集合里元素的数量，不包括已经存在于集合中的元素.\n\n\n// 以下两种方式等价\nawait redis.sadd('myset', 'hello', 'world'); // return 'OK'\nawait redis.sadd('myset', ['hello', 'world']); // return 'OK'","scard#scard":"返回集合存储的 key 的基数 (集合元素的数量)。\n\n\n返回值：\n集合的基数(元素的数量),如果 key 不存在,则返回 0.\n\n\nredis.sadd('myset', 'hello', 'world');\nawait redis.scard('myset'); // return 2\nawait redis.scard('myset1'); // return 0","srem#srem":"在 key 集合中移除指定的元素. 如果指定的元素不是 key 集合中的元素则忽略 如果 key 集合不存在则被视为一个空的集合，该命令返回 0\n\n\n返回值：\n从集合中移除元素的个数，不包括不存在的成员.\n\n\nredis.sadd('myset', 'hello', 'world');\nawait redis.srem('myset', 'hello'); // return 1","sunion#sunion":"返回给定的多个集合的并集中的所有成员 【集合并集】\n\n\n返回值：\n并集的成员列表\n\n\nredis.sadd('myset', 'hello', 'world');\nredis.sadd('myset1', 'world', '!');\n\nawait redis.sunion('myset', 'myset1'); // return [\"hello\",\"!\",\"world\"]\nawait redis.sunion('myset3', 'myset4'); // return []\n\n更多集合请参考： http://www.redis.cn/commands/sadd.html","列表-lists#列表 (Lists)":"Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）, 他们基本上就是链表;","lpush#lpush":"将所有指定的值插入到存于 key 的列表的头部。如果 key 不存在，那么在进行 push 操作前会创建一个空列表。 如果 key 对应的值不是一个 list 的话，那么会返回一个错误。\n\n返回值：\n在 push 操作后的 list 长度。\n\n\nredis.lpush('mylist', '!');\nredis.lpush('mylist', 'world');\nredis.lpush('mylist', 'hello');\n\nawait redis.lrange('mylist', 0, 1); // return ['hello','world']","lrange#lrange":"返回存储在 key 的列表里指定范围内的元素。 start 和 end 偏移量都是基于 0 的下标，即 list 的第一个元素下标是 0（list 的表头），第二个元素下标是 1，以此类推。\n偏移量也可以是负数，表示偏移量是从 list 尾部开始计数。 例如， -1 表示列表的最后一个元素，-2 是倒数第二个，以此类推。\n\n返回值：\n指定范围里的列表元素。\n\n\nredis.lpush('mylist', '!');\nredis.lpush('mylist', 'world');\nredis.lpush('mylist', 'hello');\n\nawait redis.lrange('mylist', 0, 0); // return ['hello']\nawait redis.lrange('mylist', 0, 1); // return ['hello','world']\nawait redis.lrange('mylist', -2, -1); // return [\"world\",\"!\"]","lpop#lpop":"移除并且返回 key 对应的 list 的第一个元素。\n\n返回值：\n返回第一个元素的值，或者当 key 不存在时返回 null\n\n\nredis.lpush('mylist', 'hello', 'world');\nawait redis.lpop('mylist'); // return 'world' // 从第一项开始删除\nawait redis.lpop('mylist'); // return 'world'\nawait redis.lpop('mylist'); // return null","lset#lset":"设置 index 位置的 list 元素的值为 value, 当 index 超出范围时会返回一个 error。\n\n\nredis.lpush('mylist', 'hello', 'world');\n\nawait redis.lset('mylist', 0, 'zane'); // return 'OK'   // 替换第一项\nawait redis.lrange('mylist', 0, 10); // return [ 'zane', 'hello' ]\n\n\nrpop、rpush 等同理\n\n\n\n更多列表操作请参考： http://www.redis.cn/commands/lset.html","哈希hashes#哈希（Hashes）":"由 field 和关联的 value 组成的 map。field 和 value 都是字符串的","hset#hset":"设置 key 指定的哈希集中指定字段的值。\n如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联。\n如果字段在哈希集中存在，它将被重写。\n\n返回值：\n1 如果 field 是一个新的字段\n0 如果 field 原来在 map 里面已经存在\n\n\nredis.hset('myhash', 'key1', 'hello');\nredis.hset('myhash', 'key2', 'world');\n\nawait redis.hget('myhash', 'key1'); // return 'hello'\nawait redis.hget('myhash', 'key2'); // return 'world'","hget#hget":"返回 key 指定的哈希集中该字段所关联的值\n\n返回值：\n该字段所关联的值。当字段不存在或者 key 不存在时返回 null。\n\n\nredis.hset('myhash', 'key1', 'hello');\nredis.hset('myhash', 'key2', 'world');\n\nawait redis.hget('myhash', 'key1'); // return 'hello'\nawait redis.hget('myhash', 'key'); // return null","hdel#hdel":"从 key 指定的哈希集中移除指定的域。在哈希集中不存在的域将被忽略。\n\n返回值：\n返回从哈希集中成功移除的域的数量，不包括指出但不存在的那些域\n如果 key 指定的哈希集不存在，它将被认为是一个空的哈希集，该命令将返回 0。\n\n\nredis.hset('myhash', 'key1', 'hello');\nredis.hset('myhash', 'key2', 'world');\n\nawait redis.hdel('myhash', 'key1'); // return 1\nawait redis.hdel('myhash', 'key'); // return 0","hlen#hlen":"返回 key 指定的哈希集包含的字段的数量\n\n返回值：\n哈希集中字段的数量，当 key 指定的哈希集不存在时返回 0\n\n\nredis.hset('myhash', 'key1', 'hello');\nredis.hset('myhash', 'key2', 'world');\n\nawait redis.hlen('myhash'); //return 2\nawait redis.hlen('myhash1'); // return 0","hkeys#hkeys":"返回 key 指定的哈希集中所有字段的名字。\n\n返回值：\n哈希集中的字段列表，当 key 指定的哈希集不存在时返回空列表。\n\n\nredis.hset('myhash', 'key1', 'hello');\nredis.hset('myhash', 'key2', 'world');\n\nawait redis.hkeys('myhash'); // return ['hello','world']\nawait redis.hkeys('myhash1'); // return []","hgetall#hgetall":"返回 key 指定的哈希集中所有的字段和值。返回值中，每个字段名的下一个是它的值，所以返回值的长度是哈希集大小的两倍\n\n返回值：\n哈希集中字段和值的列表。当 key 指定的哈希集不存在时返回空列表。\n\n\nredis.hset('myhash', 'key1', 'hello');\nredis.hset('myhash', 'key2', 'world');\n\nawait redis.hgetall('myhash'); // return { key2: 'world', key1: 'hello' }\nawait redis.hgetall('myhash1'); // return {}\n\n更多哈希操作请参考： http://www.redis.cn/commands/hget.html","其他说明#其他说明":"redis 还有其他数据类型， 例如 Sorted sets,Bit arrays,HyperLogLogs。 由于前端不常用到，再这里暂时不做文档补充。 若有团队需要请联系 BFF 开发人员，这边来补充相应的文档。\nredis 还可用于消费队列，订阅发布消费等场景。"}},"/document/technology/socket":{"title":"Socket","data":{"":"若想启用socket服务，需要做以下几步操作：","服务端#服务端":"","配置#配置":"安装依赖\n\n\n\n\nyarn add @yunflyjs/yunfly-plugin-socket\n\n\nconfig.plugin.ts 中声明插件\n\n\n\n\nconst plugins: { [key: string]: string }[] = [\n{\nname: 'socket',\npackage: '@yunflyjs/yunfly-plugin-socket',\nlifeHook: 'afterStart'\n},\n];\nexport default plugins;\n\n\nconfig.default.ts 中启用 socket\n\n\n\n\n// socket\nconfig.socket = {\nenable: true,\ntype: 'worker',  // 可选值 worker: 随机选择一个worker执行， all: 所有worker都执行, 默认为worker\npath: '/socket.io'\n}","使用#使用":"根目录src下新增socket文件夹\nsocket 文件夹下可新建 controller、middleware 两个文件夹\nmiddleware 可建多个，执行时没有固定的先后顺序，代码案例如下：\n\n\nexport default function socketMiddleware (socket: any) {\nreturn socket.use((socket: any, next: (err?: any) => Promise<any>) => {\n\n// middleware. do something\n\nreturn next();\n});\n}\n\ncontroller 文件夹下固定 MainController.ts 为socket接收入口, MainController 中代码固定如下：\n\n\nexport default function main (socket: any) {\n// 向客户端发送数据案例\nsocket.emit('hello', (data: any) => {\nconsole.log(data);\n});\n// 服务端就收数据案例\nsocket.on('message', (...args: any[]) => {\nconsole.log(args)\n});\n}","客户端#客户端":"由于服务端 socket.io 为2.x版本, 客户端也相应的需要使用 2.x 版本","安装依赖#安装依赖":"yarn add socket.io-client@2","基础使用#基础使用":"import io from 'socket.io-client';\n\nconst socket = io('http://127.0.0.1:3000/', {\npath: '/socket.io', // 此处需要跟服务端path保持一致\ntransports: ['websocket'],\n})\n\n// 接受数据案例\nsocket.on('hello', (...args: any[]) => {\nconsole.log(args)\n});\n\n// 定时发送数据案例\nsetInterval(() => {\nsocket.emit('message', 'hello world!')\n}, 2000)\n\nsocket.io 使用文档： https://socket.io/docs/v2/client-api/"}},"/faq":{"title":"构建报错","data":{"":"","core-jsxxxjs-模块找不到#core-js/xxx/.js 模块找不到":"原因是: 1、core-js没有安装；2、core-js版本低了解决方法: 如果是core-js未安装，则安装即可；如果是core-js版本低了，则升级到最新版本"}},"/":{"title":"Index","data":{"":""}}}